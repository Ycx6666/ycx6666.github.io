[{"title":"操作系统小班讨论GPU图形接口虚拟化技术","url":"/2024/04/操作系统小班讨论GPU图形接口虚拟化技术、 - 副本/","content":"\n\n\n### 原理\n\nGPU图形接口虚拟化的原理主要是通过软件和硬件技术，将单个物理GPU资源虚拟化成多个独立的虚拟显卡资源，从而可以供多个虚拟机或用户同时使用。\n\n在没有虚拟化的情况下，物理GPU直接与单一的主机操作系统和应用程序交互，为其提供图形处理能力。虚拟化后，GPU的物理资源（如处理器核心、显存等）被抽象、封装成多个独立的虚拟GPU（vGPU），每个vGPU可以被单独分配给不同的虚拟机。这样，多个虚拟机就能够共享同一个物理GPU的资源，同时享有GPU加速的优势。\n\n### 主流的GPU虚拟化技术：\n\n\n\n1. **NVIDIA vGPU:** NVIDIA的虚拟GPU(vGPU)技术使得一块物理GPU可以被分割为多个独立的虚拟GPU，每个虚拟GPU都可以被一个虚拟机独立使用。每个虚拟GPU都有自己的分配的GPU内存和独立的GPU调度，此外NVIDIA的vGPU支持CUDA和OpenCL，可以运行AI和深度学习工作负载。\n\n[参考：vGPU使用文档](https://docs.nvidia.com/grid/16.0/grid-vgpu-user-guide/index.html)\n\n2. **AMD MxGPU:** AMD的MxGPU是另一款主流的GPU虚拟化解决方案，它使用基于硬件的SR-IOV（Single Root I/O Virtualization）技术，将一个物理PCIe GPU变成多个PCIe vGPU，每个PCIe vGPU直接透传给虚拟机，实现多虚拟机共享一个物理GPU。每个虚拟机都有自己的虚拟GPU，并且可以使用标准的AMD驱动和开发工具。\n\n[参考：AMD与NVIDIA vGPU方案对比](https://zhuanlan.zhihu.com/p/683147438)\n\n[参考：SR-IOV-Baser GPU 虚拟化，实现真正的工作状态](https://community.amd.com/t5/visual-cloud/sr-iov-baser-gpu-virtualization-for-a-true-workstation/ba-p/414277)\n\n3. **Intel GVT-g:** Intel的图形虚拟化技术GVT-g可以将一个物理GPU分割成多个虚拟GPU，每个虚拟GPU可以被一个虚拟机使用。GVT-g使用软件调度来管理多个虚拟GPU的共享访问，支持Windows和Linux虚拟机，并且可以使虚拟机运行游戏和图形设计软件。\n\n​\t英特尔 GVT-g 是一种为英特尔 GPU（Broadwell 和更高版本）提供中介设备直通的技术。它可用于虚拟化多个客户机虚拟机的 GPU，从而有效地在虚拟机中提供近乎本机的图形性能，并且仍允许主机正常使用虚拟化 GPU。如果希望在没有专用 GPU 的超极本上运行的 Windows 虚拟机中加速图形，以实现完全设备直通\n\n[参考：英特尔GVT-g](https://wiki.archlinux.org/title/Intel_GVT-g)\n\n4. **Virgil 3D project:** Virgil是一个开源项目，旨在允许模拟出的虚拟硬件有GPU，从而为虚拟机提供3D硬件加速。Virgil 3D还可以向客户虚拟机翻译OpenGL和其他GPU命令。\n\n[参考：Virgil 3D：虚拟 GPU ](https://lwn.net/Articles/611212/)\n\n### GPU图形化接口\n\nGPU图形接口虚拟化涉及将GPU的图形渲染能力划分并分配给多个虚拟机或用户，从而使它们能够独立运行图形密集型的应用程序。这包括3D建模、图形设计、视频编辑和游戏等。图形接口虚拟化允许在虚拟环境中使用GPU来进行硬件加速的图形处理，可以显著提升远程桌面和云游戏的体验。\n\n一些关键的技术和产品包括：\n\n1. **NVIDIA GRID**:\n\n   - NVIDIA GRID可用于提供虚拟桌面和应用程序的硬件加速图形。\n   - 利用NVIDIA的Kepler及更高架构的GPU，其中的vGPU（虚拟GPU）技术可以将单个GPU划分成多个虚拟GPU实例供用户使用。\n   - 支持多种虚拟化环境，包括VMware vSphere/ESXi, Citrix XenServer以及云服务如Amazon Web Services。\n\n2. **AMD Multiuser GPU (MxGPU)**:\n\n   - 基于SR-IOV（单根I/O虚拟化）的技术，AMD的MxGPU技术能在GPU硬件级别上实现虚拟化。\n   - 不同于NVIDIA的软件虚拟化方案，MxGPU提供了硬件隔离，旨在提高安全性。\n   - 每个虚拟机都有自己的虚拟GPU，可以直接运行AMD的原生图形驱动。\n\n3. **Intel Graphics Virtualization Technology (Intel GVT)**:\n\n   - Intel GVT分成几个模式，GVT-d, GVT-g 和 GVT-s。\n   - GVT-g允许一个物理GPU在多个VM之间分享，每个虚拟机可以独立访问它的虚拟GPU资源。\n\n4. **Virglrenderer(Virgil 3D project)**:\n\n   - Virglrenderer是一个实现3D加速的项目，它通过GNU/Linux上的QEMU使用GPU硬件加速，提供OpenGL加速渲染。\n   - 它允许客户机通过虚拟化的环境使用GPU，提供图形加速。\n\n5. **VMware vSphere / Horizon View**:\n\n   - VMware的vSphere提供GPU虚拟化方案，通过DirectX或OpenGL\n\n     \n\n### 其中的关键技术\n\n1. **虚拟化软件或Hypervisor**：\n\n   - 它是虚拟化的核心，控制并管理物理硬件资源与虚拟机之间的分配与调度。\n   - Hypervisor在物理主机和虚拟机之间提供一层抽象，拦截虚拟机的硬件请求，并将这些请求转换为对实际物理硬件的操作。\n\n2. **虚拟GPU (vGPU) 技术**：\n\n   - 物理GPU被分割成多个vGPU实例，每个实例都有自己的一部分GPU资源，比如一定量的显存、GPU核心的时间片等。\n   - 每个虚拟机都认为它有自己的GPU，实际上只是使用了物理GPU的一部分资源。\n\n3. **图形驱动和API虚拟化**：\n\n   - 图形驱动程序需要能够理解vGPU，并且转换虚拟机的图形调用到物理GPU。\n   - API虚拟化确保了虚拟环境中的图形API调用（如OpenGL或DirectX）可以正确解释并映射到物理硬件。\n\n4. **资源管理和调度**：\n\n   - 虚拟化平台需要合理管理和调度物理GPU资源给各个vGPU实例。\n   - 好的调度策略可以保证所有虚拟机的图形任务公平且有效率地执行。\n\n5. **直通 (Pass-Through) 和SR-IOV技术**：\n\n   - 直通技术不涉及资源分割，它允许一个虚拟机直接控制和访问一个物理GPU，提供几乎原生的性能。\n   - SR-IOV技术允许一个物理设备呈现为多个分离的虚拟化设备，每个都可以被直接分配给虚拟机。\n\n   \n\n##### 附1：关于Intel GVT的三种模式介绍\n\n1. **GVT-d（直通式/Direct Assignment）**：\n\n   GVT-d是一种完全分配的虚拟化方法，将物理GPU直接分配给一个虚拟机使用。在这种模式下，虚拟机可以直接访问GPU的全部功能，它能提供几乎等同于物理机上的GPU性能。由于GPU被完全分配了，所以同一时间只能有一个虚拟机使用这块GPU，不支持资源共享。\n\n2. **GVT-g（时间共享/Time-sharing）**：\n\n   GVT-g是一种基于时间片的共享GPU资源方法。它将GPU资源分割成多个独立的虚拟GPU（vGPU实例），每个虚拟机获得一个vGPU实例。每个vGPU能够访问物理GPU的一部分资源，并且可以根据时间片轮流访问GPU，以此实现同时多个虚拟机共享GPU资源。这种方法可以支持多用户或多任务场景，适用于需要为多个虚拟机提供图形加速的情况。\n\n3. **GVT-s（空间共享/Space-sharing）**：\n\n   GVT-s与GVT-g相似，都是共享模式，但它通常是在具有SR-IOV（Single Root I/O Virtualization）支持的GPU上使用的。GVT-s通过将GPU的资源划分成多个虚拟功能（VF），然后这些VF可以静态分配给不同的虚拟机。这种模式适合于那些需要固定且隔离GPU资源的场合，每个VF都有独立的GPU资源，不与其他VF共享。\n\n##### 附2：英伟达(NVIDIA)vGPU架构\n\n![image-20240415170250289](https://s2.loli.net/2024/04/15/nEa6i517DIrXSfK.png)","tags":["GPU虚拟化"],"categories":["操作系统"]},{"title":"数据库复习","url":"/2024/04/数据库复习1-md/","content":"\n\n\n#数据库复习(算是?)\n\n<p align=\"center\">\n  <br>\n  <h2 style=\"text-align:center;color:#F4E0EA\">\n    樱春雪\n\t</h2>\n  <br>\n  <br>\n\t<div style=\"text-align:center\">\n    <a href=\"https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master\">湖南大学</a>\n  | <a href=\"https://theme.typora.io/theme/Drake/\">软件工程</a>\n  | <a href=\"https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md\">22级</a>\n</div>\n<br>\n<br>\n  <br>\n</p>\n\n\n\n### 一、绪论\n\n#### 1.数据库管理的五个问题\n\n- 数据**正**确性问题\n- 数据**易**用性问题\n- 数据**完**整性\n- 数据安**全**性问题\n- 数据处理**性**能问题\n\n#### 2.数据库技术的演进\n\n1. 分布式数据库\n2. 面向对象数据库\n3. NoSql数据库\n4. 数据仓库，大数据\n\n#### 3.数据+有用性=信息\n\n1. 类别性:\n\n   每类数据都有很多项，构成一个数据集\n\n2. 有用性：\n\n3. 语义性：\n\n#### 4.数据库需要解决三个问题：空间距离、交通运输成本、速度\n\n#### 5.数据库的特点\n\n![image-20240405222701146](https://s2.loli.net/2024/04/07/Ch2gwibI9faXLR5.png)\n\n \n\n##### 数据库的组成：\n\n数据库有表组成，表包括模式和数据\n\n> 数据库是一个数据的集合，所有的数据都存放在数据库中，数据库中的数据是**海量的、共享的**\n\n数据库严格按类的概念来**组织数据、分类存储**\n\n一份类对应一张表，同类数据都存储在一张表中。\n\n一个**实例**对应表中的**一行数据**，表中的一行数据对应一个实例\n\n类与类之间有关系~>实例与实例之间有关系\n\n#### 6.数据操作\n\n**添加数据、修改数据、删除数据、查询数据、统计数据**\n\n==数据库管理系统==(DBMS)来受理用户的数据操作请求，完成数据操作，反馈结果给用户。\n\n数据库模式中，数据的用户通过数据库应用程序来完成。\n\n**数据库、数据库管理系统和数据库应用程序构成了数据库系统**\n\n#### 7.数据库系统的基本特征\n\n•各种各类的业务数据将**集中**到数据库中，**统一管理**，实现**共享**。\n\n•特性：数据库的**拥有者**相对明确，数据库的**用户**则在**不断扩增，难以事先预测**。\n\n•**数据库应用程序**的**通用性**：能够对不同的**数据库**进行访问。\n\n•**数据库管理系统**、**数据库应用程序**既具有**相互独立性**，又具有**可对接性**，构成**邦联式系统**。数据库访问标准和规范。DBMS开发厂家和数据库应用程序开发商。\n\n•数据库访问标准和规范：**关系数据模型，数据操作表达语言，数据库访问编程接口**。\n\n#### 8.DB的三级模式架构\n\n**内模式**~~~>(概念模式\\内模式映射)~~~>概念模式~~~~>(外模式\\概念模式映射)~~~>外模式\n\n- **系统的结构特性：模块化，分层结构。数据库应用程序和数据库管理系统构成邦联式系统，它俩彼此之间既具有相互独立性，又具有可对接集成性。原因是数据操作的表达，以及数据库访问编程接口，都已形成了国际标准**。\n\n#### 9.数据库其他\n\n•**关系模型**，**事务处理**，**数据库设计方法**m，**SQL**，**ODBC/ JDBC**是数据库技术**发展中的标志性成果，也是数据库技术的核心内容。**\n\n•数据库应用领域的**从业人员**角色有三种：**数据库设计人员**，**数据库系统管理人员**，**数据库应用程序开发人员**。\n\n•流行的数据库管理系统**产品**有**Oracle**，**SQL Server**，**DB2**，**MySQL**。它们各有特色。\n\n### 二、关系数据模型\n\n数据模型\n\n​\t关系数据模型；\n\n​\t数据完整性约束；\n\n​\t关系代数；\n\n​\t关系数据库基本特征；\n\n#### 1.数据模型\n\n> 数据模型是指描述数据、数据间的关系、对数据的约束的有关概念。数据模型包括\n>\n> **数据结构、数据完整性约束、数据运算**三个部分，其目的是**提供一个框架，实现数据操作简单容易，做到数据正确、安全、完整**\n\n#### 2.关系数据模型\n\n==关系就是表==\n\n- 数据结构：二维表\n- 数据完整性约束：实体、引用、域、业务规则\n- 数据运算：关系代数\n\n#### 3.关系的特性\n\n1. 在一个数据库中，表的名字要唯一，不能出现同名的表\n2. 在一个表中，列的名字要唯一，不能出现同名的列\n3. 每行数据表达一个实例，一个实例在一个表中**只有一行数据**\n4. 表中的列具有**对等性、没有等级区别**\n5. 表中的列具有**对等性、没有先后概念**\n\n#### 4.按照原样存储的表的三个问题\n\n- 数据冗余问题\n- 删除问题\n- 修改问题\n\n#### 5.解决\n\n- 判断数据重复\n\n  ==列重复==\n\n  **主键约束**(一个表中是否存在两行数据指向一个对象)\n\n  在一个数据库中，当定义一个表的模式时，必须指明该表的主键\n\n  ==行重复==\n\n  如果行重复，DBMS会拒绝修改，\n\n  ==外键约束==\n\n  在含**外键**的表中**，添加**行数据**，或者**修改**已有**行数据中的外键字段**的值时，DBMS要检查，看**是否违背外键约束\n\n  当定义一个表的模式时，如果引用了其他表的外键，就必须指明，不能遗漏。\n\n  表分为关系表和实体表，实体表中也可能含有外键\n\n- 业务规则约束\n\n#### 6.超键和候选键\n\n~~超键（Super Key） （键也成为 码，如 超码）\n\n关系中的一个属性组（含有1个或多个列的组），其值能唯一标识一个元组（即：行）。这样的属性组称作该关系的超键\n\n如学生信息表中的` 学号 ` 可作为超键，` 号，姓名 `也是超键\n\n 又如，学院信息表中` 学院编号 `，` 学院名称 ` 都是超键\n\n  又如，选课表中` 学号，课程号，学期 ` 是超键\n\n一个属性组，如果其子集是超键，则该属性组也是超键，即任何超键的超集还是超键\n\n~~~候选键（Candidate Key）\n\n满足特殊条件的超键：如果一个超键删除任何一个属性后都不再是超键，则该键为该关系的候选键。即子集都不是超键的超键为候选键\n\n选课表中` 学院编号，学院名称 ` **不是候选键**\n\n任何一个候选键中的属性称作主属性（Prime Attribute）\n\n  不属于任何一个候选键中的属性称作非主属性\n\n#### 7.关系模式\n\n关系的描述称作关系模式，包括关系名、关系中的属性名、属性向域的映象、属性间的数据依赖关系等，记作R(A1 , A2 ,…, An ) \n\nR是关系名（表名），Ai是属性名（列）\n\n属性向域的映象一般直接说明为属性的类型、长度等\n\n某一时刻对应某个关系模式的内容(元组的集合)称作关系\n\n关系模式是型（schema），是稳定的\n\n关系是某一时刻的值，是随时间不断变化的\n\n#### 8.数据完整的反义词是数据损坏\n\n#### 9.确保数据完整性\n\n>**数据**有现实含义，与现实情况相符一致；满足业务规则；\n\n- **实体完整性(约束)**：每个表都有主键，并且作为主键的一个或者多个列对应的值唯一\n- **参照完整性(约束)：**任何外键的值，要么为null，要么存在于另一张表中主键的值，确保不会引用一个==不存在的值==\n- **域完整性(约束):**每一列有明确的数据类型、数据格式和数值范围以及是否可以为==null==\n- **用户自定义完整性(约束)：**针对某一具体应用的数据必须满足的语义要求。–例如，家庭地址数据中，地址相同的两行，其邮政编码也必须相同。又如：列值唯一性，学院编码是主键，学院名称不是主键的一部分，但学院名称也必须保持唯一性，这个唯一性是现实语义上不同学院不能重名**，列唯一性在关系模型中用unique关键字指明某列取值唯一。**\n\n#### 10.DBMS负责数据库中的数据具有完整性\n\n> 如果用户操作会导致数据的完整性被打破，那么DBMS就会拒绝受理他\n>\n> 如果不违背完整性约束，那么就会受理他\n\n#### 11.数据库系统的特性\n\n##### 关系型数据库的表有三种：\n\n- 专一性:数据严格按类分表保存\n- 全局性：一个数据在数据库只存一份，不能重复存储，一个类只对应一个表。\n- 联系性：表与表之间存在联系，体现在外键上。\n\n##### 用户的业务数据表也有三种：局部性、综合性、多样性\n\n- 局部性是指他仅只是数据库中表的部分行和部分列\n- 综合性是指他的列分布在数据库不同的表之中、\n- 多样性是指用户业务所需的表各式各样\n\n#### 12.关系代数的运算类型\n\n![image-20240406205401493](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406205401493.png)\n\n**投影运算会去除相同的行**\n\n**并运算：**\n\n![image-20240406210123580](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406210123580.png)\n\n**差运算**\n\n![image-20240406210146574](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406210146574.png)\n\n**交运算**\n\n![image-20240406210223825](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406210223825.png)\n\n**笛卡尔乘积运算**\n\n![image-20240406211448729](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406211448729.png)\n\n![image-20240406211503212](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406211503212.png)\n\n**更名运算**\n\nP_{(改名) (表格)\n\n##### θ链接\n\n![image-20240406212325068](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406212325068.png)\n\n##### 自然连接\n\n![image-20240406213246413](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406213246413.png)\n\n**自然连接需要两个表有共同的属性；而其中没有的产生联系的行(没有等值的行，不会出现在结果中)；含外键的表是主干表时，对于外简直为null的行，不会出现在结果中。**\n\n#### 13.外联接\n\n> 笛卡尔积、θ链接等待称为内联接\n\n![image-20240406214223357](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406214223357.png)\n\n##### 半联接\n\n半联接起返回左表中与有右表至少匹配依次的数据行\n\n==通俗的来说==\n\n就是只按照组左表中的列来，左表中没有的列不会算进去\n\n##### 除运算\n\n见1.5\n\n实际上就是解决一类问题：**如何得到全部_副表_的_主表_元素\n\n> 全部的那张表是被除的\n\n如：得到选修了全部课程的学生\n\n那么就直接将选课表除以课程表，**注意这样会将他们公共的属性剔除**\n\n![image-20240406215722752](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240406215722752.png)\n\n#### 13.运算的有优先级\n\n- 关系代数具有优先级\n- 一元运算(\\sigma,\\Pi)的优先级高于二元运算，二元运算中横向链接运算(\\times,\\bowtie)高于纵向运算(\\cup,\\cap,\\neg)\n- 括号的运算级最高\n\n##### 五个基本运算\n\n$$\n\\sigma \\Pi \\cup - \\times\n$$\n\n其他运算都可以被表达出来\n\n### 三、数据操作语言DML（SQL的子集)\n\n#### 1.数据操作中，最核心、最关键的问题是查询\n\n#### 2.SQL规范中，select的结果允许重复\n\n#### 3.where子句\n\n比较运算符：**<**、**<** **=**、**>**、**>****=**、=、 **<** **>**\n\n逻辑运算符：**and**，**or**，**not**\n\nbetween：判断表达式的值是否在某范围内\n\n列出工资在500~800之间的老师姓名\n\n#### 4.重复元组的处理\n\n如果要去掉重复元组，可以用distinct指明\n\n```sql\nselect distinct Ssharp\nform SC\n```\n\n#### 5.元组显示顺序\n\n命令：\n\norder by 列名/第几列 [asc\\desc]//从小到大，从大到小\n\n```sql\nselect *\nfrom S\norderd by AGE asc,SNAME desc\n```\n\n#### 6.更名运算\n\nold_name as new_name\n\n==as 可选==\n\n#### 7.字符串操作\n\n列名 [not] like ‘字符串'\n\n**匹配规则**\n\n>- ’%‘：匹配零个或者多个字符串\n>- '_':单个下户线匹配任意单个字符\n>- '[]'：任何在指定范围内的字符\n>\n>[a-f],[abcdef] \n>\n>- '[^]':任何不在指定范围内的字符\n>\n>- [^a-f]\n\n##### Escape\n\n> 被定义为转义字符，\n>\n> 如escape'\\'，定义\\为转移字符，则可用\\%去匹配%,用\\_取匹配_\n\n```sql\nselect *\nfrom C\nwhere CNAME LIKE'%_d\\__' escape'\\''\n```\n\n#### 8.空值\n\nis [not] null\n\n注意事项：\n\n>除is [not] null 之外，空值不满足任何查找条件\n>\n>如果null参与算术运算，则该算术表达式的值为==null==\n>\n>如果null参与比较运算，则可以视为==false==,在SQL-92中可看成unknown\n\n**示例：**\n\n找出成绩值为空的学生号\n\n```sql\nselect Ssharp\nfrom SC\nwhere GRADE is null\n不可写为 where GRADE=null\n```\n\n##### isnull\n\n```sql\nisnull(check_expression,relacement_value)\n```\n\n如果check_expression 值为空，则返回replacement，否则返回check_expression\n\n(类似于三元表达式?)\n\n##### coalesce\n\n```sql\ncoalesce(expression1,expression2)\n```\n\n返回第一个不为null的expression\n\n```sql\nselect ssharp,csharp,coalesec(grade,0)\nfrom sc\n```\n\n##### 缺省情况下空值是==最后输出的==，当指定order by时，降序情况下==首先输出空值==，升序情况下==最后输出空值==。\n\n```sql\norder by is_null,sal\n//首先输出空值，然后在从小到大输出\n```\n\n#### 9.统计\n\n##### 五个基本聚集函数\n\n>- COUNT ~ 求行数\n>- SUM ~求和\n>- AVG ~求平均值\n>- MIN ~求最小值\n>- MAX ~求最大值\n\n注意事项\n\n1. COUNT,MAX,MIN可对**任意类型的字段**，而SUM and AVG只对**数值型字段**\n2. SUM,AVG,MIN,MAX要求**查询结果只有有一列**\n3. 除了COUNT(*),其他函数都**忽略null值，count(列)也会忽略null**\n4. 统计结果是单一的值，从表概念来说，**只有一行**\n\n##### count(*) 和 count(列名)\n\ncount(*)统计所有行，有些字段为空的也统计\n\ncount(列名)该字段为NULL的不统计\n\n#### 10.分组统计(GROUP BY)\n\n> 先对查询结果，选定某一字段或者某些字段进行分组，对查询结果的行，将分组字段的==值相同的行==放在一起构成一个组，于是，可能会形成多个组，再对每个组进行统计\n\n```sql\ngroup by 列名 [having 条件表达式]\n```\n\ngroup by将表中的元组按照指定列上相等的原则分则，然后再每一份组上使用聚集函数，得到单一值\n\nhaving 对分组进行额外选择，只将聚集函数作用在满足额条件的分组上\n\n##### having 和 where 的区别\n\nhaving的粒度是==分组==，where的粒度是==行==\n\n#### 11.集合成员资格:int 子查询\n\n```sql\n表达式 [not] in (子查询)\n```\n\n用于判断表达式的值是否在子查询的结果中。\n\nE.G.\n\n```SQL\nselect *\nfrom s\nwhere SNAME in \n\t\t\t\t\t\t('张军'，'王宏')\n```\n\n#### 12.集合之间的比较:some/all子查询\n\n$$\n表达式\\quad  比较运算符 \\quad \\theta\\quad  some\\quad (子查询)\n$$\n\n> 表达式的值至少与子查询结果中的一个值相比满徐比较运算符\n\n$$\n表达式\\quad 比较运算符\\theta \\quad all \\quad (子查询)\n$$\n\n> 表达式的值与子查询结果中的所有的值相比都满足比较运算符\n\n![image-20240407103019311](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240407103019311.png)\n\n#### 13.集合基数的测试:exist子查询\n\n**测试集合是否为空**\n\n```sqlite\n[not] exists (子查询)\n```\n\n判断子查询的结果集合中是否有任何元组存在\n\n> in后的子查询与外层查询无关，每个子查询执行依次，而exists后的子查询与外层查询有关，需要执行多次，称之为==相关子查询==\n\n#### 14.反半联接not in \\ not exists\n\n#### 15.除法在SQL中的表达\n\n$$\n\\Pi_{s\\#,c\\#}(SC)\\div\\Pi_{c\\#}(C) <=> not\\quad exists...not\\quad exists ...\n$$\n\nE.G.\n\n列出选修了全部课程的学生姓名\n\n```sql\nSELECT SNAME\nFROM S S1\nWHERE NOT EXISTS\n\t(SELECT Csharp\n   FROM C C1\n   WHERE NOT EXISTS \n   \t\t(SELECT *\n      \tFROM SC\n      \tWHERE Csharp=C1.Csharp\n      \tAND Ssharp=S1.Ssharp))\n```\n\n>1. 从学生表S（别名S1）中选择一个学生。\n>2. 接着查看课程表C（别名C1）中的每一条课程记录。\n>3. 对于每个课程，查询选课记录表SC看是否存在一条记录满足以下两个条件：课程号Csharp与当前遍历到的课程C1.Csharp相同，且学生号Ssharp与之前选取的学生S1.Ssharp相同。\n>4. 如果某个课程没有对应上述条件的记录，即某个课程没有被这名学生选修，那么NOT EXISTS条件为真，这意味着C1（即当前遍历的课程）就是这名学生没有选修的课程之一。\n>5. 如果存在任何一个这样的课程（即第二层NOT EXISTS条件为真），说明这名学生并没有选修所有的课程，那么外层的NOT EXISTS条件就为假，这名学生就不会被包含在最终的结果集中。\n>6. 只有当一个学生选修了所有课程，即内层SELECT语句没有找到任何课程（第二层NOT EXISTS条件为假），外层的NOT EXISTS才为真，这名学生的SNAME才会被SELECT语句选取。\n\n#### 16.测试集合是否存在重复元组\n\nunique (子查询)\n\n如果子查询中没有重复元组，则返回true\n\n```sql\nselect PNAME\nfrom PROFF\nwhere unique\n\t(select Psharp\n   from PC\n   where PC.Psharp=PROF.Psharp)\n```\n\n#### 17.派生关系\n\n```sql\n(子查询) as 关系名(列名，列名,...)\n```\n\n```sql\nselect       SNAME ， AVG_GRADE\nfrom\n\t  (select\tSNAME ， avg（GRADE）\n\t\tfrom  \tS，SC\n\t\twhere \tSC.Ssharp = S.Ssharp\n\t\tgroup by\tSNAME)\n       as    result(SNAME ， AVG_GRADE )\n\twhere   \tAVG_GRADE  >=  60\n\n```\n\n#### 18.集合操作\n\n**集合并(union(all))**\n\n**集合交(intersect(all))**\n\n**集合差(except(all))**\n\n> #### 无all的结果会去重，有all的结果不会去重\n>\n> intersect 的优先级高于其他集合操作的优先级\n\n#### 19.笛卡尔乘积 自然连接运算\n\n==笛卡尔乘积运算==\n\n```sql\nSELECT b*,s* \nFROM Branch AS B,staff AS s\n//2.\nSELECT b*,s*\nFROM Brach b\nJOIN staff \n```\n\n//from两个表就做了一次笛卡尔乘积运算\n\n==自然连接运算==\n\n```sql\nSELECT b*,s.name,staffNo,position \nFROM Branch AS b,staff s\nWHERE b.deptNo=s.deptNo\n```\n\n#### 20.关系的链接\n\n![image-20240407112419661](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0(%E7%AE%97%E6%98%AF).assets/image-20240407112419661.png)\n\n#### 21.不等号 <>\n\n#### 22.查询结果作为添加操作的输入\n\n```sql\nINSERT INTO enroll(sno, cno, semester) (SELECT sno, ‘H61030008’, ’2018/01’ FROM student WHERE dno =’24’ AND sno LIKE ’2018%’);\n```\n\n**insert into 表明 [(列名[,列名]...)] (子查询)**\n\n#### 23.复制\n\n**复制一个数据文件到数据库中**\n\n```sql\n\tbulk insert 表名 \n\tfrom  数据文件\n\twith\n\t(batchsize = 指定批处理中的行数,\n\tcheck_constraints,\n\tdatafiletype = 数据文件类型,\n\tfieldterminator = 字段终止符, \n\tmaxerrors = 所容忍的最大错误数目, \n\trowterminator = 行终止符)\n```\n\n#### 24.更新操作\n\n```sql\nupdate 表名\nset 列名=表达式|子查询\n\t\t列名=[.表达式|子查询]\n[where 条件表达式]\n```\n\ne.g.\n\n老师工资上调5%\n\n```sql\nupdate PROF\nset SAL=SAL*1.05\n```\n\n类似于switch...case\n\n```sql\nupdate PROF\nset SAL=\n\tcase SAL\n\t\twhen SAL>200 then SAL*0.9\n\t\twhen SAL<=200 then SAL*0.95\n```\n\n#### 25.删除操作\n\n==delete==\n\n```sql\ndelete from 表名 [where 条件表达式]\n```\n\n> 从表中删除符合条件的元组，没有就全部删除\n\n#### ==truncate table==\n\n- 删除表中的所有行，而不记录单个行删除操作\n- truncate table在功能上与不带where子句的delete语句相同。但truncate table比delete速度快，且使用的系统和事务日志资源少\n- identity计数器重置为种子值\n\n#### 26.总结\n\n关系型数据库中部的表有三性：专一性、全局性、联系性\n\n用户的业务数据表：局部性、综合性、多样性\n\n### 五.数据库定义功能（创建表、三级模式、视图、存储过程）\n\n#### 1.操作符\n\n| SQL功能  | 操作符               |\n| -------- | -------------------- |\n| 数据查询 | SELECT               |\n| 数据定义 | CREATE,ALTER,DROP    |\n| 数据操纵 | INSERT,UPDATE,DELETE |\n| 数据控制 | GRANT,REVOKE         |\n\n#### 2.域类型\n\n- char(n):固定长度的字符串\n- varchar(n)：可变长字符串\n- int：整数\n- smallint：小整数类型\n- numeric(p,d)：定点数，小数点左边p位，右边q位\n- real:浮点数\n- double prrecision：双精度浮点数\n- date:日期\n- time：时间\n- inerval：两个date或time类型数据之间的差\n\n#### 3.基本表的定义(CREATE)\n\n```sql\ncreate  table   表名（\n   列名  数据类型  [default  缺省值]  [not null] [unique]\n   [，列名 数据类型  [default  缺省值]  [not null]]\n   [，primary  key（列名 [，列名] …）]\n   [，foreign  key （列名 [，列名] …） \n\t\t      references  表名 （列名 [，列名] …）]\n    [，check（条件）]）\n\n```\n\n![image-20240408195435827](https://s2.loli.net/2024/04/13/HjP9hXM85GdApWq.png)\n\n#### 4.修改表的定义(ALTER)\n\n格式：\n\n```sql\nalter table 表名\n \t[add 子句] //增加新列和约束\n \t[drop 子句] //删除列和约束\n \t[modify 子句] //修改列定义\n```\n\n#### 5.撤销基本表的定义(drop)\n\n格式：\n\n```sql\ndrop table 表名\n```\n\n#### 6.临时表\n\n>- 草稿簿，试验中间的数据处理\n>- 只记录回滚信息，不记录重做信息\n>- 临时表上的数据更新比其他表快4倍\n\n==私有临时表==\n\n```sql\ncreate table sharpmy_table\n```\n\n==全局临时表==\n\n```sql\ncreate table sharpsharpmy_table\n```\n\n==tempdb==\n\n```sql\ncreate table my_table\n```\n\n#### 7.结构数据模型的三要素\n\n- 数据结构\n- 数据操作\n- 数据的约束条件\n\n#### 8.关系模型\n\n==优点==\n\n- 简单，表的概念直观、单一，用户易理解\n\n- 非过程化的数据请求，数据请求可以不指明路径\n\n- 数据独立性，用户只需提出“做什么”，无须说明“怎么做”\n\n- 坚实的理论基础\n\n==缺点==\n\n- 效率低~>nosql\n\n#### 9.数据库模式\n\n![image-20240408200739499](https://s2.loli.net/2024/04/12/X94POZcoJabg1KQ.png)\n\n- 外模式\n  - 用户的数据视图\n  - 是数据的局部逻辑结构，模式的子集\n- 模式或者概念模式\n  - 所用用户的公共数据视图\n  - 是数据库中全体数据的全局逻辑结构和特性的描述\n\n- 内模式\n  - 又称存储模式\n  - 是数据的物理结构及存储方式\n\n==外模式/模式映像==\n\n- 定义某一个外模式和模式之间的对应关系，映象定义通常包含在各外模式中\n- 当模式改变时，修改外模式/模式映象，使外模式保持不变，从而应用程序可以保持不变，称为数据的逻辑独立性\n\n==模式/内模式影响==\n\n- 定义数据逻辑结构与存储结构之间的对应关系\n- 存储结构改变时，修改模式/内模式映象，使模式保持不变，从而应用程序可以保持不变，称为数据的物理独立性\n\n**外模式/模式映射 视图，存储过程**\n\n三级模式结构及二级映像实现了数据库系统的数据独立性\n\n#### 10.视图\n\n##### **定义视图**\n\n```sql\ncreate view view_name[(列名[,列名]...)]\n\t\t\t\tas (查询表达式)\n\t\t\t\t\t[with check option]\n```\n\n>视图的属性名缺省为子查询结果中的属性名，也可以显式指明\n>\n>with check option指明当对视图进行insert，update时，要检查是否满足视图定义中的条件\n\n##### **撤销视图**\n\n```sql\ndrop view view_name\n```\n\n> 视图是一个虚拟表，定义在一个查询上，因此视图对应的虚拟表的行的集合就是该查询的结果集\n\n##### **特点**\n\n- 当用户需要读取视图对应的结果集时，系统会**临时执行**视图对应的查询，生成临时表供使用，临时表在执行完后不再存在，视图保持为虚拟表\n- sql的语句中，子查询容易大幅增加查询语句的复杂度，因此视图有利于简化用户的查询，也能对用户屏蔽底层细节，并且**视图并不实际存储数据**，空间开销忽略不计\n- 实际上，有时也存在物化视图，即实际生成一个持久化的针对视图的数据表，以提升频繁访问视图的操作的效率\n\n##### **优点**\n\n==个性化服务==\n\n简化了用户观点，不同用户可以从不同角度观察同一数据\n\n==安全性==\n\n“纸币所需\",限制用户数据的访问范围\n\n==逻辑独立性==\n\n试图作为基本表与外模式之间的映像\n\n![image-20240408202641861](https://s2.loli.net/2024/04/12/JlX4SyF5RiQwxBa.png)\n\n##### **进行权限授权**\n\n```sql\ngrant SELECT on avg_sal to\"Tom\"//授予Tom只有查看职工平均工资的权限\n```\n\n##### **进行视图更新**\n\n```sql\ninsert into S \nvalues (null,\"张立\",23,null)//向视图中插入数据\n```\n\n（其实就是把表明换成视图名)\n\n##### 视图更新约束\n\n- select子句中的目标列不能包含聚集函数\n- select子句中不能使用unique或distinct关键字\n- 不能包括group by子句\n- 不能包括经算术表达式计算出来的列\n- 对于行列子集视图一般可以更新（视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主码）\n\n##### 物化视图\n\n- 视图的计算结果被实际存储起来\n\n- 物化视图可以看成是数据库的cache\n\n- 查询物化视图比重新计算视图要快许多\n\n- 需要进行物化视图与基本表之间的一致性维护\n\n- 应用场合\n\n  > 任何需要快速访问派生数据、或视图的重新计算非常昂贵、或查询需要耗费非常高的CPU和磁盘吞吐量的应用场合，都可以使用物化视图来提高效率\n\n**其他好处**\n\n1. 实现了应用程序与数据库的彼此独立，通用性增强，应用程序只见视图，不见表\n2. 增强安全。\n\n##### 视图存在的问题\n\n没有灵活应变性\n\n#### 11.存储过程\n\n##### 优点：提升试图的适应性，使其通用化\n\ne.g.\n\n```sql\nCREATE PROCEDURE my_students(@semesterV IN VARCHAR, @courserV IN VARCHAR, @teacherV IN VARCHAR）AS\nBEGIN\n    SELECT studentNo, name, class \n    FROM student AS S, enroll AS E, course AS C, teacher AS T\n    WHERE S.studentNo = E.studentNo \n                   AND C.courseNo = E.courseNo \n                   AND T.teacherNo =E.teacherNo \n                   ANDＣ.name = @courseV \n                   AND  Ｅ.semester =@semesterV \n                   AND T.name=@teacherV;\nEND; \n```\n\n用户:\n\n```sql\nCALL my_students('2014/01','数据库','杨金珉')\n```\n\n##### 存储过程带来的好处\n\n- 应用程序或者用户见到的是存储过程，视图，而不是表\n- 用户不用学SQL\n- 因为带变量，有很强的适用性和通用性\n- 能够将业务规则约束，放在存储过程中加以实现\n- 函数可以带上返回值\n\n##### 视图和存储过程的差异和联系\n\n- 在用户看来，视图是一个表，存储过程是一个具备特定功能的函数；\n- 视图既然是一个表，用户就可在其上进行五大数据操作；对存储过程，则不具备这种特性；\n- 存储过程尽管它的功能固定，但是带有变量，因此具有适配性，能够满足不同参数下的同一功能要求；\n","tags":["总结","数据库"],"categories":["数据库"]},{"title":"数据库的一些问题","url":"/2024/04/数据库的一些问题/","content":"\n\n\n#数据库的一些问题\n\n<p align=\"center\">\n  <br>\n  <h2 style=\"text-align:center;color:#F4E0EA\">\n    樱春雪\n\t</h2>\n  <br>\n  <br>\n\t<div style=\"text-align:center\">\n    <a href=\"https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master\">湖南大学</a>\n  | <a href=\"https://theme.typora.io/theme/Drake/\">软件工程</a>\n  | <a href=\"https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md\">22级</a>\n</div>\n<br>\n<br>\n  <br>\n</p>\n### sharp一点想法\n\n#### 1.检索至少选修两门课程的学生学号\n\n**思路：**将选修表做==自连接==。也就是把自己和自己做笛卡尔积\n$$\nSC1*SC2\n$$\n如果SC1和SC2的sno(学号)相同，但是cno(课程编号)不同，说明这个人至少选修了两门课程。\n\n那么就可以做如下运算\n$$\n\\sigma _{sc1.sno=sc2.sno\\and sc1.cno!=sc2.cno}(SC1*SC2)\n$$\n最后将学号投影出来\n$$\n\\Pi_{sno}(\\sigma _{sc1.sno=sc2.sno\\and sc1.cno!=sc2.cno}(SC1*SC2))\n$$\n**我们对此进行扩展，如果需要至少选择三门课程的** \n$$\nSC1*SC2*SC3\n$$\n\n#### 2.除法运算的应用\n\n**例：检索全部学生都选修的课程号和课程名**\n\n**思路：**\n\n- 获取所有学生的学号\n\n$$\n\\Pi_{sno}(S)\n$$\n\n- 获取所有的选课记录，然后除以所有学生学号\n\n$$\n\\Pi_{cno,sno}(SC)\\div\\Pi_{sno}(S)\n$$\n\n**这样子会筛选出选课记录中有全部学号的课程的cno**\n\n只有包含了被除数所有的条目才会将除数中的非sno属性筛选出\n\n- 最后投影即可，无需赘述\n","tags":["总结","数据库"],"categories":["数据库"]},{"title":"数据库复习2","url":"/2024/04/数据库复习2-md/","content":"\n\n\n#数据库复习(算是?)2\n\n<p align=\"center\">\n  <br>\n  <h2 style=\"text-align:center;color:#F4E0EA\">\n    樱春雪\n\t</h2>\n  <br>\n  <br>\n\t<div style=\"text-align:center\">\n    <a href=\"https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master\">湖南大学</a>\n  | <a href=\"https://theme.typora.io/theme/Drake/\">软件工程</a>\n  | <a href=\"https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md\">22级</a>\n</div>\n<br>\n<br>\n  <br>\n</p>\n\n\n\n\n### 六.数据库定义功能2\n\n#### 1.索引查询\n\n**定义**\n\n```sql\ncreate [unique] [cluster] index 索引名\non 表名 (列名[asc|desc] [,列名 asc|desc])\n```\n\n1. unique：唯一性索引，不允许表中不同的行在索引列上取相同值。若已经有相同值存在，则系统给出相关信息，不坚辞索引。系统拒绝未被唯一性的插入和更新\n2. cluster：聚簇索引，表中元组按照索引项的值排序并物理的聚簇在一起(索引码到指针的则是非物理聚簇)。一个基本表上只能建一个聚簇索引。\n3. asc/desc:索引表中索引值的排序次序，缺省为asc。\n\n==注意==\n\n> create table时指定的主键或者unique列，均会出发系统**自动创建**响应的索引用作重复性检查。\n\n![image-20240408165335994](https://cdn.jsdelivr.net/Ycx6666 / TyporaImage/KahGvUJ961qYsMb.png)\n\n#### 2.组合索引\n\n- 建立在多个属性列上的索引\n- 如果组合索引建立在A,B,C上，那他只对检索A,A+B,A+B+C列的查询起作用。\n\n![image-20240408165634068](../../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/OBAinmqZMIeY3aS.png)\n\n#### 3.索引的删除\n\n```sql\ndrop index 索引名\n```\n\n> drop index 语句不适用于定义主键或者unique约束时系统自动创建的索引，他们必须通过删除约束来撤销\n\n#### 4.索引的其他说明\n\n- 可以动态地定义索引，即可以随时建立和删除索引\n\n- 不允许用户在数据操作中引用索引。索引如何使用完全由系统决定，这支持了数据的物理独立性\n\n- 应该在使用频率高的、经常用于连接的列上建索引\n\n- 一个表上可建多个索引。索引可以提高查询效率，但索引过多耗费空间，且降低了插入、删除、更新的效率\n\n#### 5.数据完整性的四大保障措施\n\n- 主键约束\n- 外键约束\n- 域约束\n- 业务规则约束\n\n#### 6.一个带有唯一性声明的属性上有多少个NULL  --不限制\n\n#### 7.Foreign key\n\n> 作为主码的关系成为基本关系，作为外码的关系称为依赖关系\n\n==删除基本关系元组==\n\n- RESTRICT方式\n\n​\t只有当依赖关系中没有一个外码与要删除的基本关系的主码值相对应时，才可以删除该元组，否则系统拒绝此删除操作。\n\n- CASCADE方式\n\n​\t将依赖关系中所有的外码之与基本关系中要删除的主码值所对应的元组一起删除。\n\n- SET NULL方式\n\n  删除基本关系中元组时，将依赖关系中与基本关系中被删主码值相对应的外码值置为空值。\n\n  \n\n  ![image-20240408171436210](../../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/RAF6QjY3gpoyPXd.png)\n\n#### 8.全局约束\n\n> 全局约束涉及多个属性见的或多个关系间的联系\n\n```sql\ncreate table SC\n(Ssharp   CHAR(4),\n Csharp   CHAR(4),\n GRADE   SMALLINT,\n primay key (Ssharp, Csharp),\n check(Ssharp in (select Ssharp from S)),\n check(Csharp in (select Csharp from C)))\n\n```\n\n==如果S中删除元组，不会触发CHECK子句，只有对SC表的更新才会触发。==\n\n#### 9.对约束的命名、撤销和添加\n\n命名：\n\n```sql\nconstraint 约束名 <约束条件>\n```\n\n示例：\n\n```sql\nSsharp CHAR(4) constraint S_PK primary key\n```\n\n##### 关系上约束的撤销和添加\n\n撤销用 `alter table...drop constraint... `\n\n添加用 `alter table...add constraint...`\n\n**示例：**\n\n```sql\nalter table S drop constraint S_PK\nalter table SC add constraint SC_CHECK check (Ssharp in select Ssharp from S)\n```\n\n#### 10.触发器\n\n- 表模式(Schema)的定义中，包含了主键、外键、域约束的定义；\n- 业务规则约束用触发器来定义；\n- 所有完整性约束在DBMS内部最终都用触发器来表示；\n- 操作会先出发约束检查和处理，确认可以操作之后才完成操作。\n\n> ==BEFORE触发器==在语句开始做任何增删改查之前就被触发。\n>\n> ==AFTER触发器==在语句结束后触发\n>\n> ==INSTEAD OF触发器==只能在定义视图上\n\n```sql\nCREATE TRIGGER trigger_insertEnroll\nBEFORE INSERT ON enroll\nREFERENCING NEW ROW AS new\nFOR EACH ROW\nBEGIN\ncreditAll integer//定义一个整型变量\nSELECT SUM(credit) INTO credit FROM course //给这个整型变量赋值\nWHERE courseld IN(\n\tSELECT courseld FROM enroll\n\tWHERE studentld=@new.studentld\n\tAND semester=@new.semester) \t\n\tOR couseld=@new.courseld;\nWHEN(creditAll>25)//当大于25分时，就会输出错误信息\n\traise_application_error(200,'这个学期已经选修学分'+@creditAll);\nEND\n```\n\n上面这个用于使用触发器实现每学期选课不超过25学分。\n\n**DBMS内部，所有完整性约束，地使用触发器来表示**\n\n```sql\nWHEN (NOT EXIST SELECT * FROM student WHERE sudentNo = @new.studentNo OR  NOT EXIST SELECT * FROM course WHERE courseNo = @new.courseNo)\n           raise_application_error(“违背外键约束”);\n```\n\n#### 11.删除或者修改中的一个对象\n\n>•**DROP TABLE** **emp;**\n>\n>•**ALTER TABLE** **emp ……..;**\n>\n>\n>\n>•**DROP VIEW** **staff;**\n>\n>•**ALTER VIEW** **staff ……..;**\n>\n>\n>\n>•**DROP PROCEDURE** **add_enroll;**\n>\n>•**ALTER PROCEDURE** **add_enroll;**\n>\n>\n>\n>•**DROP TRIGGER** **staff_insert;**\n>\n>•**ALTER TRIGGER** **staff_insert;**\n\n#### 12.数据库中的对象\n\n![image-20240408174225483](https://cdn.jsdelivr.net/Ycx6666 / TyporaImage/image-20240408174225483.png)\n\ne.g.\n\n假定Booking表漏定义了外键(hotelNo, roomNo), 请针对往Booking表中添加记录，写一个触发器实现此这2个字段的引用完整性；\n\n```sql\nCREATE TRIGGER Booking_trigger \nBEFORE INSERT INTO Booking\nFOR EACH ROW\nBEGIN\n\tDECLARE room_exists INT\n\tSELECT COUNT(*) INTO room_exists \n\tFROM Room\n\tWHERE hotelNo=new.hotel AND roomNo=new.roomNo\n\tIF(room_exist=0) THEN\n\t\tSINGAL SQLSTATE '45000'\n\t\tSET MESSAGE_TEXT='外键引用错误'\n\tEND IF\nEND\n```\n\n#### 13.约束检查--延迟约束\n\n```sql\ndeferred contraints\n```\n\n#### 14.用户自定义数据类型\n\nUDDT:\n\n> 保证数据一致性\n\n格式:\n\n```sql\ncreate domain 域名 数据类型\n```\n\n示例：\n\n```sql\ncreate domain person-name char(20)\n```\n\n**类似于C语言中的**\n\n```sql\ntypedf ADDRESS_LIST{\n\tchar name[10];\n\tchar telephone[20];\n\tchar location[20];\n};\nADDRESS_LIST tom;\n```\n\n### 七.事务（概念、性质和调度)\n\n#### 1.事务概念\n\n> 事务是由一系列操作的序列构成的程序执行单元，这些操作要么都做，要么都不做，是一个不可分割的工作单位.\n\n==SQL中事务的定义==\n\n```sql\n事务以Begin transaction开始，以Commit transaction或 Rollback transaction结束（回滚，也就是撤销已经执行的那部分操作）\n\tCommit transaction表示提交，事务正常结束\n\tRollback transaction表示事务非正常结束，撤消事务已做的操作，回滚到事务开始时状态\n```\n\n#### 2.事务特征\n\n==要求:中间状态对外部不可见==\n\n**例**\n\n```sql\nTRANSACTION BEGIN\n\tUPDATE account SET balance = balance + 10000\n\tWHERE accountNo = '2008043101';\n\t\n\tUPDATE account SET balance = balance - 10000\n\tWHERE accountNo='2008043214';\nEND\nCOMMIT;\n```\n\n==事务特性== --一个DBMS支持事务的化，其所必须满足的特性\n\n- **原子性**\n\n事务中包含的所有操作要么全做，要么全不做\n\n**原子性由恢复机制实现**\n\n- **一致性**\n\n在外部看来，数据库中的数据总是正确的,数据库的一致性状态**由用户负责**；\n\n--数据正确性问题\n\n-有故障时，数据会丢失或者残缺不全\n\n-无故障时，因为数据阻止不合理，导致数据更新异常，冗余，数据不正确；\n\n- **隔离性**\n\n-- 系统必须保证事务不受其它并发执行事务的影响\n\n-- 对任何一对事务T1，T2，在T1看来，T2要么在T1开始之前已经结束，要么在T1完成之后再开始执行\n\n-- 隔离性通过**并发控制机制**实现\n\n- **持久性**\n\n一个事务一旦提交之后，他对数据库的影响必须是永久的\n\n系统发生故障不能改变事务的持久性\n\n持久性通过恢复机制实现\n\n> 一个事务一旦提交了，即使随后发生故障，其结果不会在数据库中丢失\n\n#### 3.事务生命周期图\n\n![image-20240412101836367](../../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/NvYt7VwBHFJqjuG.png)\n\n#### 4.事务调度及其分类\n\n> 有多个事务需要执行时，这组事务对应的的所有操作的执行顺序称为对这组事务的一个调度，表示事务的指令在系统中执行的时间顺序\n\n##### 一组事务的调度必须保证\n\n- 包含了该组所有事务的操作指令\n- 同一个事务中的指令，再调度中的先后顺序，同其在事务内部的先后顺序必须保持一致\n\n##### 串行调度\n\n- 在串行调度中，属于同一事务的指令紧凑在一起\n- 对于有n个事务的事务组，可以有n！个不同的串行调度\n\n##### 并行调度\n\n- 在并行调度中，来自不同事物的指令可以交叉执行\n- 当并行调度等价于某个串行调度时，则称他是正确的。\n\n#### 5.事务调度\n\n**并行和串行**\n\n==基本比较==\n\n- 并行十五容易破坏数据库的一致性\n- 串行事务效率低\n\n==并行的优点==\n\n- 一个事务由不同的步骤组成，所涉及的系统资源也不同。这些步骤可以并发执行，以提高系统的**吞吐量**\n- 系统中存在着周期不等的各种事务，串行会导致难于预测的时延。如果各个事务所涉及的是数据库的不同部分，采用并发会减少**平均响应时间**（例如事务操作的表各不相同）\n\n==总结==\n\n> 事务可以提高系统的吞吐量，也会减少响应时间\n\n#### 6.可恢复调度\n\n##### 事物的恢复\n\n>**事务的恢复**：一个事务失败了，为保证事务的原子性，我们应该能够撤消（回滚）该事务对数据库已经造成的影响，如write过的数据项。如果有其它事务Tx读取了失败事务写入的数据，则该事务Tx也应该撤消（前提是Tx尚未commit，如果已经commited，那么就无法恢复，出现不一致）\n\n**注：**\n\n>对于每对事物T1和T2，如果T2读取了T1所写的数据，则T1必须先于T2提交\n\n##### 级联回滚：\n\n应该避免级联回滚\n\n#### 7.无级联回滚 --不会发生级联回滚的调度\n\n##### 定义\n\n>对于每对事物T1和T2，如果T2读取了T1所写的数据，则T1必须先于T2提交\n\n#### 8.Write和Commit\n\n##### Write又称save：临时性\n\n将数据项的值从内存中写入到数据库中，同时会备份好旧值，以便事务失败的时候需要回滚（将旧值写回该数据项），因此Write对数据库的修改是临时性的\n\n##### Commit：永久性\n\n事务提交之后，会终止该事务，并且所有的备份旧值会被清除，事务对数据项的修改（Write）将因为commit的完成，实现由临时性变为永久性。\n\n#### 9.事务隔离性级别\n\n**数据库事务的个隔离级别有4种，由高到低为**\n\n1. Serializable（可串行化)\n2. Repeatable read (可重复读)\n3. Read committed (读提交)\n4. Read uncommitted (读未提交)\n\n**特点：**\n\n1. 级别越低越容易出现不一致，性能越高\n2. 越高级越不容易出错，性能越低\n\n>**有些业务场景中允许将**DBMS事务隔离性级别配置为非最高级（非可串行化），进而实现更高的性能\n\n#### 10.事务问题\n\n##### 丢失修改\n\n> 两个事务T1和T2读入同一数据并修改，T1提交的结果破坏了T2提交的结果，导致T2的修改丢失\n\n##### 读脏数据\n\n>事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤消，这时T1已修改过的数据恢复原值，T2读到的数据与数据库中数据不一致，则T2读到的数据就是脏数据\n\n##### 不能重复读  --修改其他事务读取的 update\n\n>事务T2读取某一数据后，事务T1对其做了修改，当T2再次读取该数据时，得到与前次不同的值，重复读导致不同值则表示出错，即不能重复读\n\n##### 发生幻象  --插入其他事务读的 insert/delete\n\n>事务T2按一定条件读取了某些数据后，事务T1插入了一些满足这些条件的数据，当T2再次按相同条件读取数据时，发现多了一些记录\n\n#### 11.隔离性级别的定义\n\n- serializable:一个调度的执行必须等价于一个串行调度的结果\n- repeatable read :只允许读取已提交的记录，并要求调度中，一个事务对同一记录的两次读取之间，不存在其他事务对该记录的更新\n- read committed： 只允许读取已提交的记录，但不要求可重复读\n- read uncommitted: 允许读取未提交的记录\n\n#### 12.故障恢复\n\n- 正常执行时的防备措施，为故障恢复做准备\n- 在故障发生后的故障回复措施，保证事物的四个属性\n\n##### 分页方法：\n\n1. 把要访问的数据页读入内存\n2. 数据处理\n3. 把修改了的数据页作为一个新页写回磁盘，注意不要覆盖旧页\n4. 完成第三步之后，在磁盘上删除过时了的旧页\n\n![image-20240412113027132](../../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/ivgL5HD3FR6JplY.png)\n\n==优点==:**简单**\n\n>  **故障恢复方法：如果因故障导致第3步没有完成，那么原数据页还在，就当该事物没有发生看待，保证了事物的原子性；**\n\n==缺点==:**效率不高**\n\n>  **原因是：磁头要在磁盘盘面上到处来回移动。因为磁头一会要读事物要处理的数据页，一会要去磁盘上的哪个地方找一个空闲页来写修改后的数据，还要回过头来删除旧页。**\n\n##### 日志方法(广泛采用)\n\n数据库数据的特点：既要读，也要写\n\n日志数据的特点：单调策略，只写不读\n\n![image-20240412113525506](../../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/et3RPIDspc2g1mu.png)\n\n**将日志缓冲区的内容输出到日志磁盘**\n\n**有两种同步约束：**\n\n1）当数据库缓冲区中的某个内容要输出到数据库磁盘时，必须先把与其相关的日志缓冲区内容输出到日志磁盘(WAL ) ；\n\n**数据库缓冲区中数据要输出到磁盘，是因为当要从磁盘中读数据到内存空间来进行处理时，必须先为其先腾出空间来；**\n\n**2）当事务** Ti 完成，遇到<Ti commit>记录时，要把日志缓冲区的内容输出到日志磁盘，以便保证事物的四个属性；\n\n例子：\n![image-20240412210837657](../../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/Tw6XYeFWzxUNCEq.png)\n\n#### 13.事务故障的恢复方法\n\n##### 特征：事务不能执行下去，未完成\n\n**恢复方法：**\n\n> 恢复方法：执行回卷(Rollback)操作：当事物Ti要撤销时，反向扫描日志内容，对Ti的每项数据操作记录，执行undo(Ti) 操作，使用旧值恢复数据项的原有值，即撤销事务已做的数据操作；直至遇到<Ti start> 记录为止，然后放弃Ti ；\n\n#### 14.系统崩溃故障的恢复方法\n\n1. 重启数据库管理系统\n2. 从日志磁盘读取日志文件\n3. 反向扫描日志，从日志文件的结束位置开始反向扫描，对于在日志中没有<Ti，commit>的事务，执行回滚操作，使用旧值恢复数据项。做undo()处理。\n4. 然后从日志文件的开始位置向前扫描，对日志记录中含有 <Ti,commit>的事务，执行redo(Ti)操作，使用新值赋值数据库中的数据项， 保证事务的生效性。\n\n#### 15.检查点(Checkpoint)概念\n\n做检查点的目的：\n\n> 加快系统崩溃故障恢复过程，基于如下观察\n\n- 扫描整个日志文件很费时\n- 对已经输出到了数据库磁盘的事务数据项没有必要做redo操作\n\n**周期性的做检查点**\n\n1. 暂停当前所有活动事务\n2. 把日志缓冲区的所有日志记录输出带日志磁盘\n3. 把数据库缓冲区的所有修改输出到数据库磁盘\n4. 写一条<checkpoint,<当前活动事务的标识号列表>>日志记录到日志磁盘。\n\n#### 16.有检查点的系统崩溃故障恢复\n\n1. 从日志文件的结尾处反向扫描，直到遇到最近的<checkpoint>记录为止\n2. 对反向扫描中只有<Tistart>，而没有<Ti commit>的事务，执行回滚操作，做撤销处理\n3. 从<checkpoint>开始向前扫描日志记录，对有<Ticommit>的事务，执行redo<Ti>操作。\n\n> 没有检查点时，日志文件反向扫描要到起始位置。检查点加快了故障恢复过程，缩短了恢复时间；\n\n例子：\n\n![image-20240412212101160](../../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/hpQrRmZVwSf9g3t.png)\n\n#### 17.备份操作-应对数据库磁盘故障\n\n**周期性地执行备份(dump) 操作，对磁盘数据库进行磁盘备份:**\n\n**①不再接收客户事务请求，让当前所有活动事务执行完毕；**\n\n**②输出日志缓冲区中的日志记录到日志磁盘中;**\n\n**③输出数据库缓冲区中的缓冲数据到数据库磁盘中;**\n\n**④把数据库磁盘中的数据库文件拷贝到另一个磁盘上；**\n\n**⑤往日志磁盘中写入一条 <dump> 日志记录；**\n\n⑥**接收客户事物请求，恢复正常处理；**\n\n#### 18.数据库磁盘故障的回复方法\n\n**特征**\n\n数据库数据全部丢失\n\n**恢复方法**\n\n1. 用最近备份的数据库磁盘替换掉失效的数据库磁盘\n2. 重启数据库管理系统\n3. 读日志文件，从文件末尾反向扫描直至<dump>记录；\n4. 再顺向扫描日志记录，对有<Ticomit>记录的事务做redo(Ti)操作\n\n例子\n\n![image-20240412212431459](https://cdn.jsdelivr.net/Ycx6666 / TyporaImage/G2STxwgUXbnulhJ.png)\n\n### 八.数据库安全保障技术\n\n#### 1.绪论\n\n•企业的一切信息，活动，财富，都以数据来记载和体现，另外，所有用户的一切信息，活动，财富也都以数据来记载和体现；\n\n•数据都存储在数据库的表中；\n\n•数据要有安全性，就必须对每个访问数据库的用户标识其身份，明确其能访问的数据。对其能访问的数据，还要进一步明确能执行什么样的数据操作。只有这样，数据安全性才有保障。\n\n•安全保障机制必须简单明了，而且完备，安全管理才不会出现漏洞，切实可靠。\n\n#### 2.三道防线\n\n![image-20240412212710034](../../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/fOUxbondpJmI1Fe.png)\n\n#### 3.访问权限管理机制\n\n> 用户登录后，要访问数据库中的每一个对象，还有权限要求，权限的授予可以用**<授予者，对象，权限，被授予者>**四元组来表示\n\n##### 权限管理有三条准则：\n\n1. 某个对象，其创建者拥有对其的**全部权限**;\n2. 一个用户可以将其拥有的权限**授予给其他用户**；\n3. 授权这可**收回其授予出去的权限**，权限的收回具有**连带性**。\n\n#### 4.审计\n\n**•数据库中的另一种安全机制是审计**(Audit)**。审计就如在公共场所安装摄像机，对登录进数据库的用户的一举一动都进行记录。一旦发现安全问题，就可调阅审计记录，查清事实真相。**\n\n#### 5.访问权限管理细则的建立\n\n>**设计人员**定义数据库中的**表模式**，明确**用户类型**，明确每类用户的**业务需求**，并给出每项**业务需求与表的映射关系**。\n\n例如，对于大学教务数据库，用户类别有**学生，老师，教管**。\n\n•**学生类**用户，其**业务需求**包括查阅可选课，选课，查阅成绩，查阅已修课程清单及成绩，已修学分等。\n\n•**老师类**用户，其**业务需求**包括开课申请，获取选修学生名单，登录成绩，查阅自己的开课记录，统计自己年教学工作量等。\n\n•**教管类**用户，**业务需求**：课程、学生、老师管理（包括添加，修改，删除)，给学生分班，查阅学生选课情况，查阅老师授课情况，成绩排名等。\n\n#### 6.访问权限管理细则的实施\n\n>**设计人员**明确了**用户类别**，**业务需求**，**映射关系**，也就明确了每类用户**要访问的对象**，以及对其应具有的**操作权限**。\n\n> **数据库管理人员**(DBA)的一项只要职责就是将设计在数据库中贯彻落实，也就是在数据库中创建表，创建用户类别，然后为每个用户类别指定其能访问的对象，明确其操作权限**。**\n\n> **DBA的另一项职责是管理**每类用户的实例，也就是在数据库中为每个用户创建一个账号，再确定其所属的用户类别。在SQL语言中，用户类别被叫做角色ROLE**。**\n\n#### 7.数据库中访问权限的管理粒度\n\n##### 对数据中的表\n\n- 读权限：SELECT 粒度：表\n\n- 更新权限：INSERT,UPDATE. 粒度：表，还可以进一步**指定到列**\n\n  DELETE; 粒度：表\n\n>•**DBMS中的权限管理**是**粗放型的**。粒度并没有细化到表中的**行**。对于SELECT权限，也没有细化到**列**。**并不能满足业务需求**。\n\n**•细化的其它辅助措施：视图，存储过程，应用程序；**\n\n#### 8.数据库中存储权限的数据结构\n\n![image-20240412213750895](https://cdn.jsdelivr.net/Ycx6666 / TyporaImage/rBW76sXcJMNhzH3.png)\n\n#### 9.创建用户和角色\n\n```sql\nCREATE USER jj IDENTIFIED BY '123';\nCREATE ROLE teacher;\n\nDROP USER jj;\nDROP ROLE teacher;\n```\n\n#### 10.授权\n\n```sql\nGRANT SELECT ON dept TO PUBLIC;//给予所有用户(PUBLIC)访问部门表（dept）查询\nGRANT SELECT UPDATE(salary) ON Emp TO Manager; //给予经理（Manager）角色对员工表（Emp）的查询（SELECT）权限和更新（UPDATE）员工工资（salary）的权限：\nGRANT ALL PRIVILEGES ON Proj TO Diretor WITH GRANT OPTION;//给予主管（Director）角色对项目表（Proj）的所有权限（ALL PRIVILEGES），并且允许主管再授予这些权限给其他用户（WITH GRANT OPTION）：\n```\n\n#### 11.收回权限\n\n```SQL\nREVOKE SELECT ON dept FROM PUBLIC;\nREVOKE ALL PRIVILEGES ON Emp FROM Joe;\n```\n\n#### 12.通过视图来增强安全 --将SELECT权限细化到列\n\n增强安全  ---例如这里要隐隐藏员工表的birthdate和salary\n\n```sql\nCREATE VIEW EmpViw AS\nSELECT eno,ename,...,FROM emp.\n```\n\n//其实就是把视图当作一个表了\n\n#### 13.通过视图来增强安全 --将权限细化到行\n\n```sql\nCREATE VIEW AccountTmp AS\nSELECT eno,name,...,\nFROM emp\nWHERE dno='410';\n```\n\n**授权**\n\n> GRANT SELECT ON AccountEmp TO AccountStaff;\n\n#### 14.用触发器实现安全审计\n\n```sql\nCREATE TRIGGER cheatingEmploee\nAFTER UPDATE OF salary ON Emp\nREFERENCING \n\tOLD ROW AS old\n\tNEW ROW AS new\nFOR EACH ROW\nWHEN (@new.salary>@old.salary*1.1)\n\tINSERT INTO auditEmpSalary\nVALUES(get_user_id(),get_connect_ip()),timestamp(now()),@new.eno,@new.salary,@old.salary)\n```\n\n#### 15.权限管理的简化\n\n用户角色(ROLE)概念的提出\n\n> 不给某个用户授权，而是给角色授权，然后再将角色授予给某个用户\n\n```sql\nGRANT INSERT(s_no, c_no, semester ) ON enroll TO student;\nGRANT UPDATE(class_no, t_no) ON enroll TO administrator;\nGRANT UPDATE(grade) ON enroll TO teacher;\nGRANT SELECT ON enroll TO student, administrator, teacher;\nGRANT DELETE ON enroll TO administrator, student;\n```\n\n> 授权是，不要以用户身份授权，而应该以角色身份授权\n\n```sql\nSET CURRENT_ROLE AS assiant;\nGRANT student TO B GRANTED BY CURRENT_ROLE;\n```\n\n### 九.数据处理性能提升技术\n\n#### 1.绪论\n\n•企业数据集中存储在数据库中，海量的数据。从海量的数据中查找和定位数据非常耗时费力。\n\n•数据集中后，所有用户都要来访问数据库，出现很多用户同时访问情形，数据库服务器成了的负载中心，任务繁重。\n\n•许多企业的系统因性能低下，超出用户容忍，受到非议与责难，影响企业形象。\n\n•从挖掘和利用数据特性，机器特性，以及访问特性找出路。\n\n•有效方法：数据分类/排序、数据索引。\n\n#### 2.数据库性能度量指标\n\n- **事务吞吐量**：单位时间能够处理的交易(事务)数量\n- **响应时间**：完成单个交易所用的时间\n\n==总指标：事务吞吐量/响应时间==\n\n#### 3.充分提高数据库性能的策略\n\n**挖掘和利用**\n\n- 数据特性\n- 硬件特性\n- 数据访问特性\n\n#### 4.将用户访问频繁的数据放在中央位置，把联系紧密的数据临近存储\n\n缓存：可实现磁盘访问的批量化\n\n![image-20240412222023606](https://cdn.jsdelivr.net/Ycx6666 / TyporaImage/21QBICuoWJmcVLK.png)\n\n#### 5.提高的方法\n\n- 方法1: 排序;\n\n- 方法2: 索引 （Tree索引和哈希索引）；\n\n- 方法3: 连续的磁盘存储;\n\n- 方法4: 分类、聚簇;\n\n- 方法5: 内存缓冲;\n\n- 方法6: 并发执行;\n\n- 方法7: 查询优化;\n\n- 方法8: 日志和数据分盘存储；\n\n#### 6.其中与数据库设计有关的方法\n\n- **方法1: 排序;**\n\n- **方法2: 索引 ；**\n\n- **方法3: 连续的磁盘存储;**\n\n- **方法4: 分类、聚簇;**\n\n- **方法5: 内存缓冲;**\n\n- **方法8: 日志和数据分盘存储**\n\n> 方法6“并发执行”和方法7“查询优化” ，完全封装在DBMS中，对数据库设计者DBA透明\n>\n> 其他的方法都需要数据库设计者DBA进行配置\n\n#### 7.减少无效运输--创建索引\n\n##### 语法：\n\n```sql\nCREATE INDEX stu_index ON student(d_no,name);\n```\n\n##### 正确的用索引：\n\n- **不对数据量少的表创建索引**：因为l读磁盘是以页（16k)为单位进行，如果表数据量只有几个页，索引就没意义。就像很少几页的文章，再给它搞个目录页也没有意义；\n\n- **对字符串的字段，例如备注字段，不要创建索引，因为压缩比会小**\n- 对经常作为查询条件、链接运算、排序、分组、UNION，DISTINCT字段，对其创建索引。\n\n#### 8.对于索引的思考\n\n![image-20240412224401802](../../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/zpMLw5nOPdD7UBv.png)\n\n学号sno作为学生表student的主键，其结构为yyyyddssccnn，可以帮助快速定位和检索信息，其中：\n\n\n\n- yyyy 代表年份，\n- dd 代表部门，\n- ss 代表专业代码，\n- cc 可能代表班级，\n- nn 代表个人编号。\n\n\n\n使用这样结构化的主键，我们可以通过WHERE子句中的LIKE操作符来进行模糊匹配查询，这些查询可以高效地利用主键索引（索引前缀匹配原则）：\n\n\n\n- `sno LIKE ‘20172601%’`：查询2017年部门编号为26，班级编号为01的所有学生。\n- `sno LIKE ‘2017260102%’`：查询2017年部门编号为26，班级编号为01，个人编号以02开头的学生。\n- `sno LIKE ‘_ _ _ _2601%’`：查询所有年份中部门编号为26，班级编号为01的学生。\n\n\n\n这些模糊查询大多数情况下能够有效地使用主键索引，特别是当查询模式定位在主键索引的开始部分时。\n\n\n\n至于选课表enroll，其可能的主键为{sno, cno, semester}，也就是学号、课程号和学期联合起来确定一条独特的记录。关于这个主键是否设置差异或者是否需要建立多个索引，要基于以下考虑：\n\n\n\n- 索引选择的顺序应该基于查询条件中最常使用的字段顺序。\n- 不同的索引顺序适用于不同的查询模式。\n- 通常，选择最常用来过滤查询的字段作为索引的最前部，可以获得更好的性能。\n\n\n\n例如：\n\n\n\n- 如果查询经常过滤学期，然后是学号，最后是课程号，那{semester, sno, cno}可能是一个好的选择。\n- 如果查询是基于学号过滤的，那{sno, ...}开头的索引优先级会更高。\n\n\n\n一般情况下，不需要为表的所有可能的主键列组合创建索引，因为这样会造成维护成本高和写入性能下降。实践中，应该根据应用程序查询的实际模式来设计和实现所需要的索引。\n\n#### 9.对于索引的思考 -2\n\n- 传统概念上，索引是为了减少从磁盘到CPU的无效运输\n\n- 数据还有从内存至CPU的运输，是否也要创建索引，减少从内存到CPU的无效运输？\n\n- 数据从磁盘到内存，和由内存到CPU，有什么区别？\n\n- 对于一个表的外键字段，创建索引时，由于很多行的外键字段值相同，该如何处理，以增大压缩比？\n\n- 为了提升性能，索引虽对用户不可见，但是对应用程序可见。\n\n\n\n1. **传统概念上的索引**：确实，传统上认为创建索引的目的之一是为了减少从磁盘读取不必要数据的次数，从而减少I/O操作的时间开销。索引可以帮助数据库快速定位到数据存储位置，减少磁盘的随机访问时间。\n2. **内存至CPU的数据运输**：现在的数据库系统很多都采用了内存数据库技术或者缓存技术，可以将频繁访问的数据保留在内存中。即使在内存中，索引仍然是有用的，因为它仍然可以减少不必要的数据比对操作，从而减少CPU处理时间。因此，索引不只是为了减少硬盘I/O，同样也是为了优化内存中数据的访问效率。\n3. **磁盘到内存，和内存到CPU的区别**：磁盘到内存（Disk to RAM）主要是涉及磁盘I/O操作，速度相对较慢，因为它需要机械移动(如传统HDD)或电子操作(如SSD)。内存到CPU（RAM to CPU）则是涉及将数据从内存传输到CPU，这个速度相对较快，因为都是电子操作，且内存速度通常比磁盘快几个数量级。\n4. **外键字段的索引压缩**：当外键字段的值相同时，可以采用如下方法优化：\n   - **选择合适的压缩级别**：数据库如Oracle允许你为索引选择不同级别的压缩。选择合适的压缩级别可以在提高压缩比和查询性能之间做出平衡。\n   - **使用部分索引**：如果外键字段和查询模式允许，你可以创建只包括常用值或特定值的部分索引。\n   - **Bitmap索引**：对于有大量重复值的外键字段，如在数据仓库环境中，Bitmap索引可能更加有效，因为它们能高效地压缩相同值。\n   - **使用较小的数据类型**：如果外键的引用范围并不大，可以考虑使用较小的数据类型以减少每个索引项的大小。\n5. **索引的可见性**：对用户来说，索引的创建和存在大多数情况下是透明的，即用户无需关心索引的细节，只需关心查询语句即可。然而，对于应用程序和数据库管理员来说，索引对性能的影响是非常明显的。合适的索引可以显著提高数据检索性能，不合适的索引则可能成为性能瓶颈。数据库管理员和开发者可以通过分析查询模式、执行计划等来决定是否创建或优化索引。\n\n#### 10.哈希索引\n\n>当往表中添加一行记录时，对要哈希的字段计算哈希值，然后把该记录存储在磁盘空间中磁盘地址为该哈希值的地方。\n\n> 查询数据行时，用户给出字段值，通过哈希计算，就可发现该记录的磁盘空间地址，直接读到对应的记录，不须要一行一行地去比对；\n\n##### 适合使用哈希索引的表特性：\n\n\n\n1. **主要用于等值查询**：哈希索引非常适合于那些主要涉及键值完全匹配查询的场景，因为哈希函数可以快速定位到数据行。\n2. **键的分布相对均匀**：当键值分布均匀时，哈希索引能提供较好的性能，因为它可以减少潜在的哈希冲突。\n3. **表中数据变化不频繁**：由于哈希索引不如B树索引高效地支持范围查询和顺序访问，因此更适合数据相对静态的表。\n\n\n\n##### 不适合使用哈希索引的表特性：\n\n\n\n1. **需要支持范围查询**：哈希索引不适合于需要执行范围查询的情况，因为哈希函数的结果无法保证值之间的顺序关系。\n2. **键的分布不均匀**：如果表中的键值存在大量重复，或者分布不均匀，可能会导致大量哈希冲突，进而影响索引的性能。\n3. **大量的写操作**：哈希索引可能不太适合频繁进行插入、更新和删除操作的表，因为这些操作可能会导致哈希桶过载，需要重新哈希或频繁处理哈希冲突。\n4. **需要支持前缀搜索或模式匹配**：哈希索引不适合处理前缀搜索或模式匹配的查询，因为哈希函数的结果与数据值的局部模式无关。\n\n\n\n> 总的来说，哈希索引在处理简单的等值查找时效率很高，但在其他方面较为局限。在选择是否使用哈希索引时，应当考虑表的数据特性和查询需求，以确保索引策略与数据使用模式相匹配。\n\n#### 11.减少磁头移动路程 -- 把关系紧密的数据临近存储 -- 聚簇(Clustering)\n\n>把关系非常紧密，但位于不同表中的行记录，在磁盘上临近存储。当它们做联接运算时，就能迅速得到结果；\n\n![image-20240412230022153](../../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/a8DqAvzjMKwkurG.png)\n\n#### 12.提高表数据访问性能 -- 连续空间存储\n\n>对于表记录，如果**连续地存储**在一个磁道上，当读数据时，数据就可**一个紧挨一个地读到**，访问速度就会大大加快；\n>\n>你的计算机使用一段时间后，感觉明显变慢，也是这个道理；\n>\n>你可以做**磁盘碎片整理**，让每个文件的数据在磁盘上连续存储，这样就克服了**磁头在盘面空间中到处来回移动**，速度大大加快；\n\n![image-20240412230137895](https://cdn.jsdelivr.net/Ycx6666 / TyporaImage/Lhbrt5HdCkEfeza.png)\n\n#### 13.访问频繁的数据存储再中央位置\n\n>对于**访问频繁**的数据表存储在**中央位置**，那么就可减少磁头移动的总路程；\n\n![image-20240412230237500](../../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/VcMYiJgn14Z6fux.png)\n\n##### 实现方法\n\n```sql\nCREATE TABLESPACE  basicdata DATAFILE ‘c:\\oracle\\data\\basicdata.dbf’  SIZE 1000M;\n\nCREATE TABLE employee (\neno CHAR(5) NOT NULL,\nename VARCHAR(30),\n\nPRIMARY KEY (eno),\nFOREIGN KEY (dno)  REFERENCES Dept(dno),\n\nTABLESPACE  basicdata,\n                  STORAGE (INITIAL 100M NEXT 100M)//初始100M，追加100M\n)\n\n```\n\n#### 14.提高数据处理性能 -- 缓存\n\n>数据存在磁盘上可靠。访问磁盘也是这个道理，很费时间。**缓存**能使得**批量读磁盘**，**批量写磁盘**成为可能，**可减少磁盘运输次数，也可减少磁头移动的总路程**。其原理：**规模效益**。；\n\n\n\n#### 15.提高数据处理性能 -- 并发执行\n\n> 并发处理在获得效率提升的同时，也引入了访问冲突的问题，导致数据的不一致和不正确\n\n![image-20240412230851792](../../../../Typora/Project/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%EF%BC%885-8%EF%BC%89.assets/8M2pqTyfjvOxJC5.png)\n\n##### 并发控制\n\n- **当前等待执行的事务集：{Ta}，正在执行的事务集:{T*x*}。任一T*c*属于{T*a*}，如果它和{T*x*}不冲突，那么就可调度执行T*c*。**\n\n- **当服务器受理一个客户的事务请求T*c*时，如果它和{T*x*}不冲突，那么就执行它，并将其加进{T*x*}中。否则将它加进{T*a*}中。**\n\n- **当一个事务执行完毕后，就将它从{T*x*}中剔除，然后对{T*a*}中的事务逐一检查，调度那些与更新后的{T*x*}无冲突的事务去执行，并将其从{T*a*}中移入到{T*x*}中。**\n\n#### 16.提高数据处理行呢个 -- 查询 优化\n\n![image-20240412231121422](https://cdn.jsdelivr.net/Ycx6666 / TyporaImage/uVZT3dlaSp5fNwA.png)\n\n#### 17.提高数据处理性能 -- 配置单独专用的日志磁盘\n\n>当配置单独的日志磁盘时，正常运行时，日志具有只写不读的特点，而且是递增，**磁头可一个挨一个地写，不用来回移动，性能得到极大提高**。\n\n#### 18.索引 -- 最重要的技能\n\n- **索引原理：压缩和排序。**\n\n- **增大压缩比的方法：分组；**\n\n- **分组，与排序相比，约束条件没有那么强！**\n\n- **例如，enroll表，以学号分组存储时，即一个学生的选课记录临近存储。与集合概念相比，分组提出了要求；**\n\n- **于是，对于enroll表，以学号字段创建索引时，一个学生只有一条索引记录，压缩比增大了n倍，n是一个学生的选课记录行数。**\n\n- **NOSQL中的key-Value模型中，value可以是一个集合/表。**\n\n","tags":["总结","数据库"],"categories":["数据库"]},{"title":"操作系统作业1","url":"/2024/03/操作系统作业1/","content":"# 4\t\n\n## 4-1\n\n![image-20240316210403950](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240316210403950.png)\n\n可以看到，在每一个时刻，都保持cpu处于忙碌状态，因此cpu利用率位100%;\n\n使用-c指令查看发现符合预期。\n\n## 4-2\n\n![image-20240316210906963](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240316210906963.png)\n\n进程二为一个I/O操作，因此程序完成的时间与等待I/O完成的时间有关；\n\n若设这个时间位x，那么所需要的总时间就为进程0的执行时间加上I/O发起请求的时间加上I/O等待的时间再加上I/O执行完成的时间；\n\n即\n$$\n4+x+2=6+x\n$$\n如输入-c之后的表，表中I/O等待了4个时刻，因此耗费了11个时刻的时间，与预期相符。\n\n## 4-3\n\n![image-20240316211841117](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240316211841117.png)\n\n我们可以看到，当交换了程序运行时间后，实际上进行I/O操作时仍旧处于阻塞状态，但是不同的是，此时程序二由于cpu空闲而可以运行，这样子就大大提高了cpu利用率，有效缩短了时间，因此交换顺序是很重要的，这样可以大大提高cpu利用率和运行效率。\n\n使用-c指令可以发现答案正确。\n\n# 5\n\n## 5-1\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n\nint main(int argc,char *argv[])\n{\n\n        int x=100;\n        int rc=fork();\n\n        if(rc<0){\n                fprintf(stderr,\"fork failed\");\n                exit(1);\n        }else if(rc==0){\n                printf(\"child(pid:%d) (x:%d)\\n\",(int)getpid(),x);\n        \n        }else {\n                printf(\"parent of %d (pid:%d) (x:%d)\\n\",\n                                rc,(int)getpid(),x);\n          \t\t\tx=50;\n        }\n        return 0;\n\n}\n```\n\n在主进程访问x并将100设置为50时，子进程中的值仍为100，这说明子进程与父进程中的x值互不影响。\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n\nint main(int argc,char *argv[])\n{\n\n        int x=100;\n        int rc=fork();\n\n        if(rc<0){\n                fprintf(stderr,\"fork failed\");\n                exit(1);\n        }else if(rc==0){\n        \tx=50;\n                printf(\"child(pid:%d) (x:%d)\\n\",(int)getpid(),x);\n        \n        }else { \n        \tx=150;\n                printf(\"parent of %d (pid:%d) (x:%d)\\n\",\n                                rc,(int)getpid(),x);\n               \n        }\n        return 0;\n\n}\n```\n\n将父进程中的x设置为50再输出而子进程中的x设置为150输出，可以观察到：\n\n![image-20240316214932000](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240316214932000.png)\n\n因此这更加证明了父进程和子进程中的变量x并不互相影响。\n\n## 5-2\n\n```c\n#include<stdio.h>\n#include<unistd.h>\n#include<string.h>\n#include<fcntl.h>\n#include<stdlib.h>\n\nint main(int argc,char *argv[])\n{\n        int rc=fork();\n        int fd=open(\"./op-5-2-open.txt\",O_RDWR);\n\n        if(rc<0){\n                fprintf(stderr,\"fork failed\");\n                exit(1);\n        }else if(rc==0){\n                printf(\"child(fd:%d)\\n\",fd);\n                char str[]=\"child process\";\n                write(fd,str,sizeof(str));\n        \n        }else { \n                printf(\"parent (fd:%d)\\n\",fd);\n               \n                char str2[]=\"parent process\";\n                write(fd,str2,sizeof(str2));\n\n        }\n        close(fd);\n        return 0;\n\n}\n\n\n```\n\n当他们并发的写入同一个文件中时，可以看到子进程和父进程都可以正常的访问open()返回的文件描述符；打开txt文件后可以发现后运行的子进程覆盖了先运行的父进程，如下面第二张图所示：\n\n\n\n![image-20240316221640885](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240316221640885.png)\n\n![image-20240316221829401](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240316221829401.png)\n\n\n\n## 5-4\n\n```C\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n\nint main(){\n\tint rc=fork();\n\tif(rc<0){\n\t\tfprintf(stderr,\"fork failed!\\n\");\n\t}else if(rc==0){\n\t\tprintf(\"execl\\n\");\n\t\texecl(\"/bin/ls\",\"ls\",NULL);\n\t}else {\n\t\tint wc=wait(NULL);\n\t}\n\treturn 0;\n}\n```\n\n运行后输出结果如图所示：\n\n![image-20240317171813950](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240317171813950.png)\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n\nint main(){\n\tint rc=fork();\n\tif(rc<0){\n\t\tfprintf(stderr,\"fork failed!\\n\");\n\t}else if(rc==0){\n\t\tprintf(\"execl\\n\");\n\t\tconst char*arg;\n\t\tchar *const argv[]={\"ls\",\"-l\",NULL};\n\t\tcahr *const envp[]={\"\",\"\",NULL};\n\t\t\n\t\texecl(\"/bin/ls\",arg,NULL);\n    //\n    printf(\"execlp\\n\");\n\t\texeclp(\"ls\",arg,NULL);\n    //\n    printf(\"execle\\n\");\n\t\texecle(\"/bin/ls\",arg,NULL,envp);\n    //\n    printf(\"execv\\n\");\n\t\texecv(\"/bin/ls\",argv);\n    //\n    printf(\"ececvp\\n\");\n\t\texecvp(\"ls\",argv);\n    //\n    printf(\"ececvp\\n\");\n\t\texecvp(\"ls\",argv,envp);\n\t}else {\n\t\tint wc=wait(NULL);\n\t}\n\treturn 0;\n}\n```\n\n\n\n分别运行后可以看到如图所示的结果：\n\n![image-20240317173008027](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240317173008027.png)\n\n![image-20240317173034407](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240317173034407.png)\n\n![image-20240317173059810](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240317173059810.png)\n\n![image-20240317173127891](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240317173127891.png)\n\n![image-20240317173153763](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240317173153763.png)\n\n__为什么会有这么多的变种__，是因为多种exec()调用的参数传递方式和传递参数不同，这样子就可以更加灵活多样的使用exec()的功能，从而完成更加细致多样的操作来满足不同的需求。\n\n#\t7\n\n## 7-1\n\n由于三个任务时间相同且在同一时刻到达，因此他们两种方式的响应时间和周转时间分别相同。\n\n**其调度方式为:**\n\n| SJF/FIFO调度顺序 | A    | B    | B    |\n| ---------------- | ---- | ---- | ---- |\n| 运行长度         | 200  | 200  | 200  |\n\n其中每个单元格表示：**响应时间/周转时间**\n\n| 调度方式 | A     | B       | C       |\n| -------- | ----- | ------- | ------- |\n| FIFO     | 0/200 | 200/400 | 400/600 |\n| SJF      | 0/200 | 200/400 | 400/600 |\n\n**这两种调度方式的平均响应时间为:**\n$$\n（0+200+400）/3=200\n$$\n**这两种调度方式的平均周转时间为：**\n$$\n(200+400+600)/3=400\n$$\n\n\n## 7-2\n\n**其调度方式为:**\n\n| SJF/FIFO调度顺序 | A    | B    | B    |\n| ---------------- | ---- | ---- | ---- |\n| 运行长度         | 100  | 200  | 300  |\n\n其中每个单元格表示：**响应时间/周转时间**\n\n| 调度方式 | A     | B       | C       |\n| -------- | ----- | ------- | ------- |\n| FIFO     | 0/100 | 100/300 | 300/600 |\n| SJF      | 0/100 | 100/300 | 300/600 |\n\n**这两种调度方式的平均响应时间为:**\n$$\n（0+100+300）/3=133.33\n$$\n**这两种调度方式的平均周转时间为：**\n$$\n(100+300+600)/3=333.33\n$$\n\n\n## 7-3\n\n其中每个单元格表示：**响应时间/周转时间**\n\n| 调度方式 | A     | B     | C     |\n| -------- | ----- | ----- | ----- |\n| RR       | 0/598 | 1/599 | 2/600 |\n\n**这两种调度方式的平均响应时间为:**\n$$\n（0+1+2）/3=1\n$$\n**这两种调度方式的平均周转时间为：**\n$$\n(598+599+600)/3=599\n$$\n","tags":["操作系统"],"categories":["作业"]},{"title":"协变返回类型","url":"/2024/03/协变返回类型/","content":"# 协变返回类型\n\n## 定义\n\n==定义==\t<p>导出类中被覆盖的方法可以返回积累芳芳的返回类型的某种到处类型</p>\n\n\n```java\n//polymorphism/CovariantReturn.java\npackage polymorphism;\nclass Grain {\n  public String toString() { return \"Grain\"; }\n}\nclass Wheat extends Grain {\n  public String toString() { return \"Wheat\"; }\n}\nclass Mill {\n  Grain process() { return new Grain(); }\n}\nclass WheatMill extends Mill {\n  Wheat process() { return new Wheat(); }\n}\npublic class CovariantReturn {\n  public static void main(String[] args) {\n    Mill m = new Mill();\n    Grain g = m.process();\n    System.out.println(g);\n    m = new WheatMill();\n    g = m.process();\n    System.out.println(g);\n  }\n} /* Output:\nGrain\nWheat\n*///:~\n\n```\n\n## 状态模式\n\n\n```java\nclass Stage {\n\n  private Actor actor = new HappyActor();\n\n  public void change() { actor = new SadActor(); }\n\n  public void performPlay() { actor.act(); }\n```\n\n## 纯继承模式\n\n\n<blockquote>只有在基类中出现的方法才可以在导出类中定义，是一种纯粹的“is a\"关系\n\n<blockquote>扩展接口可定义为”is-like-a\"关系\n\n```java\n//: polymorphism/RTTI.java\n// Downcasting & Runtime type information (RTTI).\n// {ThrowsException}\npackage polymorphism;\nclass Useful {\n  public void f() {System.out.println(\"Userful:f()\");}\n  public void g() {System.out.println(\"Userful:g()\");}\n}\n\nclass MoreUseful extends Useful {\n  public void f() {System.out.println(\"MoreUseful:f()\");}\n  public void g() {System.out.println(\"MoreUseful:g()\");}\n  public void u() {System.out.println(\"MoreUseful:u()\");}\n  public void v() {System.out.println(\"MoreUseful:v()\");}\n  public void w() {System.out.println(\"MoreUseful:w()\");}\n}\t\n\npublic class RTTI {\n  public static void main(String[] args) {\n    Useful[] x = {\n      new Useful(),\n      new MoreUseful()\n    };\n    x[0].f();\n    x[1].g();\n    // Compile time: method not found in Useful:\n    //x[1].u();\n    ((MoreUseful)x[1]).u(); // Downcast/RTTI\n  //  ((MoreUseful)x[0]).u(); // Exception thrown\n   \n    if (x[0] instanceof MoreUseful)\n    {\n    \tSystem.out.println(\"ttt\");\n    \tMoreUseful mf = (MoreUseful) x[0];\n    \tmf.u();\n    }\n    \n    \n  }\n} ///:~\n\n```\n\n==对象不能向上转型，类型才能向上转型。==\n\n==内存分析== \n\n\"[Java多态的向上转型——内存分析_向上转型内存结构-CSDN博客](https://blog.csdn.net/qq_43582566/article/details/121909107)\"\n\n\n\n# java的异常处理机制\n\n## throws\n\n![image-20231220165420962](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231220165420962.png)\n\n<b>例</b>  \n\n```java\nstatic void calculate() throws IllegalAccessException{\n\t\tint c[]={1,2};\n\t\tc[5]=60;\n\t\tint a=0;\n\t\tSystem.out.println(\"a=\"+a);\n\t    int b=50/a;\n\t    throw new IllegalAccessException();\n\t}\n\tpublic static void main(String args[]){\n\t\ttry\n\t\t{\n\t\t\tcalculate();\n\t\t}   \n\t\tcatch (IllegalAccessException e)\n\t\t{\n\t\t\tSystem.out.println(\"非法存取\"+e);\n\t\t}\n```\n\n\n\n# 泛型编程\n\n功能类似于cpp中的模板,作用是提高代码的复用率\n\n例\n\n```java\nstatic void calculate() throws IllegalAccessException{\n\t\tint c[]={1,2};\n\t\tc[5]=60;\n\t\tint a=0;\n\t\tSystem.out.println(\"a=\"+a);\n\t    int b=50/a;\n\t    throw new IllegalAccessException();\n\t}\n\tpublic static void main(String args[]){\n\t\ttry\n\t\t{\n\t\t\tcalculate();\n\t\t}   \n\t\tcatch (IllegalAccessException e)\n\t\t{\n\t\t\tSystem.out.println(\"非法存取\"+e);\n\t\t}\n```\n\n## 泛型类\n\n> 泛型是带一个或则和多个类型参数的类\n\neg \n\n```java\npackage generics;\n\npublic class Box<T> {\n\tprivate T  t;\n\tpublic void add(T  t) {\n\t\tthis.t = t;\n\t}\n\tpublic T  get() {\n\t    return  t;\n\t}\n\tpublic static void main(String[] args){\n\t\tBox<String> box = new Box();\n\t    Box<Integer> box1 = new Box<Integer>();\n\t\tbox.add(\"hello\");     //box.add(100);\n\t\tSystem.out.println(box.get());\n\t   }\n\t}\n\n\n```\n\n> 泛型类的使用与方法调用类似。 ¡ 方法调用需向方法传递参数，使用泛型需传递一个类型参 数，即用某个具体的类型替换T。 要在Box对象中存放String对象，就要在创建Box对象时为其 传递String类型参数。 ¡ 要实例化泛型类对象，也使用new运算符，但在类名和括 号之间需加上要传递的具体类型，\n>\n> > 例如： //在JDK 1.7之前，创建泛型对象时的写法 BoxGenerics box = new BoxGenerics(); \n>\n> > //在JDK 1.7之后，创建泛型对象时的写法 BoxGenerics box = new BoxGenerics(); \n>\n> 按照约定，类型参数名使用单个大写字母表示。常用的类 型参数名（标记符）有：E表示元素，K表示键，N表示数字，T 表示类型，V表示值，？等\n\n> 当没有指定模板类型时，会默认当成object对像\n\n```java{\npublic class REG1 {\n\tpublic static void main(String[] args)\n\t{\n\t    CE c3=new CE();\n\t    c3.x=5;\n\t    c3.y=10;\n\t    System.out.println(c3.toString());\n\t}\n}\n\n```\n\n![image-20231222144704812](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231222144704812.png)\n\n当定义数组时，不能直接定义,需要用以下方法:\n\n```java\nint i=0;\n\t//CE<Integer,Double>[] carry1=new CE<Integer,Double>[5];\n\t\tCE<Integer,Double>[] carry2=new CE[5];\n\t\tfor(i=0;i<5;i++)\n\t\t{\n\t\t    carry2[i]=new CE<Integer,Double>();\n\t\t}\n```\n\n\n\n## 泛型方法\n\n#### 类型擦除\n\n在泛型代码内部，无法获得任何有关泛型参数的信息。 ¡ 当泛型类型实例化时，编译器使用一种叫类型擦除的技术 转换这些类型。在编译时，编译器将清除类和方法中的所 有与类型参数有关的信息。 ¡ Java考虑到兼容问题，使用擦除实现泛型，意味着泛型使 用时，任何具体的类型信息都被擦除了，唯一知道的就是 你在使用一个对象。\n\n```java\n public class ErasedTypeEquivalence { public static void main(String[] args) { Class c1 = new ArrayList().getClass(); Class c2 = new ArrayList().getClass(); System.out.println(c1 == c2); //True or False？ } } //generics.ErasedTypeEquivalence.java 35 //: generics/LostInformation.java\n```\n\n#### 边界\n\n> <u>边界通配符</u> <code>? super Apple</code> 表示传入apple整个类及其以上的父类。\n>\n> <u>边界通配符</u> <code>? extend Apple</code> 表示传入apple整个类及其以下的子类。\n\n* 1.上界不能往里存，只能往外取 编译器只知道容器里的是Fruit或者Fruit的子类，但不 知道它具体是什么类型，所以存的时候，无法判断是否要存 入的数据的类型与容器种的类型一致，所以会拒绝set操作。 \n\n* 2.下界往外取只能赋值给Object变量，不影 响往里存 因为编译器只知道它是Fruit或者它的父类，这样实际上 是放松了类型限制，Fruit的父类一直到Object类型的对象 都可以往里存，但是取的时候，就只能当成Object对象使用 了。\n\n*  所以如果需要经常往外读，则使用，如果需 要经常往外取，则使用。\n\n  [＜? extend T＞和＜? super T＞的解释_-CSDN博客](https://blog.csdn.net/qq_58746475/article/details/119887000?ops_request_misc=%7B%22request%5Fid%22%3A%22170323034416800222821634%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=170323034416800222821634&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-119887000-null-\tnull.142^v96^pc_search_result_base9&utm_term= extend &spm=1018.2226.3001.4187)\"\n\n  > <u>无界通配符</u>  使用无界通配符指定一个未知类型 “？” 。 ？ 与==? extend Apple==具有相同的含义，表示任何类 型。\n\n## 泛型接口\n\n<ul>泛型也可以用于接口\n\n* 实现泛型接口时，如果不生命类型，那么泛型自动变为object\n* 如果想保留接口中的泛型，则在实现剋的声明时，必须保留泛型接口中的泛型声明\n* 也可以在是实现时，直接给定接口泛型中的具体类型\n\n#### 使用泛型需要注意的问题\n\n* 任何基本类型都不能作为类型参数\n* 实现参数化接口，由于擦除，一个类不能实现同一 泛型接口的两种变体\n* 转型与警告：使用带泛型类型参数的转型， instanceof无任何效果，因为擦除\n*  方法重载：类型参数不能识别\n","tags":["Java","协变"],"categories":["Java"]},{"title":"Node.js入门","url":"/2024/03/Node.js使用教程/","content":"# Node.js使用教程\n<p align=\"center\">\n  <br>\n  <h2 style=\"text-align:center;color:#F4E0EA\">\n    樱春雪\n\t</h2>\n  <br>\n  <br>\n\t<div style=\"text-align:center\">\n    <a href=\"https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master\">湖南大学</a>\n  | <a href=\"https://theme.typora.io/theme/Drake/\">软件工程</a>\n  | <a href=\"https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md\">2204</a>\n</div>\n<br>\n<br>\n<img style=\"clear:both;display:block;margin:auto;width:400px;height:100px\" src=\"计算机系统作业1.assets\\7HN)MKDR%[2BI2$@Q69A8$H.png\">\n  <br>\n</p>\n\n\n\n\n\n\n## 1.读取文件内容\n\n### fs文件系统模块\n\nfs模块时node.js 官方提供的用来操作文件的模块\n\n> fs.readFile.()方法，用来读取指定文件中的内容\n>\n> fs.writeFile()方法，用来向指定的文件中写入文件\n\n入股要在js代码中，使用fs模块操作文件，需要用到require函数调用模块\n\n```js\nconst fs=require('fs')\n```\n\n###fs.readFile()的语法格式\n\n如果在参数列表中的参数被中括号包括起来，表示其是一个可选参数\n\n```js\nconst fs=require('fs')\nfs.readFile(path[,options],callback\n```\n\n> 参数一：必选参数，字符串，表示文件的路径\n>\n> 参数二：可选参数，表示以什么编码方式来读取文件\n>\n> 参数三：必选参数，文件读取完成后，通过回调函数拿到读取的结果\n\n```js\nconst fs=require('fs')\nfs.readFile('路径','utf8',function(err,dataStr){\n  console.log('err')\n})\n```\n\n### 判断文件是否读取成功\n\n可以判断err对象是否为null，从而知晓\n\n## 2.向指定的文件中写入内容\n\n###fs.writeFile()的语法格式\n\n使用这个方法，可以写入文件\n\n```js\nfd.writrFile(file,data[,options],callback)\n```\n\n> 参数一：必选参数，需要指定一个文件路径的字符串，表示文件的存储路劲\n>\n> 参数二：必选参数，表示要写入的内容\n>\n> 参数三：可选参数，表示以什么文件格式写入，默认utf8\n>\n> 参数四：必选参数，文件写入完成后的回调函数\n\n__需要注意的是，如果路径已经存在，那么或覆盖原有的内容__\n\n###判断文件是否写入成功\n\n如果写入成功，那么err的值等于null\n\n如果写入失败，err的值是一个错误对象\n\n## 3.处理路径问题\n\n### fs模块-路径动态拼接的问题\n\n在使用fs模块时，如果使用的时./或者../开头的相对路径时，很容易出现动态拼接错误的问题。\n\n__原因__：在代码运行的时候，==会以执行node命令时所处的目录==，动态拼接出被操作文件的完整路径。\n\n__解决方法__:直接使用绝对路径。\n\n__注意__：在js中，一个反斜杠“\\\"表示转移符，需要写两个反斜杠才表示一个反斜杠\"\\\\\"。\n\n**缺点**：移植性非常差，并且不利于维护\n\n**解决方法**:==__dirname==表示当前文件所处的目录，==不会被node命令所处目录变化而变化==。\n\n例如\n\n### 03.1使用path路径模块\n\npath是用来专门处理路径的模块，他提供了一系列的方法和属性，用来满足用户对路径的处理需求。\n\n exp\n\n> path.join()方法：用来将多个路径片段拼接成一个完整的路径字符串。\n>\n> path.basename()方法：用来从路径字符串中，将文件名字解析出来。\n\n需要以下导入：\n\n```js\nconst path=require('path')\n```\n\n### 03.2路径拼接\n\npath.join()的代码示例：\n\n==注意:==在==../==之前的一个字符串将被抵消。\n\n```js\nconst path = require('path')\n\n//../抵消\nconst pathStr=path.join('/a', '/b/c', '../', '/d', '/e')\nconsole.log(pathStr)//输出\\a\\b\\d\\e\n```\n\n**以后进行拼接时尽量使用path.join(),可以避免错误输入路径带来的某些错误（.)**\n\n### 03-3获取路径中的文件名\n\n**1.path.basename():**可以获取路径中的最后一部分，可以使用这个方法获取路径中的文件名，格式如下\n\n```js\npath.basename(path[,ext])\n```\n\n**代码示例**，使用这个方法，可以从一个文件路径中，获取到文件的名称部分：\n\n```js\nconst path = require('path')\n\nconst fpath = '/a/b/c/index.html'\n\nconst fullname = path.basename(fpath)\nconst fullname2 = path.basename(fpath, '.html')//消除扩展名\n\nconsole.log(fullname)//拿到文件名\nconsole.log(fullname2)\n```\n\n### 03-4如何获取路径中的文件扩展名\n\n**语法格式**：path.extname()的代码\n\n```js\nconst path = require('path')\n\nconst fpath = '/a/b/c/index.html'\n\nconst fext = path.extname(fpath)\n\nconsole.log(fext)//.html\n```\n\n### 03-5时钟案例\n\n步骤：\n\n​\t1.创建两个正则表达式，用来匹配<style>和<scipt>标签\n\n​\t2.使用fs模块，读取需要被处理的HTML文件\n\n​\t3.自定义resolveCSS方法，写入index.css文件\n\n​\t4.自定义resolveJs方法，写入index.js文件\n\n​\t5.自定义resolveHtml方法，写入index.html文件\n\nresolveCSS()方法:\n\n```js\nfunction resolveCSS(htmlStr) {\n  const r1 = regStyle.exec(htmlStr)\n  const newCSS = r1[0].replace('<style>', '').replace('</style>', '')\n  //写入index.css文件\n  fs.writeFile(path.join(__dirname,'../素材1/index.css'), newCSS, (err) => {\n    if (err)\n      return console.log('写入CSS样式失败！' + err.message)\n      console.log('写入样式文件成功!')\n  })\n}\n```\n\nresolveJs()方法：\n\n```js\nfunction resolveJs(htmlStr) {\n  const r2 = regJs.exec(htmlStr)\n  const newJs = r2[0].replace('<script>', '').replace('</script>', '')\n  //写入index.css文件\n  fs.writeFile(path.join(__dirname,'../素材1/index.js'), newJs, (err) => {\n    if (err)\n      return console.log('写入JS文件失败！' + err.message)\n      console.log('写入JS文件成功!')\n  })\n}\n```\n\nrsolveHTML()方法\n\n```js\nfunction resolveHTML(htmlStr) {\n  //调用replace方法\n  const newHTML=htmlStr.replace(\n    regStyle,`<link rel=\"stylesheet\" href=\"./index.css\">`\n  ).replace(\n    regJs,'<script src=\"./index.js\"></script>'\n  )\n  //写入\n  fs.writeFile(path.join(__dirname, './素材1/index.html'), 'utf8', (err) => {\n    if (err) {\n      return console.log('写入HTML文件失败！'+err.message)\n    }\n    console.log('写入HTML文件成功！')\n  })\n}\n```\n\n==注意点==\n\n> 1.一定要新建一个文件夹\n>\n> 2.使用fs.write()方法写入内容时，重复写入会导致新内容覆盖旧内容\n\n## 4.HTTP模块\n\n###4.1什么是HTTP模块\n\n==概念==\n\n在网络节点，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。\n\n==方法==\n\nhttp模块中的http.createServer()方法，能把一台普通的电脑，变成一台Web服务器\n\n==引入==\n\n``` js\nconst http=require('http')\n```\n\n### 4.2进一步理解http模块的作用\n\n==服务器和普通电脑的区别==\n\n服务器和普通电脑的区别，服务器上安装了Web服务器软件，例如：IIS，Apache等，通过这些服务器软件，能把一台普通的电脑变成一台Web服务器。\n\n**在nodejs中，我们不需要这些软件，我们可以通过HTTP模块创建一个服务器**\n\n### 4.3服务器相关概念\n\n==IP地址==\n\n- 互联网上每台计算机的唯一标识。\n\n- 格式：“点分十进制”，a.b.c.d，其中abcd都是0-255之间的十进制整数。\n\n- **在cmd中输入ping 网站 可以获取网站IP地址**\n\n- 在自己电脑中输入127.0.0.1就可以访问本机了。\n\n==域名和域名服务器==\n\n- IP地址不够直观，因此发明了域名来方便人们记忆\n\n- IP地址和域名是一一对应的关系，这种关系存放在一种叫做**域名服务器(DNS)**的电脑中。\n\n**注意**\n\n127.0.0.1对应的域名是localhost\n\n==端口号==\n\n 一台电脑中，可以运行很多个Web服务，每个Web都对应一个唯一的端口号，通过端口号，可以将网络请求准确的发给对应的Web服务。\n\n**注意**\n\n- 每个端口号不能被同时多个Web服务占用\n\n- 在是基于应用中，只有80端口可以在URL中省略。\n\n### 4.4创建最基本的Web服务器\n\n#### 1.创建最基本的Web服务器的步骤\n\n1. 导入http模块\n2. 创建Web服务器示例\n3. 为服务器绑定request时间，监听客户端请求\n4. 启动服务器\n\n#### 2.示例代码\n\n```js\n//1\nconst http = require('http')\n\n//创建示例\nconst server = http.createServer()\n\n//3.绑定request\nserver.on('reques', (req, res) => {\n  console.log('某人访问了服务器....')\n})\n\n//4.启动\nserver.listen(80, () => {\n  console.log('server running...')\n})\n```\n\n### 4.5.REQ\n\n3.req请求对象，只要服务器收到了客户端的请求，就会调用通过server.on()位服务器绑定的事件处理函数\n\n包含了与客户端相关的数据和属性\n\n> req.url是客户端请求的URL地址\n>\n> req.method是客户端请求的method类型\n\n### 4.6时钟Web服务器案例\n\n#### 1.核心思路\n\n> 将每个文件的实际存放路径，作为每个资源的请求URL地址\n\n#### 2.实现步骤\n\n1. 导入需要的模块\n2. 创建基本Web服务器\n3. 将资源url地址作为文件存放路径\n4. 读取文件内容并响应客户端\n5. 优化资源请求路径\n\n#### 3.导入需要的模块\n\n```js\nconst fs=require('fs')\nconst path=require('path')\nconst http=require('http')\n```\n\n#### 4.将资源url作为文件存放路径\n\n获取到的请求路径:==/index.html==\n\n#### 5.读取文件内容并发送给客户端\n\n```js\n  fs.readFile(fpath, 'utf8', (err, dataStr) => {\n    //4.2读取失败\n    if (err)\n      return res.end('404 Not Found')\n    //4.3读取成功\n    res.end(dataStr)\n  })\n```\n\n> 如果获取的文件内容中引用了其他文件，那么浏览器会自动请求\n\n#### 6.优化请求资源的路径\n\n如果请求根路径，那么就用/clock/index.html来代替\n\n## 5.模块化\n\n### 5.1是么是模块化\n\n#### 1.编程领域中的模块化\n\n此处的模块化，就是固定遵守的规则，把一个大文件拆分成独立并且互相依赖的多个小模块。\n\n**好处**\n\n> 提高了代码复用性\n>\n> 提高了代码可维护性\n>\n> 可以实现按需加载\n\n### 5.2模块化规范\n\n模块规范化就是在对代码进行模块化的拆分与组合时，需要遵守的那些规则\n\n好处：降低了沟通的成本，极大方便了各个模块的相互调用\n\n## 6.Nodejs中的模块化\n\n### 6.1模块的分类\n\n>**内置模块**：内置模块是由Nodejs官方提供的，例如fs，path,http等等\n>\n>**自定义模块**：用户创建的每个.js文件，都是自定义模块\n>\n>**第三方模块**:由第三方开发出的模块，不是官方也不是用户提供的\n\n### 6.2加载模块\n\n使用强大的==require==方法，可以加载需要的各种模块\n\n```js\n//加载内置模块\nconst fs=require('fs')\n//加载用户自定义模块，如果去掉.js后缀名也能运行\nconst custom=require('./custom.js')\n//加载第三方模块\nconst moment=require('moment')\n```\n\n==使用其他模块时，调用时就会加载模块的代码==\n\n### 6.3模块作用域\n\n#### 1.什么是作用域\n\n和函数作用域类似，自定义模块中的方法、变量等等，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域\n\n#### 2.好处\n\n防止全局变量污染的问题\n\n![image-20240321205245056](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240321205245056.png)\n\n![image-20240321205419593](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240321205419593.png)\n\n### 6.4向外共享模块作用域中的成员\n\n#### 1.module对象\n\n每个.js自定义文件中都有一个module对象，他存储了当前模块的数据等等\n\n![image-20240321205637062](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240321205637062.png)\n\n#### 2.module.exports对象\n\n在自定义模块中，可以使用这个对象可以将模块内的成员共享出去；\n\n外界使用require()方法导入自定义模块时，得到的就是module.exports所指向的对象\n\n==在一个自定义模块中，默认的module.exports对象就是空对象，也就是module对象==\n\n```js\nmodule.exports.sayHello=function() {\n  console.log(`我是${usename}`)\n}   \n\nmodule.exports.usename = 'zs'//像module.exports中挂载一个属性\n```\n\n![image-20240321222048156](Node.js使用教程.assets/image-20240321222048156.png)\n\n#### 3.共享成员的注意点\n\n使用require()方法导入模块时，导入的结果，永远以module.exports指向的对象为准\n\n#### 4.exports对象\n\nmodule.exports和exports指向的是同一个对象\n\n最终指向的值，==以module.exports==指向的对象为准\n\n#### 5.module.exports和exports使用误区\n\n>1. 使用require时，得到的永远都是module.exports对象\n\n为了防止混乱，建议大家不要在同一个模块中同时使用两者\n\n### 6.5Nodejs中的模块化规范\n\nnodejs遵循了**CommonJS模块化规范**，其规定了模块的特性和各模块之间如何互相依赖\n\n**CommonJS规定：**\n\n> 1.每个模块内部，module变量代表当前某块\n>\n> 2.module变量是一个对象，他的exports属性(即module.exports)是对外的接口\n>\n> 3.加载某个模块，其实是加载该模块的module.exports属性，require()方法用于加载模块\n\n## 7.npm与包\n\n### 7.1初步入门\n\n#### 什么是包\n\nNodejs中的第三方模块又叫做包\n\n#### 包的来源\n\nNodejs的内置模块和自定义模块，都是由第三方团队制作的\n\n#### 为什么需要\n\n==原因==Nodejs的内置某块仅提供了一些底层的api，导致开发时效率低\n\n包是基于内置模块封装出来的\n\n#### 怎么下载\n\nnpm公司 <www.npmjs.com>是全球最大的包共享平台\n\nnpm公司还提供了一个地址为 https://registy.npmjs.org/的服务器，来对外共享所有的包，但是其打不开。\n\n#### 如何下载\n\n这个包管理工具叫做==Node Package Manager==(简称npm包管理工具)\n\n### 7.2npm初体验\n\n#### 1.格式化实践的传统做法\n\ndateFormat()方法\n\n```js\nfunction dateFormat(dtStr) {\n  const dt = new Date(dtStr)\n  const y = dt.getFullYear()\n  const m = padZero(dt.getMonth()+1)\n  const d = padZero(dt.getDate())\n\n  const hh = padZero(dt.getHours())\n  const mm = padZero(dt.getMinutes())\n  const ss = padZero(dt.getSeconds())\n\n  return `${y}-${m}-${d} ${hh}:${mm}:${ss}` \n}\nfunction padZero(n) {\n  return (n > 9 ? n : '0'+n);\n}\n\nmodule.exports = {\n  dateFormat\n}\n```\n\n\n\n#### 2.格式化时间高级做法\n\n> 1.使用npm包管理工具，安装时间包moment\n>\n> 2.使用require\n>\n> 3.参考官方文档调用API\n\n#### 3.在项目中安装包\n\n初次安装包后，会在项目文件夹下多一个叫做node_modules的文件夹和package-lock.json的文件\n\n第一个用于存放所有一安装到项目中的包\n\n第二个记录了第一个目录下每一个包的下载信息\n\n```npm\nnpm install 包的完整名称\n可以简写为\n \t\t\t\tnpm i 完整的名称\n```\n\n#### 4.使用moment\n\n```js\n//导入\nconst moment = require('moment')\n\nconst dt = moment().format('YYYY-MM-DD HH-mm-ss')\nconsole.log(dt)\n```\n\n#### 5.安装指定版本的包\n\n在包的名称之后，==通过@符号跟上具体的版本号==，从而安装指定版本的包\n\n后安装的相同的包会覆盖原有的包\n\n#### 6.包的语义化版本规范\n\n包的版本号是按照点分十进制形式进行定义的，总共由三位数字\n\n>1.第一位数字：大版本\n>\n>2.第二位数字：功能版本\n>\n>3.第三位数字：Bug修复版本\n\n### 7.3包管理配置文件\n\nnpm**规定**，在项目根目录中，必须提供一个叫做package.json的包配置管理文件，用来记录与项目有关的一些配置信息\n\n- **项目的名称、版本号、描述等等**\n- **项目中用到了那些包**\n- **那些包只会在开发期间用到**\n- **那些包在开发和部署起家都会用到**\n\n#### 1.多人协作的问题\n\n1. 第三方包体积过大，不方柏霓团队成员之间共享项目源代码\n\n#### 2.如何记录项目中安装了哪些包\n\n在项目根目录中，创建一个叫做==package.json==的配置文件，用于记录项目中安装了哪些包，\n\n以后在项目开发中，一定要把**node_modules文件夹**，添加到.gitignore忽略文件中\n\n#### 3.快速创建package.json\n\n可以在执行目录中，快速创建package.json包管理配置文件\n\n```js\nnpm init -y\n```\n\n**注意**\n\n>上述命令只能在英文目录下运行\n>\n>运行npm install时，npm包管理工具会自动把包的名称和版本号，记录到package.json文件中\n\n**PS:**现在已经可以自动创建package.json文件了！\n\n#### 4.depenencies节点\n\n这个节点，用于记录npm install 安装了哪些包，会记录包的名称和版本号\n\n![image-20240324214311357](Node.js使用教程.assets/image-20240324214311357.png)\n\n#### 5.一次性安装所有包\n\n拿到一个node_module被删除了的项目之后，需要先把所有的包下载下来，不然运行不起来\n\n使用\n\n```js\nnpm install //npm i\n```\n\n可以一次性安装所有的包\n\n#### 6.卸载包\n\n可以运行==npm uninstall + 指定包==命令\n\n注意，删除包之后，在node_mudules中业户删除包信息\n\n#### 7.devDependencies节点\n\n如果某些包旨在项目开发阶段使用，可以把这些包记录到**devDependencies**节点中；\n\n如果某些包在开发与上线中都要用到，那建议记录到**Dependencies**\n\n\n\n可以使用如下命令：\n\n```js\n//安装指定包到devDependencies\nnpm i 包名 -D\n//上述命令是简写形式\nnpm install 包名 --save-dev\n```\n\n### 7.4解决下包速度慢的问题\n\n#### 1.为什么慢\n\n使用npm下包时，默认从国外网站进行下载\n\n官方源 <https://registry.npmjs.org/>\n\n#### 2.淘宝镜像\n\n==已安装==\n\n#### 3.切换npm下包镜像源\n\n```npm\nnpm config get registry //查看下包源\nnpm config set registry=https://registry.npm.taobao.rog/ //切换为淘宝镜像源\n```\n\n#### 4.nrm\n\n为了更方便切换，可以使用nrm这个工具，快速查看和切换\n\n```npm\n#安装全局\nnpm i nrm -g\n#查看可用镜像源\nnrm ls\n#将下包镜像源切换为taobao\nnrm use taobao\n```\n\n### 7.5包的分类\n\n#### 1.项目包\n\n那些被安装到项目中的node_modules的包，都是项目包\n\n>开发依赖包 在devD\n>\n>核心依赖包 在D\n\n#### 2.全局包\n\n在执行==npm install==时候，如果提供了-g参数，则会把她安装为全局包\n\n==注意-==\n\n只有工具性的包，才有全局安装的必要***\n\n判断某个包是否全局才能使用，查看官方文档即可***\n\n#### 3.i5ting_toc\n\n> i5ting_doc是一个可以把md文档转为htnl页面的小工具，使用步骤如下\n\n```npm\n#将其安装为全局包\nnpm install -g i5ting_toc\n#调用i5ting_toc，轻松和实现md 转 html页面功能\ni5ting_toc -f 要转换的md文件路径 -o\n```\n\n#### 4.规范的包结构\n\n1. 每一个包都需要单独的目录\n2. 包的顶级目录下必须要package.json这个配置文件\n3. package.json必须包含name,version,main三个属性，对应了包的名字、版本号和包的入口\n\n### 7.6开发属于自己的包\n\n#### 1.skip\n\n#### 2.初始化包的基本结构\n\n1. 新建itheima-tools文件夹，作为包的根目录\n2. 在itheima-tools文件夹中华，新建如下三个文件\n   - package.json\n   - index.js\n   - README.md\n\n#### 3.初始化package.json\n\n```json\n{\n  \"name\": \"ycx_tools\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"description\": \"提供了格式化时间、HTMLESCAPE的功能\",\n  \"keywords\": [\n    \"ycx_tools\",\n    \"format\",\n    \"ycx\",\n    \"escape\"\n  ],\n  \"license\":\"ISC\"\n}\n```\n\n#### 4.在index.js中定义方法\n\n```js\nfunction dateFormat(dtStr) {\n  const dt = new Date(dtStr)\n  const y = dt.getFullYear()\n  const m = padZero(dt.getMonth()+1)\n  const d = padZero(dt.getDate())\n\n  const hh = padZero(dt.getHours())\n  const mm = padZero(dt.getMinutes())\n  const ss = padZero(dt.getSeconds())\n\n  return `${y}-${m}-${d} ${hh}:${mm}:${ss}` \n}\nfunction padZero(n) {\n  return (n > 9 ? n : '0'+n);\n}\n\nmodule.exports = {\n  dateFormat\n}\n```\n\n**即使require没有指定文件，根据package.json中的main属性来查找**\n\n#### 5.在index.js中定义转移HTML的方法\n\n```js\n//定义转移html\nfunction htmlescape(htmlStr) {\n  return htmlStr.replaca(/<|>|\"|&/g, (match) => {\n    switch (match) {\n      case `<`:\n        return '&lt;'\n      case `>`:\n        return '&gt;'\n      case `\"`:\n        return '&quot;'\n      case `&`:\n        return '&amp;'\n    }\n  })\n}\n```\n\n#### 6.index.js定义还原HTML的方法\n\n```js\n//定义还原HTML\nfunction htmlUnEscape(str) {\n  return str.replace(/&lt;|&gt;|&quot;|&amp;/g, (match) => {\n    switch (match) {\n      case `&lt;`:\n        return '<'\n      case `&gt;`:\n        return '>'\n      case `&quot;`:\n        return '\"'\n      case `&amp;`:\n        return '&'\n    }\n  })\n}\n```\n\n#### 7.将不同的功能纪念性模块化拆分\n\n>1. 将格式化时间的功能，拆分到src->dateFormat.js中\n>2. 将处理HTML字符换的功能，拆分到src->htmlescape.js中\n>3. 在index.js中，导入两个模块，得到需要向外共享的方法\n>\n>4.在index.js中，使用module.exports把对应的方法共享出去\n\n\n\n**es6--扩展运算符** 将数组或者对象的内容转换为一段以逗号隔开的序列\n\n```js\nmodule.exports = {\n  ...date,//展开运算符\n  ...escape\n}\n```\n\n#### 8.编写包的说明文档\n\nREADME.md文档用于说明包\n\n**可以包含以下说明**\n\n>安装方式、导入方式、格式化时间\n>\n>转移HTML中的特殊字符、还原HTML中的特殊字符、开源协议\n\n### 7.7发布包\n\n#### 1.注册账号\n\n==已注册==\n\n#### 2.登录\n\n在命令行中输入 `npm login` 进行登录\n\n**注意，使用之前需要先将服务器切换到官方服务器**\n\n`npm config set registry=https://registry.npmjs.org/`\n\n#### 3.把包发布到npm上\n\n> 将终端切换到包的根目录，运行 npm publish命令，即可发布\n\n![image-20240325110008091](Node.js使用教程.assets/image-20240325110008091.png)\n\n发布成功!!!\n\n#### 4.删除已发布的包\n\n**注意**\n\n```npm\nnpm unpublish 包名 --force，即可删除\n```\n\n\n\n>npm unpublish命令只能删除72小时以内的包\n>\n>npm unpublish删除的包，在24小时内不能重新发布\n>\n>尽量不要发布没有意义的包\n\n## 8.模块的缓存机制\n\n### 8.1优先从缓存中加载\n\n模块第一次加载会被缓存，这也意味着多次调用require()不会导致模块代码被执行多次\n\n**注意**  各种模块都会从缓存中加载，从而提高模块的加载效率\n\n### 8.2内置模块加载机制\n\n> 内置模块是Node.js提供的模块，优先级最高。\n\n### 8.3自定义模块加载机制\n\n使用require()加载自定义模块是，必须指定以./ 或者 ../开头的路径标识符，否则node会把他当作第三方模块或者内置模块加载\n\n如果省略了文件扩展名，那么node或按照一下顺序分别尝试加载文件\n\n1. 按照确切的文件名进行加载\n2. 补全.js进行加载\n3. 补全.json进行\n4. 补全.node\n5. 加载失败\n\n### 8.4第三方模块加载机制\n\n如果传递给require的不符合上述两种规则，则node.js会从当前模块父目录开始，尝试从/node_modules加载第三方模块\n\n如果没有找到，则移动到再上一层父目录中，直到磁盘根目录中。\n\n### 8.5目录作为模块\n\n把目录作为标识符，传递给require()时，有三种加载方式\n\n>1. 被加载目录下查找一个叫做package.json的文件，并寻找main属性，作为require()入口\n>2. 如果没有.json文件按，或者main不存在或者无法解析，则Node.js或试图加载目录下的index.js文件\n>3. 如果都失败了，会打印模块缺失 Error:Cannot find module 'xxx'\n\n# \n\n\n\n","tags":["入门","nodejs"],"categories":["node.js"]},{"title":"操作系统第四组第二次小班课","url":"/2024/03/大纲 - 副本/","content":"# 操作系统第四组第二次小班课\n\n> 代码实现利用多进程实现 C/S 模式聊天程序，启动一个服务器，单个和多个客户端，服务端接收到新的客户端请求就创建一个进程与客户端通信。\n\n## CS 架构和 BS 架构\n\n常见的软件架构有两种：CS、BS。不管是哪种，真正的核心处理逻辑都是在服务器上：\n\n1. CS：Client/Server（客户端 / 服务器），采取这种架构的软件，在用户本地需要下载并安装客户端程序，在远程有一个服务器端程序。比如：QQ、steam。\n\n   优点：事先下载好所有资源，用户体验好。缺点：需要开发客户端和服务端，开发、部署、维护麻烦，服务端更新时，客户端也需要更新。CS架构适合定制专业化的办公类软件。\n\n2. BS：Brower/Server（浏览器 / 服务器），采取这种架构时，只需要一个浏览器，用户通过不同的网址就可以访问不同的服务器。比如：京东、淘宝（网页端）。\n\n   优点：方便，不需要开发客户端，只需要页面+服务端，且只需要打开浏览器就可以使用。缺点：需要通过网络传输所有的图片、音频资源，如果资源过大，则会降低用户体验。BS架构适合移动互联网应用。\n\n## 网络编程三要素\n\n当我们要向另外一台计算机发送信息时，我们要知晓对方电脑在互联网上的地址（**IP**），还需要确定对方电脑接受数据的软件（**端口号**，一个端口号只能被一个软件绑定使用），还需要确定网络传输的规则（**协议**）。故**IP、端口号、协议**就是网络编程三要素。\n\n**网络编程三要素**：\n\n1. IP：设备在网络中的地址，是唯一的标识。\n2. 端口号：应用程序在设备中唯一的标识。\n3. 协议：数据在网络中传输的规则，常见的协议有 UDP、TCP、http、https、ftp。\n\n### IP\n\n全称：Internet Protocol，是互联网协议地址，也称IP地址。是分配给上网设备的数字标签。常见的IP分为：ipv4、ipv6。\n\nIPv4：全称为Internet Protocol version 4，即互联网通信协议第四版。采用**32位地址长度**，**分成4组（每组1字节，8位）**。一般用**点分十进制表示法**，例如：`192.168.1.66`。每一组最大值是255，最小值是0。在IPv4中，每一组有256种表示方法，一共4组，最多可以表示 $256^4 = 4294967296$ 种地址，数量有限，不够使用。实际上，在2019年11月26日，IPv4的全部可用地址就已经分配完毕了。\n\nIPv6：全称为Internet Protocol version 6，即互联网通信协议第六版。由于互联网的蓬勃发展，IP地址的需求量越来越大，而IPv4模式下的IP总数有限，为了让地址能够继续分配，故出现了IPv6。采用**128位地址长度，分成8组（每组2字节，16位）**。一共有 $2^{128} = 3.04\\times10^{38}$ 种地址，这个数量，可以给地球上的每一粒沙子都编上号。一般用**冒分十六进制表示法**，例如：`2001:0DB8:0000:0023:0008:0800:200C:417A`。对于每一组，可以省略前导0，此时，对于上述IP地址，可以记录为：`2001:DB8:0:23:8:800:200C:417A`。此外，还有一种特殊情况：**0位压缩表示法**。即如果计算出的16进制表示形式中有多个连续的0，可以利用`::`进行压缩表示，例如对于`FF01:0:0:0:0:0:0:1101`，我们可以压缩为：`FF01::1101`。\n\n上述是对于IPv4和IPv6的基本介绍，现对IPv4进行额外补充。\n\nIPv4的地址分类形式有两种：一种是公网地址（万维网使用），一种是私有地址（局域网使用）。`192.168.`开头的就是私有地址，范围即为`192.168.0.0--192.168.255.255`，专门为组织机构内部使用，通过共享公网IP以此节省IP。\n\n一个特殊的IP地址为：`127.0.0.1`，又称localhost。是回送地址，也叫本地回环地址，又称本机IP。永远只会寻找当前所在的本机。换个地方上网，局域网IP可能不一样，因为这个是通过路由器分配的。通过localhost，可以保证自己给自己发送数据时不出错。\n\n### 端口号\n\n应用程序在设备中唯一的标识。**一个端口号只能被一个应用程序使用。**\n\n端口号是由两个字节表示的整数，取值范围：0-65535。其中0-1023之间的端口号是用于一些知名的网络服务或者应用。我们自己使用1024以上的端口号就可以了。\n\n### 协议\n\n计算机网络中，连接和通信的规则被称作网络通信协议。\n\nOSI参考模型：世界互联协议标准，全球通信规范，单模型过于理想化，未能在因特网上进行广泛推广。\n\nTCP / IP 参考模型：事实上的国际标准。\n\n#### UDP协议\n\n用户数据报协议（User Datagram Protocol），是**面向无连接**（不管两台计算机是否建立连接，直接传输数据）通信协议。速度快，有大小限制，一次最多发送64K，数据不安全，易丢失数据。应用场景：网络会议、语音通话、在线视频。（丢失数据的影响不大）\n\n#### TCP协议\n\n传输控制协议（Transmission Control Protocol），是**面向连接**的通信协议。速度慢，没有大小限制，数据安全。应用场景：下载软件、文字聊天、发送邮件。（丢失数据影响较大）","tags":["操作系统"],"categories":["小班"]},{"title":"数据库系统第四章课后作业","url":"/2024/03/数据库作业2软件2204戴腾宇202226010418/","content":"## 第四章课后作业\n\n### 1.\n\n**某酒店集团公司在全国各城市开有酒店。每个酒店都有客房，客户可在网上先登录，然后预订，也可入店时现场预订。其住宿业务数据库中有如下4个表：**\n\n**Hotel(hotelNo, name, city, address, phone)**\n**Room(roomNo, hotelNo, type, price)**\n**Booking (hotelNo, roomNo, guestNo, dateFrom, dateTo)**\n**Guest(guestNo, password, name, city, email, phone, discount, creditNo)**\n**其中房间类型type字段的取值有单人间、双人间、商务间、豪华间。price是指住宿一天的房价。**\n**1)写出创建Room表和Booking表的SQL语句。**\n**2)创建一个视图，列出在2019-09-30这天，入住在编号为H0001的酒店的客人情况表，输出字段包括客人名字、房间号、房间类型、价格。**\n**3)创建一个存储过程，以起始日期、结束日期、酒店号为输入参数，求出所指的住宿期间，这个酒店可供预定的房间列表，包括房间号、类型、价格。按价格升序排列。**\n**4)有业务规则：不允许发生一个客户在两个不同的酒店有起始日期相同的预订。请创建一个触发器，表示该业务规则。**\n\n1)\n\n```mysql\nCREATE TABLE Room (\n\troomNo VARCHAR(10),//假设房间号为10个字符\n\thotelNo VARCHAR(10),//假设宾馆好为10个字符\n\ttype ENUM(‘单人间’，‘双人间’，‘三人间’)，//假设有这三种房间\n\tprice INT,\n\tPRIMARY KEY (roomNo,hotelNo),\n  FOREIGN KEY (hotelNo) REFERENCES Hotel(hotelNo)\n);\n\nCREATE TABLE Booking (\n  hotelNo VARCHAR(10),\n  roomNo VARCHAR(10),\n  guestNo int,\n  dateFrom DATE,\n  dateto DATE,\n  PRIMARY KEY (hotelNo,roomNo,guestNo,dateFrom,dateTo),\n  FOREIGN KEY (hotelNo) REFERENCES Hotel(hotelNo),\n  FOREIGN KEY (roomNo) REFERENCES Room(roomNo),\n  FOREIGN KEY (guestNo) REFERENCES Guest(guestNo)\n);\n```\n\n\n\n2)\n\n```sql\nCREATE VIEW view_h0001 AS\nSELECT g.name,b.roomNo,r.type,r.prcie \nFROM Booking b\nJOIN Guest g IN b.guestNo=g.guestNo\nJOIN Room r IN b.roomNo=r.roomNo AND b.hotelNo=r.hotelNo\nWHERE b.hotelNo='H0001'\nAND '2019-09-30' BETWEEN b.dateFrom AND b.dateTo;\n```\n\n\n\n3)\n\n```mysql\nCREATE PROCEDURE getGuestInfo(@gDateFrom in DATE,@gDateTo in DATE,@gHotelNo in VARCHAR)\nBEGIN \n\tSELECT r.roomNo,r.type,r.price\n\tFROM Room r\n\tWHERE @gHotelNo=r.hotelNo AND r.roomNo NOT IN(\n  \tSELECT b.roomNo\n    FROM Booking b\n    WHERE b.hotelNo=@gHotelNo AND NOT(\n    \tb.dateTo>@gDateFrom AND \n      b.dateStart<@gDateTo\n    )\n  )\n  ORDER BY r.price ASC\nEND;\n```\n\n\n\n4)\n\n```sql\nDELIMITER \nCREATE TRIGGER unableInsertBooking\nBEFORE INSERT ON Booking\nFOR EACH ROW\nBEGIN\n\tDECLARE sum INT;\n\tSELECT COUNT(*)\n\tINTO sum\n\tFROM Booking\n\tWHERE new.guestNo=b.guestNo\n\t\tAND new.dateFrom=b.dateFrom\n\t\tAND new.hotelNo<>b.hotelNo\n\tIF sum>0 THEN\n\t\tSIGNAL SQLSTATE '45000'\n\t\tSET MESSAGE_TEXT='Wrong operation!'\n\tEND IF\n END\n DELIMITER;\n```\n\n\n\n## 2.\n\n**数据库中的对象，例如表，其模式是存储在DBMS内部的表中。假设表对象的模式存储在DBMS内部的tableSchema表中，请写出tableSchema表的模式。并用SQL写出tableSchema表的模式的定义语句。注意：要存储表对象的模式，在DBMS内部光有tableSchema表还不够，还要有辅助表才行。基于严格按类分表存储原则，以及类与类之间有联系，还要求写出辅助表的定义。**\n\n**tableSchema表的模式定义**\n\nTableSchema 表可能包括表名、字段名、数据类型、是否可为空、主键、外键等信息。\n\n```sql\nCREATE TABLE tableSchema (\n  tableName VARCHAR(100),\n  columnName VARCHAR(100),\n  dataType VARCHAR(100),\n  isNullable BOOLEAN,\n  isPrimaryKey BOOLEAN,\n  isForeignKey BOOLEAN,\n  referenceTable VARCHAR(100),\n  referenceColumn VARCHAR(100),\n  /* 其它可能的字段 */\n  PRIMARY KEY (tableName, columnName)\n  /* 外键约束等 */\n);\n```\n\n**辅助表**\n\n辅助表可用来存储索引或者关系信息的表。\n\n```sql\nCREATE TABLE auxiliaryTable (\n  tableName VARCHAR(100),\n  constraintName VARCHAR(100),\n  constraintType VARCHAR(50),\n  /* 其它可能的辅助信息 */\n  PRIMARY KEY (tableName, constraintName)\n  /* 外键约束等 */\n);\n```\n\n","tags":["数据库系统"],"categories":["作业"]},{"title":"数据库系统第一、二章课后作业","url":"/2024/03/数据库作业一/","content":"##习题一\n\n1. 标识每个表的主键和外键：\n\n   - 学院表（Department）：主键是 `deptNo`。\n   - 学生表（Student）：主键是 `studentNo`。`deptNo` 是外键，引用了学院表（Department）的`deptNo`。\n   - 课程表（Course）：主键是 `courseNo`。`deptNo` 是外键，引用学院表（Department）的`deptNo`。\n   - 教师表（Teacher）：主键是 `teacherNo`。`deptNo` 是外键，引用学院表（Department）的`deptNo`。\n   - 教师开课表（Teach）：主键可能是 `courseNo`、`semester` 和 `classNo` 的组合。`courseNo` 是外键，引用课程表（Course）的`courseNo`；`teacherNo` 是外键，引用教师表（Teacher）的`teacherNo`。\n   - 学生选课表（Enroll）：主键是 `studentNo`、`courseNo`、`semester` 的组合。`studentNo` 是外键，引用学生表（Student）的`studentNo`；`courseNo` 是外键，引用教师开课表（Teach）的`courseNo`；`teacherNo`是外键，引用教师表`(Teacher)`中的主键。\n   - 教室表（Classroom）：主键是 `classroomNo`。\n   - 排课表（Dispatch）：主键是 `courseNo`、`semester`、`classNo`、`period`、`weekday` 的组合。`classroomNo` 是外键，引用教室表（Classroom）的`classroomNo`。\n\n2. 域约束：\n\n   - 课程表（Course）中的 `credit` 字段：域约束为数值类型，取值范围取决于学校的学分制度。\n   - 教师表（Teacher）中的 `rank` 字段：域约束为字符串类型,取值范围是预定义的职称集合，例如 {'助教', '讲师', '副教授', '教授'} 等。\n\n3. 使用关系代数生成以下用户所需业务数据：\n\n   (a)\n\n   ​\t\n   $$\n   \\Pi_{studentNo, name, birthday}(\\sigma_{sex = '女' \\land YEAR(birthday) = 2000}(Student))\n   $$\n   ​\t\n\n   (b)\n   $$\n   \\Pi_{Course.courseNo, Course.name, Enroll.semester, Course.credit, Enroll.score}(Enroll ⨝_{Enroll.courseNo=Course.courseNo \\land Enroll.studentNo='200843407'} Course)\n   $$\n   \n\n   (c)\n   $$\n   \\Pi_{Student.studentNo,Student.name,Student.sex}(\\sigma_{semester='2011-1' \\ landcourseNo='G61030009'}(Enroll) \\Join _{Enroll.student=Student.studentNo}Student)\n   $$\n   \n\n   ## 习题二\n\n   （1）\n\n   - Hotel表\n     - 主键: hotelNo\n     - 没有外键\n   - Room表\n     - 主键: (roomNo, hotelNo) 的联合主键\n     - 外键: hotelNo (关联到Hotel表的hotelNo)\n   - Booking表\n     - 主键: (hotelNo, roomNo, guestNo, dateFrom, dateTo) 的联合主键\n     - 外键: hotelNo (关联到Hotel表的hotelNo)，roomNo (关联到Room表的roomNo)，guestNo (关联到Guest表的guestNo)\n   - Guest表\n     - 主键: guestNo\n     - 没有外键\n\n   (2)\n\n   - 每个房间在任何时间段内只能被一位客户预订，不允许在相同日期范围内有重叠的预订。\n   - 客户在进行网络预订时必须使用有效的身份验证登陆信息，即客户的guestNo和password字段需要有效对应才能完成预订流程。\n\n   \n\n   (3)\n\n   ​\t(a)\n   $$\n   \\Pi_{Room.type, Hotel.name, Hotel.city}(\\sigma_{Room.price > 1500}(Room ⨝ Hotel))\n   $$\n   ​\t(b)\n   $$\n   \\Pi_{Hotel.name, Room.roomNo, Room.price}(\n       (σ_{Hotel.city = '长沙' AND Room.type = '单人间'}(Hotel ⨝ Room))\n       -\\\\\n       (σ_{Booking.dateFrom \\leq '2019-09-11' AND Booking.dateTo \\geq '2019-09-11'}(Booking))\n   )\n   $$\n   \n\n## \t习题三 \n\n1. ```SQL\n   SELECT h.name,r.type,COUTT(r.roomNo) AS room_num \n   From Hotel As h\n   JOIN Room r ON h.hotelNo=r.hotelNo\n   WHERE h.city='长沙'\n   GROUP BY h.name,r.type\n   ORDER BY h.name;\n   ```\n\n2. ```sql\n   SELECT g.name,b.roomNo\n   From Booking b\n   JOIN Hotel h ON b.hotelNo=h.hotelNo\n   JOIN GUEST g ON b.guestNo=g.guestNo\n   WHERE h.city='长沙' AND b.dateFrom<='2019-09-29' AND b.dateTo>='2019-09-29'\n   ORDER By g.name;\n   ```\n\n3. ```sql\n   SELECT h.name,r.roomNo,r.price\n   FROM Hotel h\n   JOIN Room r ON h.hotelNo=r.hotelNo\n   WHERE h.city='长沙' AND r.type='双人间' AND r.price<140\n   ORDER BY h.name,r.price;\n   ```\n\n4. ```sql\n   SELECT COUNT(DISTINCT b.name)\n   FROM Booking b\n   WHERE b.dateFrom>='2019-08-00' AND b.dateTo<='2019-08-31';\n   ```\n   \n5. ```sql\n   SELECT *\n   FROM Booking b\n   WHERE b.dateTo=NULL;\n   ```\n\n6. ```sql\n   SELECT COUNT(h.hotelNo)\n   FROM Hotel h;\n   ```\n\n7. ```sql\n   SELECT h.city AVG(r.price) AS avg_price\n   FROM Hotel h\n   JOIN Room r ON h.hotelNo=r.hotelNo\n   GROUP BY h.city;\n   ```\n\n8. ```sql\n   SELECT h.city,r.type,AVG(r.price) AS avg_price\n   FROM Hotel h\n   JOIN Room r ON h.hotelNo=r.hotelNo\n   GROUP BY h.city,r.type;\n   ```\n\n9. ```sql\n   SELECT h.city,h.name,b.roomNo,g.name,g.guestNo\n   FROM Booking b\n   JOIN Hotel h ON r.hotelNo=b.hotelNo\n   JOIN Guest g ON b.guestNo=b.guestNo\n   WHERE g.city='北京' AND b.dateFrom<='2019-09-29' AND b.dateTo>='2019-09-29';\n   ```\n\n10. ```sql\n   SELECT SUM(r.price) AS sum_income\n   FROM Room r\n   JOIN Hotel h ON h.hotelNo=r.hotelNo\n   WHERE h.city='长沙';\n   ```\n\n11. ```sql\n    SELECT SUM(r.price) AS sum_income\n    FROM Booking b\n    JOIN Hotel h ON b.hotelNo=h.hotelNO\n    JOIN Room r ON b.hotelNo=r.hotelNo\n    WHERE h.city='长沙' AND b.dateFrom<='2019-09-29' AND b.dateTo>='2019-09-29';\n    ```\n\n12. ``` sql\n    SELECT r.roomNo\n    FROM Room r\n    JOIN Hotel h ON h.hotelNo=r.hotelNo\n    WHERE h.city='长沙' AND r.roomNo NOT IN{\n    \t\tSELECT b.roomNo\n    \t\tFROM Booking b\n    \t\tWHERE b.dateFrom<='2019-09-29' AND b.dateTo>='2019-09-29'\n    };\n    ```\n\n13. ```sql\n    SELECT h.city,h.name,\n    \t\t\t(COUNT(DISTINCT b.roomNo)/COUNT(DISTINCT r.roomNO))*100\n    \t\t\tAS occupancyRate\n    FROM Hotel h\n    JOIN Room r ON r.hotelNo=h.hotelNo\n    JOIN Booking b ON r.hotel=b.hotelNo AND r.roomNo=b.roomNo\n    WHERE b.dateFrom<='2019-09-29' AND b.dateTo>='2019-09-29'\n    GROUP BY h.city,h.name;\n    ```\n\n14. ```sql\n    SELECT r.roomNo,r.price\n    FROM Room r\n    JOIN Hotel h ON h.hotelNo=r.hotelNo\n    WHERE r.type='双人间' AND h.city='长沙' AND r.roomNo NOT IN {\n    \t\t\tSELECT b.roomNo\n    \t\t\tFROM Booking b\n    \t\t\tWHERE b.dateFrom='2019-10-01' AND b.dateTo='2019-10-03'\n    };\n    ```\n\n15. ```sql\n    SELECT r.type\n    FROM Room r\n    JOIN Hotel h ON h.hotelNo=r.hotelNo\n    JOIN Booking b ON b.hotelNo=r.hotelNo AND b.roomNo=r.roomNo\n    WHERE h.city='长沙' AND '2019-09-29' BETWEEN b.dateFrom AND b.dateTo\n    GROUP BY r.type\n    ORDER BY COUNT(*) DESC\n    LIMIT 1;\n    ```\n\n16. ```sql\n    SELECT g.name,g.creditNo,g.city\n    FROM Guest g\n    JOIN Booking b ON b.guestNo=g.guestNo\n    WHERE b.dateFrom>='2019-08-01' AND b.dateTo<='2019-08-31'\n    GROUP g.name,g.creditNo,g.city\n    HAVING COUNT(b.guest)>5;\n    ```\n\n17. ```sql\n    INSERT INTO Hotel(hotelNo,name,city,address,phone) \n    \t\t\tVALUES ('001','天马大酒店'，'长沙'，'岳麓区'，'10086');\n    INSERT INTO Room(roomNo,hotelNo,type,price) \n    \t\t\tVALUES ('001','001'，'十人间'，'10086');\n    INSERT INTO Booking(hotelNo,roomNo,guestNo,dateFrom,dateTo) \n    \t\t\tVALUES ('001','001'，'001'，'2024-03-15'，'2024-03-16');\n    INSERT INTO Guest(guestNo,password,name,city,email,phone,discount,creditNo) \n    \t\t\tVALUES ('001','114514'，'张三'，'长沙'，'999@gmail.com','10086','0.01','3131313313131');\n    ```\n\n18. ```sql\n    UPDATE Room SET price=price*1.05;\n    ```\n\n19. ```sql\n    CREATE TABLE archival_booking like Booking;\n    INSERT INTO archival_booking \n    \t\t\tSELECT *\n    \t\t\tFROM Booking \n    \t\t\tWHERE b.dateFrom<='2019-01-01';\n    DELETE FROM Booking\n    \t\t\tWHERE dateFrom<='2019-01-01';\n    ```\n\n20. ```sql\n    UPDATE Guest SET Discount=Discount*0.9\n    WHERE guestNo{\n    \tSELECT guestNo\n    \tFrom Guest\n    \tWHERE dateFrom>='2019-01-01' AND dateTo<='2019-12-31'\n    \t\t\t\tGROUP BY guestNO\n    \t\t\t\tHAVING COUNT(*)>=12\n    };\n    ```\n\n21. ```sql\n    DELETE FROM Guest \n    \t\t\tWHERE g.guest NOT IN{\n    \t\t\tSELECT b.guestNo\n    \t\t\tFROM Booking b\n    \t\t\tWHERE b.dateFrom>='2017-01-01'\n    \t\t\t};\n    ```\n\n22. ```sql\n    SELECT g.name,g.creditNo,g.city\n    FROM guest g\n    \t\tWHERE NOT EXISTS(\n    \t\t\tSELECT h.hotelNO\n    \t\t\tFROM Hotel h\n    \t\t\tWHERE h.city='长沙'\n    \t\t\t\t\tAND NOT EXISTS(\n                    SELECT b.hotelNo\n                    FROM Booking b\n                    WHERE b.hotelNo=g.hotelNo \n                          AND b.guestNo=g.guestNo\n                          AND b.dateFrom BETWEEN '2019-01-01' AND '2019-12-31'\n    \t\t)\n    );\n    ```\n\n","tags":["数据库系统"],"categories":["作业"]},{"title":"数据库系统第三章课后作业","url":"/2024/03/数据库作业三/","content":"#  数据库作业三\n\n## 习题一\n\n大学教务管理数据库中，操作系统(courseNo为H61030008)是一门专业核心课，请为2019级软件工程专业（专业编号为‘24）的每个学生，向选课表enroll（studentNo, courseNo,semester,score)中添加一行选修该课的记录。将这个操作定义为一个事务。学号的样式为yyyyddssccnm.其中yyyy表示是哪一年级，dd表示所属学院的编号，ss表示专业编号。\n\n\n\n```sql\nTRANSACTION BEGIN\n\nINSERT INTO Enroll (studentNo,courseNo,semester,score) \nVALUES(\n\t(SELECT studentNo,FROM student WHERE studentNo LIKE '2019__24%'),\n  'H61030008',\n\t(SELECT semester FROM course WHERE courseNo='H6103008'),\n   60//这个数据貌似只有选课表中有，插入数值应该更具实际情况而定\n)\n  \nEND\nCOMMIT;\n```\n\n\n\n## 习题二\n\n在图6-7所示的事务执行框架中，从其开始执行，直至执行logCommit()之前，其前面的数更新日志已写入了日志磁盘，有可能吗?在这期间，那些已写人日志磁盘的日志记录，能从日志缓存区删除吗?请说明理由。logCommit()不只是给日志缓存区添加一条<t_id，COMMIT日志记录，还要等待，直至其所有日志记录被写入日志磁盘为止。为什么?对于logAbort()它只是给日志缓存区添加一条<tid，ABORT>日志记录，但并不需要等待。为什么?当一个事务被放弃，其所有日志记录还需要写入日志磁盘吗?请说明理由。\n\n1. 在提交之前，不一定会将所有的日志全部都写入磁盘，但这些日志一定会在适当的时候异步写入磁盘；在执行logCommit()时，必须将之前的所有日志全部写入磁盘，这样才能在发生崩溃之后完整的执行回滚。\n2. 可能，但这通常由数据库系统管理，可能涉及缓存替换策略和数据库的持久化策略。\n3. 这是为了崩溃后能够完整的执行回滚操作，因为只有等待所有的日志记录全都被写入后，才能保证回滚时能够执行每一步操作。\n4. 一个事务被中止时，他的变更不需要保存到数据库，因此也不需要等待前面的日志全部写入。\n5. 也需要，因为如果系统在回滚时发生崩溃，这些日志将用于再次恢复和回滚，以保证数据库的一致性。","tags":["数据库系统"],"categories":["作业"]},{"title":"数据库与身份验证","url":"/2024/03/数据库与身份验证/","content":"\n# 数据库与身份验证\n\n<p align=\"center\">\n  <br>\n  <h2 style=\"text-align:center;color:#F4E0EA\">\n    樱春雪\n\t</h2>\n  <br>\n  <br>\n\t<div style=\"text-align:center\">\n    <a href=\"https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master\">湖南大学</a>\n  | <a href=\"https://theme.typora.io/theme/Drake/\">软件工程</a>\n  | <a href=\"https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md\">2204</a>\n</div>\n<br>\n<br>\n<img style=\"clear:both;display:block;margin:auto;width:400px;height:100px\" src=\"计算机系统作业1.assets\\7HN)MKDR%[2BI2$@Q69A8$H.png\">\n  <br>\n</p>\n\n## 1.数据库的基本概念\n\n### 1.1什么是数据库\n\n> 数据库是用来组织、存储和管理数据的仓库\n\n### 1.2常见的数据库及其分类\n\n1. MySQL数据库(最广泛、流行度最高的开源免费数据库\n2. Oracle数据库\n3. SQL Server数据库\n4. Mongodb数据库\n\n## 2.安装并配置MySql相关的服务\n\n#### 2.1了解\n\n- MySql server :专门用来提供数据存储和服务的软件\n- MySQL Workbench :可视化的MySQL管理工具，通过它，可以方便的操作存储在MySQL Server中的数据\n\n#### 2.2&3.安装\n\n略\n\n## 3.MySQL的基本使用\n\n### 3.1使用mysql workbench管理数据库\n\n略\n\n#### 3.创建数据库\n\n#### 4.常见数据表\n\n> 1. PK主键，唯一标识\n> 2. NN，值不允许为空\n> 3. UQ，值唯一\n> 4. AI，值自动增长\n\n### 3.2使用SQL管理数据\n\n#### 1.什么是SQL\n\n> sql是一门结构化查询语言，专门用于访问和处理数据库的编程语言，能让我们以编程的形式，操作数据库里面的数据。\n\n**三个关键点：**\n\n- SQL是一门数据库编程语言\n- 使用SQL编写出来的代码，叫做SQL语句\n- SQL语言只能在==关系型数据库中使用==（例如Mysql，Oracle，SQL server)，非关系型数据库(如mongdb)不支持SQL语言。\n\n#### 2.SQL能够做什么\n\n从数据库中增删改查数据，创建新的数据库，创建表等等\n\n#### 3.SQL的学习目标\n\n如何对数据库进行增删改查\n\n---\n\nwhere、and和or、order by、count(*)函数\n\n### 3.3SQL语言\n\n## 4.在项目中操作MySql\n\n### 4.1在项目中操作数据库的步骤\n\n1. 安装专门的MySql数据库的第三方模块\n2. 通过mysql模块连接到MySql数据库\n3. 通过mysql模块执行SQL语句\n\n#### 1.安装mysql模块\n\n> mysql是一个托关于npm上的第三方某块\n\n语法:\n\n```js\nnpm i mysql//mysql2\n```\n\n#### 2.配置mysql模块\n\n在使用sql模块操作mysql数据库之前，必须先对MySQL进行必要的配置，主要配置步骤如下\n\n==这里推荐安装mysql2==,否则会因为加密不一样而出现错误\n\n```js\n//1.导入mysql模块\nconst mysql = require('mysql')\n\n//2.建立与mysql数据库的链接\nconst db = mysql.createPool({\n  host: 'localhost',//登录ip地址\n  user: 'root',//数据库账号\n  password: '615715',//数据库密码\n  database: 'test'//指定数据库\n})\n```\n\n#### 3.测试mysql模块能否正确工作\n\n通过db.query()函数，指定要执行的sql语句，通过回调函数拿到结果:\n\n**这里的SELECT 1没有任何实质性作用，仅用于测试**\n\n```js\n//判断mysql能否正确工作\ndb.query('SELECT 1', (err, res) => {\n  //如果出错了\n  if (err) return console.log(err.message)\n  console.log(res)\n})\n```\n\n### 4.2使用mysql操作mysql数据库\n\n#### 1.查询数据\n\n查询user中所有的数据\n\n如果执行的是SELECT，则执行的结果是以一个**数组**\n\n```JS\n//查询user中所有的数据\nconst sqlstr = `SELECT * FROM user`\ndb.query(sqlstr, (err, res) => {\n  if (err) return console.log(err.message)\n  console.log(res)\n})\n```\n\n![image-20240328215553883](数据库与身份验证.assets/image-20240328215553883.png)\n\n#### 2.插入数据\n\n向user中插入数据\n\nid为001，name为zz\n\n```js\n//向user中新增一条数据，user=‘001’ name='dn'\nconst user = { id: '001', username: 'dn' }\n\n//定义sql语句\nconst sqlStr = `insert into user (id,name) values(?,?)`\n\n//执行\ndb.query(sqlStr, [user.id, user.password], (err, res) => {\n  if (err) return console.log(err.message)\n  console.log()\n  //判断成功\n  //注意，如果执行的是insert，则res是一个对象，在这个对象中有affectRows这个属性来判断是否陈功\n  if (res.affectedRows === 1)\n    console.log('插入成功')\n})//填写两个占位符的值\n\n```\n\n**在这里面，有几个需要注意的：**\n\n>- 占位符?可以用于表示待插入的位置，在执行db.query时指定属性值进行填充\n>- 在返回的对象res中有一个属性affectRows，如果他的值为1，代表插入成功\n\n#### 3.插入数据的便捷操作\n\n当我们向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，可以通过如下方式：\n\n```js\nconst user = { id:10,name:'zz'}\nconst sqlStr = `insert into user set ?`\n//执行\ndb.query(sqlStr, user, (err, res) => {\n  if (err) return console.log(err.message)\n  console.log()\n  //判断成功\n  //注意，如果执行的是insert，则res是一个对象，在这个对象中有affectRows这个属性来判断是否陈功\n  if (res.affectedRows === 1)\n    console.log('插入成功')\n})//填写两个占位符的值\n```\n\n#### 4.更新数据\n\n通过如下方式\n\n```js\nconst user = { id:10,name:'zz'}\nconst sqlStr = `insert into user set ?`\n//执行\ndb.query(sqlStr, user, (err, res) => {\n  if (err) return console.log(err.message)\n  console.log()\n  //判断成功\n  //注意，如果执行的是insert，则res是一个对象，在这个对象中有affectRows这个属性来判断是否陈功\n  if (res.affectedRows === 1)\n    console.log('插入成功')\n})//填写两个占位符的值\n```\n\n#### 5.更新数据的便捷方式\n\n如果数据对象的每一个属性都和数据表的字段一一对应，则可以通过如下方式来快速更新表数据:\n\n```js\n//更新数据的便捷方式\nconst user = { id:10,user:'无敌逆神',password:'1234567'}\nconst sqlStr = `update user set ? where id=?`\n\n//执行\ndb.query(sqlStr, [user,user.id], (err, res) => {\n  if (err) return console.log(err.message)\n    if (res.affectedRows === 1)\n      console.log('更新成功')\n})\n```\n\n==注意，在提供数据的时候还要加一个额外的参数**user.id**==\n\n#### 6.删除数据\n\n**删除数据时，推荐使用id来，因为它具有唯一标识**\n\n```js\n//删除id为5的数据\nconst sqlStr = 'delete from user where id=?'\n\ndb.query(sqlStr, 5, (err, res) => {\n  if (err) return console.log(err.message)\n  //删除结果执行后，也会生成一个结果对象，其中也包含affectedRows这个属性\n    if (res.affectedRows === 1)\n      console.log('删除成功')\n})\n```\n\n#### 7.标记删除\n\n使用delete时，会真正的将数据从表中删除掉，推荐使用标记**删除**的方式，来**模拟删除**的动作\n\n>所谓的标记删除时，就是在表中设置类似于status这样的状态字段，来标记这条数据是否被删除\n>\n>当用户执行了删除的动作后，并不与执行delete语句将其删除掉，而是执行了**UPDATE**语句，将status更新为删除\n\n```js\nconst sqlStr = 'update user set status=? where id=?'\n\ndb.query(sqlStr, [1, 6], (err, res) => {\n    if (err) return console.log(err.message)\n  //删除结果执行后，也会生成一个结果对象，其中也包含affectedRows这个属性\n    if (res.affectedRows === 1)\n      console.log('删除成功')\n})\n```\n\n## 5.前后端身份认证\n\n### 5.1Web开发模式\n\n#### 1.服务器渲染的Web开发模式\n\n> 服务器渲染的概念：服务器发送给客户端的HTML页面，是在服务器通过字符串的拼接动态生成的，因此，客户端不需要Ajax这样的技术请求额外的数据\n\n#### 2.服务器渲染Web开发模式的优缺点\n\n==优点==\n\n> 前端耗时少，因此服务器负责动态生成HTML内容，浏览器只需要渲染页面即可\n>\n> 有利于SEO，因为服务器端响应的时完整的HTML内容，所以爬虫更容易获取信息，有利于SEO\n\n-----\n\n==缺点==\n\n>占用服务器端资源，即服务器端完成HTML内容页面的拼接，如果请求比较多，会对服务器造成一定的压力\n>\n>不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行合作分工，尤其对于前端复杂度给高的项目，不利于项目高效开发\n\n#### 3.前后端分离的Web开发模式\n\n> 前后端分离的概念：前后端分离的开发模式，依赖于Ajax技术的广泛使用，简而言之，前后端分离的Web开发模式就是后端只负责提供API接口，前端使用Ajax调用接口的开发模式\n\n#### 4.前后端分离的优缺点\n\n==优点==\n\n> 开发体验好：前端专注于UI页面开发，后端专注于api的开发，且前端有更多的选择性\n>\n> 用户体验好：Ajax的广泛应用，极大的提高了用户的体验，可以轻松实现页面的同步刷新\n>\n> 减轻了服务器端的渲染压力\n\n==缺点==\n\n> 不利于SEO，不利于爬虫的爬取\n\n#### 5.如何选择开发模式\n\n==不谈业务场景选使用都是耍流氓==\n\n![image-20240329211010552](数据库与身份验证.assets/image-20240329211010552.png)\n\n### 5.2什么是身份认证\n\n#### 1.什么是身份认证\n\n> 身份认证又称“身份验证”，“鉴权”，是指通过一定的手段，完成对用户的身份确认\n\n#### 2.为什么需要身份验证\n\n> 身份验证的目的，是为了确认**当前用户所声称某种身份的用户确实是某种用户\n\n#### 3.不同开发模式下的身份验证\n\n**服务器渲染推荐使用Session认证机制**\n\n**前后端分离推荐使用JWT认证机制**\n\n### 5.3Session认证机制\n\n#### 1.HTTP协议的无状态性\n\n> HTTP协议的无状态性，指的是客户端每次HTTP请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态\n\n![image-20240329212001957](数据库与身份验证.assets/image-20240329212001957.png)\n\n#### 2.如何突破HTTP无状态的限制\n\n![image-20240329212149180](数据库与身份验证.assets/image-20240329212149180.png)\n\n\n\n==现实生活中的会员卡身份认证方式，就叫做Cookie==\n\n#### 3.什么是Cookie\n\n> Cookie就是存储在浏览器中的一段键值对，他的大小不超过4kb，它由一个值(value)和一个键值(key)和其他几个用于控制Cookie有效期，安全性，适用范围的可选属性组成\n>\n> 不同域名下的Cookie各自独立，每当客户端发起请求时，会自动把当前域名下的所有未过期的Cookie一起发送给服务器\n\n==四大特性==\n\n1. 自动发送\n2. 域名独立\n3. 过期时限\n4. 4kb限制\n\n#### 4.Cookie在身份验证的作用\n\n> 客户端第一次请求服务器的时候，服务器会通过响应头的方式，向客户端发送一个身份验证的Cookie，客户端会自动将COOKIE保存在浏览器中\n>\n> 随后当客户端浏览器每次请求服务器的时候，浏览器都会自动将身份认证相关的Cookie，通过请求头的方式发送给服务器，服务器即可验明客户端的身份\n\n\n\n![image-20240329213207760](数据库与身份验证.assets/image-20240329213207760.png)\n\n#### 5.Cookie的安全性\n\n==COOKIE不具有安全性==\n\n> 由于Cookie是存储在浏览器中的，而且浏览器也提供了读写Cookie的API，也难辞Cookie也很容易被伪造，不具有安全性\n\n\n\n![image-20240329213612017](数据库与身份验证.assets/image-20240329213612017.png)\n\n\n\n**所以千万不要使用Cookie来存储用户隐私且敏感的数据**\n\n#### 6.提高身份认证的安全性\n\n![image-20240329213730371](数据库与身份验证.assets/image-20240329213730371.png)\n\n\n\n**这种会员卡+刷卡认证的设计理念，就是Session认证机制的精髓**\n\n在服务器会验证这个Cookie是否真正存在\n\n#### 7.Session的工作原理\n\n![image-20240329213923164](数据库与身份验证.assets/image-20240329213923164.png)\n\n### 5.4在Express中使用Session认证\n\n#### 1.安装express-session认证\n\n<npm i express-session>\n\n#### 2.配置\n\n安装成功后，需要通过app.use()来注册session中间件，\n\n```js\n//TODO：配置Session中间件\nconst session = require('express-session')\napp.use(\n  session({\n    secret: 'ycx',\n    resave: false,\n    saveUninitialized:true\n  })\n)\n```\n\n#### 3.如何向session中存入数据\n\n配置成功后，就可以通过req.session来访问和配置session对象，从而存储用户关键信息\n\n==只有配置成功后，才能通过req.出来session这个属性==\n\n```js\n  if (req.body.username != 'admin' || req.body.password != '000000') {\n    return res.send({ stats: 1, msg: '登陆失败' })\n  }\n  //TODO2:将登陆成功后的用户信息，保存在Session中\n  //只有配置成功后，才能通过req.出来session这个属性\n  req.session.user = req.body//用户信息\n  req.session.islogin = true//登陆状态\n  \n  res.send({ status: 0, ms: '登录成功' })\n```\n\n#### 4.从session中取数据\n\n可以直接从req.session中取数据\n\n```js\n //TODO3从session中获取用户名称，响应给客户端\n  if (!req.session.islogin) {\n    return res.send({status:1,msg:'fail'})\n  }\n  res.send({\n    status: 0,\n    msg: 'success',\n    username: 'req.session.user.username'\n  })\n```\n\n#### 5.清空session\n\n使用req.session.destroy()函数，==只会清空当前用户服务器保存的session==\n\n```js\n//退出登录的接口\napp.post('/api/logout', (req, res) => {\n  req.session.destroy()\n  res.send({\n    status: 0,\n    msg:'退出登录成功'\n  })\n})\n```\n\n### 5.5JWT认证机制\n\n#### 1.了解session的缺点\n\n> session认证机制需要配合Cookie才能实现，由于Cookie默认不支持跨域访问，所以当涉及到前端跨域请求后端接口时，需要很多额外的配置，\n>\n> 前后端需要跨域问题时，推荐session\n>\n> 不需要时，推荐jwt\n\n#### 2.什么是JWT\n\nJWT是目前最流行的跨域认证解决方案\n\n#### 3.JWT工作原理\n\n#### ![image-20240402201227994](数据库与身份验证.assets/image-20240402201227994.png)\n\n> 用户的信息通过Token字符串的方式，保存在客户端浏览器中，服务器通过还原Token字符串的形式来验证用户的身份。\n\n#### 4.JWT字符串组成\n\nJWT通常由三部分组成\n\n> Header、Payload(有效荷载)、Signature(签名)\n\n三者之间使用\".\"分隔\n\n#### 5.JWT三个部分的代表含义\n\n==Header====Signature==\n\n> 是安全性相关的部分，只是为了保证Token的安全性\n\n==Payload==\n\n> 是真正的用户信息，他是用户信息经过加密之后生成的字符串\n\n![image-20240402220156590](数据库与身份验证.assets/image-20240402220156590.png)\n\n#### 6.JWT的使用方式\n\n客户端收到服务器返回的JWT之后，将他存储在\n\n**localStorage或者sessionStorage**之中\n\n此后，客户端每次与服务器端通信，都要带上这个JWT字符串，从而进行身份验证。\n\n**推荐的做法：**\n\n> 将JWT放在HTTP请求头的Authorization字段中\n\n**其格式为：**\n\n```js\nAuthorization: Bearer <token>\n```\n\n### 5.6在Express中使用JWT\n\n#### 1.安装JWT相关包\n\n```js\nnpm install jsonwebtoken express-jwt\n```\n\n**其中**\n\n-  jsonwebtoken用于生成JWT字符串\n- express-jwt用于将JWT字符串解析还原成JSON对象\n\n#### 2.导入相关包\n\n使用require()函数\n\n```js\n// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt\nconst jsonwebtoken = require('jsonwebtoken')\nconst expressJwt = require('express-jwt')\n```\n\n#### 3.定义Secret密钥\n\n> 为了保证JWT字符串安全性，防止\n","tags":["nodejs","数据库","npm","身份验证"],"categories":["数据库"]},{"title":"计算机系统第四章课后作业","url":"/2024/03/计算机系统作业1/","content":"### 2.61 \n\n![image-20240324110351074](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A1.assets/image-20240324110351074.png)\n\n```C\n#include\"stdio.h\"\n#include\"stdlib.h\"\n\nint judge(int x){\n    return ((x+1)||x||(!(x>>24)+1)||(!(x&0xff)));\n}\nint main(){\n  int x;\n  scanf(\"%d\", &x);\n  printf(\"%d\", judge(x));\n  return 0;\n}\n```\n\n### 2.71\n\n![image-20240324112741611](计算机系统作业1.assets/image-20240324112741611.png)\n\n![image-20240324112902304](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A1.assets/image-20240324112902304.png)\n\n```c\n#include\"stdio.h\"\n#include\"stdlib.h\"\n\ntypedef unsigned packed_t; \n\nint xbyte(packed_t word, int bytenum) \n{ \n   return ((int)(word<<((3-bytenum)<<3)))>>24;\n}\nint main(){\n  int x,num;-\n  scanf(\"%d %d\", &x,&num);\n  printf(\"0x%hx\", xbyte(x,num));\n  return 0;\n}\n```\n\n### 2.87\n\n![image-20240324142831618](计算机系统作业1.assets/image-20240324142831618.png)\n\n![image-20240324142847715](计算机系统作业1.assets/image-20240324142847715.png)\n\n| 格式A       | 格式A   | 格式B       | 格式B   |\n| ----------- | ------- | ----------- | ------- |\n| 位          | 值      | 位          | 值      |\n| 1 01110 001 | -9/16   | 1 0110 0010 | -9/16   |\n| 0 10110 101 | 208     | 0 1110 1010 | 208     |\n| 1 00111 110 | -7/1024 | 1 0000 0111 | -7/1024 |\n| 0 00000 101 | 5/2^17  | 0 0000 0001 | 1/1024  |\n| 1 11011 000 | -2^12   | 1 1110 1111 | -248    |\n| 0 11000 100 | 768     | 0 1111 0000 | +∞      |\n\n### 2.88\n\n![image-20240324152512538](计算机系统作业1.assets/image-20240324152512538.png)\n\n\n\n**A:**正确，int转float，double转float有可能小数部分损失，但两者仍然相等\n\n**B:**错误，当x、y其中一者为INT_MAX，其他一个为整数时，会导致int溢出，导致两者不相等\n\n**C:**正确，改变运算顺序并不影响浮点数相加运算\n\n**D:**正确，改变运算顺序并不影响浮点数相乘运算\n\n**E:**错误，当dx=0，dy=1或者dx=1，dy=0时，会导致除法表达式不成立从而不总是为0。","tags":["计算机系统"],"categories":["作业"]},{"title":"Express","url":"/2019/11/Express使用/","content":"# Express\n\n<p align=\"center\">\n  <br>\n  <h2 style=\"text-align:center;color:#F4E0EA\">\n    樱春雪\n  </h2>\n  <br>\n  <br>\n  <div style=\"text-align:center\">\n    <a href=\"https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master\">湖南大学</a>\n  | <a href=\"https://theme.typora.io/theme/Drake/\">软件工程</a>\n  | <a href=\"https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md\">2204</a>\n</div>\n<br>\n<br>\n<img style=\"clear:both;display:block;margin:auto;width:400px;height:100px\" src=\"计算机系统作业1.assets\\7HN)MKDR%[2BI2$@Q69A8$H.png\">\n  <br>\n</p>\n\n\n\n## 1.初识Express\n\n### 1.1Express简介\n\n#### 1.什么是Express\n\n>Express是基于Node.js平台，快速、开放、极简的Web开发框架\n\n#### 2.进一步理解\t\t\t\t\t\t\n\nhttp内部模块使用很复杂，开发效率低；EXpress是基于http封装出来的。\n\n#### 3.Express能做什么\n\n两种服务器\n\n>Web网站服务器：专门提供Web网页的服务器\n>\n>API接口服务器：专门提供API接口的服务器\n\n**使用Express，可以方便快捷的创建两种服务器**\n\n### 1.2Express的基本使用\n\n#### 1.安装\n\n```npm\nnpm i express@4.17.1\n```\n\n#### 2.创建最基本Web服务器\n\n```js\n//1.导入\nconst express=require('express')\n//2.创建\nconst app=express()\n//3.启动Web服务器\napp.listen(80, () => {\n  console.log('express server running at localhost')\n})\n```\n\n#### 3.监听GET请求\n\n通过app.get()方法，可以监听\n\n具体语法格式如下\n\n```js\napp.get('请求url',function(req,res){//req 请求对象 res 响应对象\n  /**待处理函数**/\n})\n```\n\n#### 4.监听POST请求\n\n通过app.post()方法\n\n具体格式如下\n\n```js\napp.post('请求url',function(req,res){//req 请求对象 res 响应对象\n  /**待处理函数**/\n})\n```\n\n#### 5.把内容响应给客户端\n\n通过res.send()方法，可以把处理好的内容，发送给客户端\n\n这个方法既可以发送JSON字符串，也可以发送文本\n\n```js\napp.get('/user', (req, res) => {\n  //调用express提供的send方法相应一个对象\n  res.send({name:'zs',age:20,gender:'男'})\n})\n```\n\n```js\napp.post('/user', (req, res) => {\n  res.send('请求成功!')\n})\n```\n\n#### 6.获取URL中携带的查询参数\n\n通过req.query对象，可以访问客户端通过查询字符穿的方式\n\n```js\napp.get('/', (req, res) => {\n  //默认是空对象\n  console.log(req.query)\n  res.send(req.query)\n})\n```\n\n#### 7.获取url中的动态参数\n\n通过==req.params==对象，可以访问到URL中，通过==：==匹配到的动态参数\n\n```js\napp.get('/user/:id', (req, res) => {\n  console.log(req.params)\n  res.send(req.params)\n})\n```\n\n![image-20240325211442354](Express使用.assets/image-20240325211442354.png)\n\n也可以匹配两个至多个动态参数例如 `/:id/:name`，返回一个对象\n\n### 1.3托管动态资源\n\n#### 1.express.static()\n\nexpress提供了该函数，叫做express.static(),可以方便快捷的创建一个静态资源服务器\n\n例如，通过以下代码就可以将public目录下的图片、CSS文件、Js文件对外开放访问了\n\n```js\napp.use(express.static('public'))\n```\n\n现在就可以访问public下所有问价了\n\n==注意==\n\n> Express在指定的静态目录中查找文件，存放文件的路径名不会出现在路径名中\n\n![image-20240325212444542](Express使用.assets/image-20240325212444542.png)\n\n打开成功\n\n#### 2.托管多个静态资源目录\n\n可以多次调用express.statci()函数\n\n> 访问静态资源时候，会按照顺序依次访问资源。\n\n#### 3.挂载路径前缀\n\n需要在托管的资源访问路径之前，挂载路径前缀\n\n```js\napp.use('/public',express.static('public'))\n```\n\n### 1.4nodemon\n\n#### 1.为什么要使用\n\n> 在编写Node.js项目的时候，如果修改了项目代码，需要频繁close掉，然后重新启动 \n>\n> 使用nodemon之后，它可以监听项目文件的变动，当代码被修改之后，nodemon会帮助重启项目\n\n#### 2.安装\n\n```npm\nnpm install -g nodemon\n```\n\n## 2.Express路由\n\n### 2.1介绍\n\n### 2.2路由的使用\n\n#### 1.最简单的路由\n\n在Express中，最简单的路由的使用方式，就是把路由挂载到app上\n\n```js\n//来get\napp.get('/', (req, res) => {\n  res.send('hello world')\n})\n\n//来post\napp.post('/', (req, res) => {\n  res.send('Post ing')\n})\n```\n\n#### 2.模块化路由\n\n方便对路由进行模块化管理，不建议将路由直接挂载到app上，而是推荐==将路由抽离为单独的模块==\n\n将路由抽离为单独模块步骤\n\n>1. 创建路由.js文件\n>2. 调用express.static()方法创建路由对象\n>3. 向路由对象上挂载具体的路由\n>4. 室友moudule.exports向外共享路由对象\n>5. 使用app.use函数注册路由模块\n\n#### 3.创建路由.js文件\n\n```js\nconst express = require('express')\n//创建路由对象\nconst router = express.Router()\n//挂载具体的路由\nrouter.get('/user/list', (req, res) => {\n  res.send('Get user list.')\n})\n\nrouter.post('user/add', (req, res) => {\n  res.send('Add new user successfully')\n})\n//向外导出\nmodule.exports=router\n```\n\n#### 4.如何注册路由模块\n\n```JS\n//1.导入路由模块\nconst router=require('./router')\n//2.注册\napp.use(router)\n\n```\n\n**app.use()的作用就是用于注册全局的中间件**\n\n#### 5.为路由模块添加前缀\n\n类似于为静态资源统一挂载前缀\n\n```JS\napp.use('api',router)\n```\n\n## 3.Express中间件\n\n### 3.1中间件概念\n\n#### 1.2.概念等等\n\n略\n\n#### 3.Express中间件的调用流程\n\n当一个请求到达Express的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理\n\n![image-20240326163045849](Express使用.assets/image-20240326163045849.png)\n\n#### 4.Express中间件的格式\n\n中间件的本质就是一个function函数，其格式如下\n\n![image-20240326163143550](Express使用.assets/image-20240326163143550.png)\n\n**中间间函数形参列表中，必须包含一个next形参，而路由处理函数中只有req、res**\n\n==next形参必须放到最后一个==\n\n#### 5.next函数的作用\n\n==next 函数是实现多个中间件连续调用的关键==，他表示把流转关系转交给下一个中间件或路由\n\n![image-20240326163407998](Express使用.assets/image-20240326163407998.png)\n\n### 3.2定义中间件函数\n\n#### 1.定义\n\n可以通过如下方式\n\n```js\nconst express = require('express')\nconst app = express()\n\n//定义一个最简单的中间件函数\nconst mw = (req,res,next) => {\n  console.log('最简单的中间件函数')\n  //把流转关系交给下一个中间件或者函数\n  next()\n}\napp.listen(80, () => {\n  console.log('Running')\n})\n```\n\n#### 2.全局生效的中间件\n\n客户端发起的**任何请求**，到达服务器之后，都会触发的中间件，成为==全局生效的中间件==\n\n通过调用**app.use(中间件函数)**，即可定义一个全局生效的中间件，\n\n```js\napp.use(mw)\n```\n\n![image-20240326164327361](Express使用.assets/image-20240326164327361.png)\n\n#### 3.定义全局中间件的简化形式\n\n```js\napp.use((req, res, next) => {\n  console.log('This is the app')\n})\n```\n\n#### 4.中间件的作用\n\n> 多个中间件之间，可以共享**req和res**，基于这样的特性，我么可以在上游的中间件中，**统一为**req或者res添加自定义属性或者方法，**供下游**中间件或者路由使用\n\n![image-20240326164904111](Express使用.assets/image-20240326164904111.png)`\n\n现在需要在每一个需求都获取时间\n\n```JS\napp.get('/', (req, res) => {\n  const time=Date.now()\n  res.send('Home page')\n  console.log('This is get')\n})\napp.post('/user', (req, res) => {\n  const time=Date.now()\n  res.send('User')\n})\n```\n\n在中间件函数中添加自定义属性\n\n```js\napp.use((req, res, next) => {\n  //为req对象，添加自定义属性\n  const time = Date.now()\n  //添加自定义属性\n  req.startTime=time\n  console.log('This is the app')\n})\n```\n\n#### 5.定义多个全局中间件\n\n可以使用app.use连续定义多个全局中间件，客户端请求到达服务器之后，会按照前后顺序执行\n\n```js\n//第一个\napp.use((req, res, next) => {\n  console.log('第一个')\n  next()\n})\n//第二个\napp.use((req, res, next) => {\n  console.log('第二个')\n  next()\n})\n//路由\napp.get('/user', (req, res) => {\n  res.send('User page')\n})\n```\n\n![image-20240326165934807](Express使用.assets/image-20240326165934807.png)\n\n#### 6.局部生效的中间件\n\n> 不使用app.use()定义的中间件，叫做局部生效的中间件\n\n```js\nconst mwl = (req, res, next) => {\n  console.log('局部生效')\n  next()\n}\napp.get('/', (req, res) => {\n  res.send('Home page')\n})\napp.post('/user', (req, res) => {\n  res.send('User page')\n})\n```\n\n这里面只有第一个路由才能被正确设置\t\n\n#### 7.连续定义多个局部中间件\n\n可以如下定义，顺序从前到后:\n\n```js\n//1.定义中间件函数\nconst mwl1 = (req, res, next) => {\n  console.log('局部生效1')\n  next()\n}\nconst mwl2 = (req, res, next) => {\n  console.log('局部生效2')\n  next()\n}\napp.get('/',mwl1,mwl2,(req, res) => {//('/',[mwl1,mwl2],(req,res))\n  res.send('Home page')\n})\n```\n\n#### 8.中间件五个使用注意事项\n\n>1. 一定要在路由之前注册中间件\n>2. 客户但发送的请求可以连续调用多个中间件函数\n>3. 执行完中间件业务代码后，一定要使用next()\n>4. 在调用next()后，不用再写其他业务代码了，防止代码逻辑混乱\n>5. 连续调用多个中间件，多个中间件之间是共享(req,res)对象的\n\n### 3.3中间件分类\n\n==常用的中间件分类==\n\n> 1. 应用级别\n> 2. 路由级别\n> 3. 错误级别\n> 4. Express内置\n> 5. 第三方\n\n#### 1.应用级别\n\n> 通过app.use()/app.get()/app.post(),绑定到app实例上的中间件\n\n#### 2.路由级别\n\n> 绑定到express.Router()实例上的，叫做路由级别中间件\n>\n> > **差别**\n> >\n> > 应用级别中间件是绑定到app上，路由级别绑定到Router上\n\n#### 3.错误级别\n\n**作用：**专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题\n\n**格式：**错误级别中渐渐暗function()处理函数中，必须有四个形参，形参顺序从前到后\n\n```js\n（err,req,res,next)\n```\n\n```js\napp.get('/', (req, res) => {\n  throw new Error('Error occured')\n  //1.1人为制造错误\n  res.send('Home page')\n})\n\n```\n\n![image-20240326172657669](Express使用.assets/image-20240326172657669.png)\n\n**使用错误级别中间件**\n\n```js\napp.get('/', (req, res) => {\n  throw new Error('Error occured')\n  //1.1人为制造错误\n  res.send('Home page')\n})\n//定义错误级别中间件，防止崩溃\napp.use((err,req,res,next) => {\n  console.log('发生了错误' + err.message)\n  res.send('Error' + err.message)\n  next()\n})\n\n```\n\n\n\n![image-20240326172936210](Express使用.assets/image-20240326172936210.png)\n\n**程序没有崩溃**\n\n> 注意如果将中间件和路由调换顺序，还是会报错\n\n#### 4.Express内置中间件\n\nExpress再4.16.0之后有三个常用中间件，\n\n> express.static()快速托管静态资源的内置中间件，\n>\n> express.json()解析JSON格式的请求体数据(有兼容性，再4.16.0及之后)\n>\n> express.urlencoded()解析URL-encoded格式的请求日数据(有兼容性)\n\n```js\napp.use(express.json)//配置解析application/json格式化数据\napp.use(express.urlencoded({extended:false}))//配置解析application/x-www-form-urlencoded格式数据的中间件\n```\n\n==express.json()使用==\n\n```js\napp.post('/user', (req, res) => {\n  //再服务器，可以使用req.body属性来接受来自客户端的请求体数据\n  console.log(req.body)\n  //默认情况下，如果不配置解析表单数据的中间件，则req.body默认等于Undefined\n  res.send('ok')\n})\n```\n\n输出Undefined\n\n**注意，除了错误级别中间件，其他中间件必须在路由之前进行配置**\n\n```js\n//通过express.json这个中间件解析\napp.use(express.json())\napp.post('/user', (req, res) => {\n  //再服务器，可以使用req.body属性来接受来自客户端的请求体数据\n  console.log(req.body)\n  //默认情况下，如果不配置解析表单数据的中间件，则req.body默认等于Undefined\n  res.send('ok')\n})\n```\n\n成功输出json字符串\n\n![image-20240326174434765](Express使用.assets/image-20240326174434765.png)\n\n==express.urlencoded()==\n\n```js\napp.post('/book', (req, res) => {\n  console.log(req.body)\n  res.send('ok')\n})\n```\n\n![image-20240326174712500](Express使用.assets/image-20240326174712500.png)\n\n解析不了，得到空对象\n\n```js\n//通过express.urlencoded()中间件来解析表单中的urlencoded\napp.use(express.urlencoded({ extended: false }))\n```\n\n![image-20240326174852564](Express使用.assets/image-20240326174852564.png)\n\n**解析成功！**\n\n#### 5.第三方中间件\n\n> 非express官方的，由第三方出来的中间件，叫做第三方中间件\n\n**步骤**\n\n例如安装 body-parser\n\n1. npm i body-parser\n2. const parser=require('body-parser')\n3. app.use(parser.urlencoded({ extended: false }))\n\n**express中内置的express.urlencoded就是基于body-parser这个进一步封装的**\n\n### 3.4自定义中间件\n\n#### 1.步骤\n\n实现步骤：\n\n1. 定义中间件\n2. 监听req的data事件\n3. 监听req的end事件\n4. 使用queryString模块解析请求体数据\n5. 将解析出来的数据对象挂载为req.body\n6. 将子定义中间件封装为模块\n\n#### 2.定义\n\n通过app.use()定义\n\n#### 3.监听req的data事件\n\n通过监听req的data事件，就可以获取客户端发送到服务器的数据\n\n**如果数据量比较大，客户端会把数据切割分批发送到服务器**\n\n```js\n  //1.定义变量存储客户端发送的请求体数据\n  let str = ''\n  //2.监听req的data事件\n  req.on('data', (chunk) => {\n    str+=chunk\n```\n\n#### 4.监听req的end事件\n\n当end事件触发，代表数据接收完毕\n\n```js\nreq.on('end', () => {\n    //在str村发的是完整的请求体数据\n    //TODO:把字符串请求体数据，转换成对象格式\n  })\n```\n\n#### 5.使用querystring解析请求体数据\n\n```js\n   const body = qs.parse(str)\n    console.log(body)\n```\n\n![image-20240326200337095](Express使用.assets/image-20240326200337095.png)\n\n#### 6.将解析出来的数据对象挂载为req.body\n\n```js\n    req.body = body\n    next()\n```\n\n![image-20240326200614669](Express使用.assets/image-20240326200614669.png)\n\n#### 7.将子定义中间件封装为模块\n\n为了优化代码，需要把子定义中间件封装为独立模块\n\n## 4.使用Express写接口\n\n### 4.1创建最基本的Express服务器\n\n```js\nconst express = require('express')\nconst app = express()\n\napp.listen(80, () => {\n  console.log('Running...')\n})\n```\n\n### 4.2创建API路由模块\n\n```js\nconst express = require('express')\nconst router = express.Router\n\napp.listen(80, () => {\n  console.log('Running')\n})\n\nmodule.exports(router)\n```\n\n### 4.3编写GET接口\n\n```js\nrouter.get('/get', (req, res) => {\n  //通过req.query获取查询字符串，发送到服务器的数据\n  const query = req.query\n  //调用res.send()方法，向客户端相应处理的结果\n  res.send({\n    status: 0,//0成功\n    msg: 'GET 请求成功',\n    data:query\n  })\n})\n```\n\n通过上述操作成功获得了数据\n\n![image-20240326202743866](Express使用.assets/image-20240326202743866.png)\n\n### 4.4编写POST接口\n\n```JS\nrouter.post('/post', (req, res) => {\n  //获取请求体包含的url-encoded格式数据\n  const body = req.body\n  //通过send方法，响应结果\n  res.send({\n    status: 0,\n    msg: 'POST请求成功',\n    data:body\n  })\n})\n```\n\n成功获取了表单数据\n\n![image-20240326203222926](Express使用.assets/image-20240326203222926.png)\n\n### 4.5CORS跨域资源共享\n\n#### 1.接口的跨域问题\n\n==严重的问题==\n\n编写的接口不支持跨域问题。\n\n**解决接口的跨域问题主要有两种方法**\n\n> 1.CORS(主流的解决方案，推荐)\n>\n> 2.JSONP(有缺陷，只支持GET)\n>\n> 也可以使用响应头\n\n#### 2.使用CORS中间件\n\n使用步骤\n\n1. 运行 npm install cors\n2. 使用 const cors=require('cors')\n\n3. app.use(cors())\n\n#### 3.什么是CORS\n\n> cors跨区域资源共享由一系列HTTP响应头组成，这些HTTP响应头决定浏览器是否组织前端js代码是否共享\n\n#### 4.cors注意\n\n>1. cors主要在服务器端进行部署，客户端浏览器无需做任何配置\n>2. cors在浏览器中由兼容性，支支持XMLHttpRequest Level2的浏览器，才能正常访问开启了cors的服务器端接口\n\n#### 5.cors响应头部- Access-Control-Allow-Origin\n\n响应头部中携带一个 Access-Control-Allow-Origin 字段其语法如下\n\n```js\nAccess-Control-Allow-Origin:<origin>|*\n```\n\n其中 origin参数的值制定了允许访问人该资源的外域URL。\n\n例如，下面字段将只允许来自http://itcast.cn的请求\n\n```js\nres.setHeader('Access-Control-Allow-Origin','http//itcast.cn')\n```\n\n*****号代表通配符，表示允许任何域名请求\n\n#### 6.cors响应头 Access-Control-Allow-Headers\n\n![image-20240326213549750](Express使用.assets/image-20240326213549750.png)\n\n```js\n//允许客户端向服务器发送 Content-Type请求头和 X-Custom-Header请求头\n//多个请求头之间用 “，”分隔\nres.setHeader('Access-Control-Allow-Headers','Content-Type,X-Custom-Header')\n```\n\n#### 7.cors响应头部 - Access-Control-Allow-Methods\n\n默认情况下，cors仅支持客户端发起==GET、POST、HEAD==请求\n\n如果客户端希望通过 ==PUT、DELETE==等方式请求服务器，需要在该响应头指明允许所使用的HTTP方法\n\n#### 8.cors请求的分类\n\n简单请求、预检请求\n\n#### 9.简单请求\n\n![image-20240327224520915](Express使用.assets/image-20240327224520915.png)\n\n#### 10.预检请求\n\n符合以下任何一个条件按\n\n>1. 请求方式为GET\\POST\\HEAD之外的Method类型\n>2. 请求头中包含自定义头部字段\n>3. 向服务器发送了application\\json格式的数据\n\n在浏览器和服务器正式通信之前，浏览器会先发送OPTION请求进行预检，以获知服务器是否允许该实际请求，**服务器成功响应预检请求之后，才会发送真正的请求，并且携带真实数据。\n\n#### 11.简单请求和预检请求的区别\n\n> 网络请求的特点：客户端和服务器之间之会发生一次请求\n>\n> 预检请求的特点：客户端与服务器直接会发生两次请求，OPTION预检请求成功之后，才会发其真正的请求\n\n### 4.6JSONP接口\n\n#### 1.jsonp的概念和特点\n\n**概念**\n\n浏览器通过<scirpt>标签的src属性，请求服务器上的数据，同时，服务器返回一个函数的调用，这种请求的方式叫做jsonp。\n\n---\n\n**特点**\n\n1. jsonp不属于真正的ajax请求，因为他没有使用XMLHTTPRequest这个对象\n2. jsonp仅支持GET请求，不支持其他请求\n\n#### 2.创建jsonp接口的注意事项\n\n如果已经配置了CORS跨域资源共享，必须在配置CORS之前配置jsonp接口\n\n```JS\napp.get('/api/jsonp', (req, res) => {\n  //TODO 创建\n})\n//必须在配置cors之前配置jsonp\napp.use(cors())\n```\n\n#### 3.实现jsonp接口\n\n**步骤：**\n\n>1. 获取客户端发送过来的回调函数的名字\n>2. 得到通过jsonp形式发送给客户端的数据\n>3. 根据前两步得到的数据，拼接处一个函数调用的字符串\n>4. 把上一步拼接得到的字符串，响应给客户端<script>标签进行解析执行。\n\n#### 4.具体步骤\n\n```JS\n  //TODO 创建\n  //得到函数名称\n  const funcName = req.query.callback\n  //2.得到数据对象\n  const data = { name: 'zs', age: '20' }\n  //拼接\n  const str = `${funcName}(${JSON.stringify(data)})`\n  //响应\n  res.send(str)\n})\n```\n\n#### 5.使用JQUERY发起jsonp请求\n\n略\n","tags":["express","入门"],"categories":["node.js"]}]