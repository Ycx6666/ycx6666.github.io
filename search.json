[{"title":"Node.js入门","url":"/2024/03/Node.js使用教程/","content":"# Node.js使用教程\n<p align=\"center\">\n  <br>\n  <h2 style=\"text-align:center;color:#F4E0EA\">\n    樱春雪\n\t</h2>\n  <br>\n  <br>\n\t<div style=\"text-align:center\">\n    <a href=\"https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master\">湖南大学</a>\n  | <a href=\"https://theme.typora.io/theme/Drake/\">软件工程</a>\n  | <a href=\"https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md\">2204</a>\n</div>\n<br>\n<br>\n<img style=\"clear:both;display:block;margin:auto;width:400px;height:100px\" src=\"计算机系统作业1.assets\\7HN)MKDR%[2BI2$@Q69A8$H.png\">\n  <br>\n</p>\n\n\n\n\n\n\n## 1.读取文件内容\n\n### fs文件系统模块\n\nfs模块时node.js 官方提供的用来操作文件的模块\n\n> fs.readFile.()方法，用来读取指定文件中的内容\n>\n> fs.writeFile()方法，用来向指定的文件中写入文件\n\n入股要在js代码中，使用fs模块操作文件，需要用到require函数调用模块\n\n```js\nconst fs=require('fs')\n```\n\n###fs.readFile()的语法格式\n\n如果在参数列表中的参数被中括号包括起来，表示其是一个可选参数\n\n```js\nconst fs=require('fs')\nfs.readFile(path[,options],callback\n```\n\n> 参数一：必选参数，字符串，表示文件的路径\n>\n> 参数二：可选参数，表示以什么编码方式来读取文件\n>\n> 参数三：必选参数，文件读取完成后，通过回调函数拿到读取的结果\n\n```js\nconst fs=require('fs')\nfs.readFile('路径','utf8',function(err,dataStr){\n  console.log('err')\n})\n```\n\n### 判断文件是否读取成功\n\n可以判断err对象是否为null，从而知晓\n\n## 2.向指定的文件中写入内容\n\n###fs.writeFile()的语法格式\n\n使用这个方法，可以写入文件\n\n```js\nfd.writrFile(file,data[,options],callback)\n```\n\n> 参数一：必选参数，需要指定一个文件路径的字符串，表示文件的存储路劲\n>\n> 参数二：必选参数，表示要写入的内容\n>\n> 参数三：可选参数，表示以什么文件格式写入，默认utf8\n>\n> 参数四：必选参数，文件写入完成后的回调函数\n\n__需要注意的是，如果路径已经存在，那么或覆盖原有的内容__\n\n###判断文件是否写入成功\n\n如果写入成功，那么err的值等于null\n\n如果写入失败，err的值是一个错误对象\n\n## 3.处理路径问题\n\n### fs模块-路径动态拼接的问题\n\n在使用fs模块时，如果使用的时./或者../开头的相对路径时，很容易出现动态拼接错误的问题。\n\n__原因__：在代码运行的时候，==会以执行node命令时所处的目录==，动态拼接出被操作文件的完整路径。\n\n__解决方法__:直接使用绝对路径。\n\n__注意__：在js中，一个反斜杠“\\\"表示转移符，需要写两个反斜杠才表示一个反斜杠\"\\\\\"。\n\n**缺点**：移植性非常差，并且不利于维护\n\n**解决方法**:==__dirname==表示当前文件所处的目录，==不会被node命令所处目录变化而变化==。\n\n例如\n\n### 03.1使用path路径模块\n\npath是用来专门处理路径的模块，他提供了一系列的方法和属性，用来满足用户对路径的处理需求。\n\n exp\n\n> path.join()方法：用来将多个路径片段拼接成一个完整的路径字符串。\n>\n> path.basename()方法：用来从路径字符串中，将文件名字解析出来。\n\n需要以下导入：\n\n```js\nconst path=require('path')\n```\n\n### 03.2路径拼接\n\npath.join()的代码示例：\n\n==注意:==在==../==之前的一个字符串将被抵消。\n\n```js\nconst path = require('path')\n\n//../抵消\nconst pathStr=path.join('/a', '/b/c', '../', '/d', '/e')\nconsole.log(pathStr)//输出\\a\\b\\d\\e\n```\n\n**以后进行拼接时尽量使用path.join(),可以避免错误输入路径带来的某些错误（.)**\n\n### 03-3获取路径中的文件名\n\n**1.path.basename():**可以获取路径中的最后一部分，可以使用这个方法获取路径中的文件名，格式如下\n\n```js\npath.basename(path[,ext])\n```\n\n**代码示例**，使用这个方法，可以从一个文件路径中，获取到文件的名称部分：\n\n```js\nconst path = require('path')\n\nconst fpath = '/a/b/c/index.html'\n\nconst fullname = path.basename(fpath)\nconst fullname2 = path.basename(fpath, '.html')//消除扩展名\n\nconsole.log(fullname)//拿到文件名\nconsole.log(fullname2)\n```\n\n### 03-4如何获取路径中的文件扩展名\n\n**语法格式**：path.extname()的代码\n\n```js\nconst path = require('path')\n\nconst fpath = '/a/b/c/index.html'\n\nconst fext = path.extname(fpath)\n\nconsole.log(fext)//.html\n```\n\n### 03-5时钟案例\n\n步骤：\n\n​\t1.创建两个正则表达式，用来匹配<style>和<scipt>标签\n\n​\t2.使用fs模块，读取需要被处理的HTML文件\n\n​\t3.自定义resolveCSS方法，写入index.css文件\n\n​\t4.自定义resolveJs方法，写入index.js文件\n\n​\t5.自定义resolveHtml方法，写入index.html文件\n\nresolveCSS()方法:\n\n```js\nfunction resolveCSS(htmlStr) {\n  const r1 = regStyle.exec(htmlStr)\n  const newCSS = r1[0].replace('<style>', '').replace('</style>', '')\n  //写入index.css文件\n  fs.writeFile(path.join(__dirname,'../素材1/index.css'), newCSS, (err) => {\n    if (err)\n      return console.log('写入CSS样式失败！' + err.message)\n      console.log('写入样式文件成功!')\n  })\n}\n```\n\nresolveJs()方法：\n\n```js\nfunction resolveJs(htmlStr) {\n  const r2 = regJs.exec(htmlStr)\n  const newJs = r2[0].replace('<script>', '').replace('</script>', '')\n  //写入index.css文件\n  fs.writeFile(path.join(__dirname,'../素材1/index.js'), newJs, (err) => {\n    if (err)\n      return console.log('写入JS文件失败！' + err.message)\n      console.log('写入JS文件成功!')\n  })\n}\n```\n\nrsolveHTML()方法\n\n```js\nfunction resolveHTML(htmlStr) {\n  //调用replace方法\n  const newHTML=htmlStr.replace(\n    regStyle,`<link rel=\"stylesheet\" href=\"./index.css\">`\n  ).replace(\n    regJs,'<script src=\"./index.js\"></script>'\n  )\n  //写入\n  fs.writeFile(path.join(__dirname, './素材1/index.html'), 'utf8', (err) => {\n    if (err) {\n      return console.log('写入HTML文件失败！'+err.message)\n    }\n    console.log('写入HTML文件成功！')\n  })\n}\n```\n\n==注意点==\n\n> 1.一定要新建一个文件夹\n>\n> 2.使用fs.write()方法写入内容时，重复写入会导致新内容覆盖旧内容\n\n## 4.HTTP模块\n\n###4.1什么是HTTP模块\n\n==概念==\n\n在网络节点，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。\n\n==方法==\n\nhttp模块中的http.createServer()方法，能把一台普通的电脑，变成一台Web服务器\n\n==引入==\n\n``` js\nconst http=require('http')\n```\n\n### 4.2进一步理解http模块的作用\n\n==服务器和普通电脑的区别==\n\n服务器和普通电脑的区别，服务器上安装了Web服务器软件，例如：IIS，Apache等，通过这些服务器软件，能把一台普通的电脑变成一台Web服务器。\n\n**在nodejs中，我们不需要这些软件，我们可以通过HTTP模块创建一个服务器**\n\n### 4.3服务器相关概念\n\n==IP地址==\n\n- 互联网上每台计算机的唯一标识。\n\n- 格式：“点分十进制”，a.b.c.d，其中abcd都是0-255之间的十进制整数。\n\n- **在cmd中输入ping 网站 可以获取网站IP地址**\n\n- 在自己电脑中输入127.0.0.1就可以访问本机了。\n\n==域名和域名服务器==\n\n- IP地址不够直观，因此发明了域名来方便人们记忆\n\n- IP地址和域名是一一对应的关系，这种关系存放在一种叫做**域名服务器(DNS)**的电脑中。\n\n**注意**\n\n127.0.0.1对应的域名是localhost\n\n==端口号==\n\n 一台电脑中，可以运行很多个Web服务，每个Web都对应一个唯一的端口号，通过端口号，可以将网络请求准确的发给对应的Web服务。\n\n**注意**\n\n- 每个端口号不能被同时多个Web服务占用\n\n- 在是基于应用中，只有80端口可以在URL中省略。\n\n### 4.4创建最基本的Web服务器\n\n#### 1.创建最基本的Web服务器的步骤\n\n1. 导入http模块\n2. 创建Web服务器示例\n3. 为服务器绑定request时间，监听客户端请求\n4. 启动服务器\n\n#### 2.示例代码\n\n```js\n//1\nconst http = require('http')\n\n//创建示例\nconst server = http.createServer()\n\n//3.绑定request\nserver.on('reques', (req, res) => {\n  console.log('某人访问了服务器....')\n})\n\n//4.启动\nserver.listen(80, () => {\n  console.log('server running...')\n})\n```\n\n### 4.5.REQ\n\n3.req请求对象，只要服务器收到了客户端的请求，就会调用通过server.on()位服务器绑定的事件处理函数\n\n包含了与客户端相关的数据和属性\n\n> req.url是客户端请求的URL地址\n>\n> req.method是客户端请求的method类型\n\n### 4.6时钟Web服务器案例\n\n#### 1.核心思路\n\n> 将每个文件的实际存放路径，作为每个资源的请求URL地址\n\n#### 2.实现步骤\n\n1. 导入需要的模块\n2. 创建基本Web服务器\n3. 将资源url地址作为文件存放路径\n4. 读取文件内容并响应客户端\n5. 优化资源请求路径\n\n#### 3.导入需要的模块\n\n```js\nconst fs=require('fs')\nconst path=require('path')\nconst http=require('http')\n```\n\n#### 4.将资源url作为文件存放路径\n\n获取到的请求路径:==/index.html==\n\n#### 5.读取文件内容并发送给客户端\n\n```js\n  fs.readFile(fpath, 'utf8', (err, dataStr) => {\n    //4.2读取失败\n    if (err)\n      return res.end('404 Not Found')\n    //4.3读取成功\n    res.end(dataStr)\n  })\n```\n\n> 如果获取的文件内容中引用了其他文件，那么浏览器会自动请求\n\n#### 6.优化请求资源的路径\n\n如果请求根路径，那么就用/clock/index.html来代替\n\n## 5.模块化\n\n### 5.1是么是模块化\n\n#### 1.编程领域中的模块化\n\n此处的模块化，就是固定遵守的规则，把一个大文件拆分成独立并且互相依赖的多个小模块。\n\n**好处**\n\n> 提高了代码复用性\n>\n> 提高了代码可维护性\n>\n> 可以实现按需加载\n\n### 5.2模块化规范\n\n模块规范化就是在对代码进行模块化的拆分与组合时，需要遵守的那些规则\n\n好处：降低了沟通的成本，极大方便了各个模块的相互调用\n\n## 6.Nodejs中的模块化\n\n### 6.1模块的分类\n\n>**内置模块**：内置模块是由Nodejs官方提供的，例如fs，path,http等等\n>\n>**自定义模块**：用户创建的每个.js文件，都是自定义模块\n>\n>**第三方模块**:由第三方开发出的模块，不是官方也不是用户提供的\n\n### 6.2加载模块\n\n使用强大的==require==方法，可以加载需要的各种模块\n\n```js\n//加载内置模块\nconst fs=require('fs')\n//加载用户自定义模块，如果去掉.js后缀名也能运行\nconst custom=require('./custom.js')\n//加载第三方模块\nconst moment=require('moment')\n```\n\n==使用其他模块时，调用时就会加载模块的代码==\n\n### 6.3模块作用域\n\n#### 1.什么是作用域\n\n和函数作用域类似，自定义模块中的方法、变量等等，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域\n\n#### 2.好处\n\n防止全局变量污染的问题\n\n![image-20240321205245056](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240321205245056.png)\n\n![image-20240321205419593](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240321205419593.png)\n\n### 6.4向外共享模块作用域中的成员\n\n#### 1.module对象\n\n每个.js自定义文件中都有一个module对象，他存储了当前模块的数据等等\n\n![image-20240321205637062](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240321205637062.png)\n\n#### 2.module.exports对象\n\n在自定义模块中，可以使用这个对象可以将模块内的成员共享出去；\n\n外界使用require()方法导入自定义模块时，得到的就是module.exports所指向的对象\n\n==在一个自定义模块中，默认的module.exports对象就是空对象，也就是module对象==\n\n```js\nmodule.exports.sayHello=function() {\n  console.log(`我是${usename}`)\n}   \n\nmodule.exports.usename = 'zs'//像module.exports中挂载一个属性\n```\n\n![image-20240321222048156](Node.js使用教程.assets/image-20240321222048156.png)\n\n#### 3.共享成员的注意点\n\n使用require()方法导入模块时，导入的结果，永远以module.exports指向的对象为准\n\n#### 4.exports对象\n\nmodule.exports和exports指向的是同一个对象\n\n最终指向的值，==以module.exports==指向的对象为准\n\n#### 5.module.exports和exports使用误区\n\n>1. 使用require时，得到的永远都是module.exports对象\n\n为了防止混乱，建议大家不要在同一个模块中同时使用两者\n\n### 6.5Nodejs中的模块化规范\n\nnodejs遵循了**CommonJS模块化规范**，其规定了模块的特性和各模块之间如何互相依赖\n\n**CommonJS规定：**\n\n> 1.每个模块内部，module变量代表当前某块\n>\n> 2.module变量是一个对象，他的exports属性(即module.exports)是对外的接口\n>\n> 3.加载某个模块，其实是加载该模块的module.exports属性，require()方法用于加载模块\n\n## 7.npm与包\n\n### 7.1初步入门\n\n#### 什么是包\n\nNodejs中的第三方模块又叫做包\n\n#### 包的来源\n\nNodejs的内置模块和自定义模块，都是由第三方团队制作的\n\n#### 为什么需要\n\n==原因==Nodejs的内置某块仅提供了一些底层的api，导致开发时效率低\n\n包是基于内置模块封装出来的\n\n#### 怎么下载\n\nnpm公司 <www.npmjs.com>是全球最大的包共享平台\n\nnpm公司还提供了一个地址为 https://registy.npmjs.org/的服务器，来对外共享所有的包，但是其打不开。\n\n#### 如何下载\n\n这个包管理工具叫做==Node Package Manager==(简称npm包管理工具)\n\n### 7.2npm初体验\n\n#### 1.格式化实践的传统做法\n\ndateFormat()方法\n\n```js\nfunction dateFormat(dtStr) {\n  const dt = new Date(dtStr)\n  const y = dt.getFullYear()\n  const m = padZero(dt.getMonth()+1)\n  const d = padZero(dt.getDate())\n\n  const hh = padZero(dt.getHours())\n  const mm = padZero(dt.getMinutes())\n  const ss = padZero(dt.getSeconds())\n\n  return `${y}-${m}-${d} ${hh}:${mm}:${ss}` \n}\nfunction padZero(n) {\n  return (n > 9 ? n : '0'+n);\n}\n\nmodule.exports = {\n  dateFormat\n}\n```\n\n\n\n#### 2.格式化时间高级做法\n\n> 1.使用npm包管理工具，安装时间包moment\n>\n> 2.使用require\n>\n> 3.参考官方文档调用API\n\n#### 3.在项目中安装包\n\n初次安装包后，会在项目文件夹下多一个叫做node_modules的文件夹和package-lock.json的文件\n\n第一个用于存放所有一安装到项目中的包\n\n第二个记录了第一个目录下每一个包的下载信息\n\n```npm\nnpm install 包的完整名称\n可以简写为\n \t\t\t\tnpm i 完整的名称\n```\n\n#### 4.使用moment\n\n```js\n//导入\nconst moment = require('moment')\n\nconst dt = moment().format('YYYY-MM-DD HH-mm-ss')\nconsole.log(dt)\n```\n\n#### 5.安装指定版本的包\n\n在包的名称之后，==通过@符号跟上具体的版本号==，从而安装指定版本的包\n\n后安装的相同的包会覆盖原有的包\n\n#### 6.包的语义化版本规范\n\n包的版本号是按照点分十进制形式进行定义的，总共由三位数字\n\n>1.第一位数字：大版本\n>\n>2.第二位数字：功能版本\n>\n>3.第三位数字：Bug修复版本\n\n### 7.3包管理配置文件\n\nnpm**规定**，在项目根目录中，必须提供一个叫做package.json的包配置管理文件，用来记录与项目有关的一些配置信息\n\n- **项目的名称、版本号、描述等等**\n- **项目中用到了那些包**\n- **那些包只会在开发期间用到**\n- **那些包在开发和部署起家都会用到**\n\n#### 1.多人协作的问题\n\n1. 第三方包体积过大，不方柏霓团队成员之间共享项目源代码\n\n#### 2.如何记录项目中安装了哪些包\n\n在项目根目录中，创建一个叫做==package.json==的配置文件，用于记录项目中安装了哪些包，\n\n以后在项目开发中，一定要把**node_modules文件夹**，添加到.gitignore忽略文件中\n\n#### 3.快速创建package.json\n\n可以在执行目录中，快速创建package.json包管理配置文件\n\n```js\nnpm init -y\n```\n\n**注意**\n\n>上述命令只能在英文目录下运行\n>\n>运行npm install时，npm包管理工具会自动把包的名称和版本号，记录到package.json文件中\n\n**PS:**现在已经可以自动创建package.json文件了！\n\n#### 4.depenencies节点\n\n这个节点，用于记录npm install 安装了哪些包，会记录包的名称和版本号\n\n![image-20240324214311357](Node.js使用教程.assets/image-20240324214311357.png)\n\n#### 5.一次性安装所有包\n\n拿到一个node_module被删除了的项目之后，需要先把所有的包下载下来，不然运行不起来\n\n使用\n\n```js\nnpm install //npm i\n```\n\n可以一次性安装所有的包\n\n#### 6.卸载包\n\n可以运行==npm uninstall + 指定包==命令\n\n注意，删除包之后，在node_mudules中业户删除包信息\n\n#### 7.devDependencies节点\n\n如果某些包旨在项目开发阶段使用，可以把这些包记录到**devDependencies**节点中；\n\n如果某些包在开发与上线中都要用到，那建议记录到**Dependencies**\n\n\n\n可以使用如下命令：\n\n```js\n//安装指定包到devDependencies\nnpm i 包名 -D\n//上述命令是简写形式\nnpm install 包名 --save-dev\n```\n\n### 7.4解决下包速度慢的问题\n\n#### 1.为什么慢\n\n使用npm下包时，默认从国外网站进行下载\n\n官方源 <https://registry.npmjs.org/>\n\n#### 2.淘宝镜像\n\n==已安装==\n\n#### 3.切换npm下包镜像源\n\n```npm\nnpm config get registry //查看下包源\nnpm config set registry=https://registry.npm.taobao.rog/ //切换为淘宝镜像源\n```\n\n#### 4.nrm\n\n为了更方便切换，可以使用nrm这个工具，快速查看和切换\n\n```npm\n#安装全局\nnpm i nrm -g\n#查看可用镜像源\nnrm ls\n#将下包镜像源切换为taobao\nnrm use taobao\n```\n\n### 7.5包的分类\n\n#### 1.项目包\n\n那些被安装到项目中的node_modules的包，都是项目包\n\n>开发依赖包 在devD\n>\n>核心依赖包 在D\n\n#### 2.全局包\n\n在执行==npm install==时候，如果提供了-g参数，则会把她安装为全局包\n\n==注意-==\n\n只有工具性的包，才有全局安装的必要***\n\n判断某个包是否全局才能使用，查看官方文档即可***\n\n#### 3.i5ting_toc\n\n> i5ting_doc是一个可以把md文档转为htnl页面的小工具，使用步骤如下\n\n```npm\n#将其安装为全局包\nnpm install -g i5ting_toc\n#调用i5ting_toc，轻松和实现md 转 html页面功能\ni5ting_toc -f 要转换的md文件路径 -o\n```\n\n#### 4.规范的包结构\n\n1. 每一个包都需要单独的目录\n2. 包的顶级目录下必须要package.json这个配置文件\n3. package.json必须包含name,version,main三个属性，对应了包的名字、版本号和包的入口\n\n### 7.6开发属于自己的包\n\n#### 1.skip\n\n#### 2.初始化包的基本结构\n\n1. 新建itheima-tools文件夹，作为包的根目录\n2. 在itheima-tools文件夹中华，新建如下三个文件\n   - package.json\n   - index.js\n   - README.md\n\n#### 3.初始化package.json\n\n```json\n{\n  \"name\": \"ycx_tools\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"description\": \"提供了格式化时间、HTMLESCAPE的功能\",\n  \"keywords\": [\n    \"ycx_tools\",\n    \"format\",\n    \"ycx\",\n    \"escape\"\n  ],\n  \"license\":\"ISC\"\n}\n```\n\n#### 4.在index.js中定义方法\n\n```js\nfunction dateFormat(dtStr) {\n  const dt = new Date(dtStr)\n  const y = dt.getFullYear()\n  const m = padZero(dt.getMonth()+1)\n  const d = padZero(dt.getDate())\n\n  const hh = padZero(dt.getHours())\n  const mm = padZero(dt.getMinutes())\n  const ss = padZero(dt.getSeconds())\n\n  return `${y}-${m}-${d} ${hh}:${mm}:${ss}` \n}\nfunction padZero(n) {\n  return (n > 9 ? n : '0'+n);\n}\n\nmodule.exports = {\n  dateFormat\n}\n```\n\n**即使require没有指定文件，根据package.json中的main属性来查找**\n\n#### 5.在index.js中定义转移HTML的方法\n\n```js\n//定义转移html\nfunction htmlescape(htmlStr) {\n  return htmlStr.replaca(/<|>|\"|&/g, (match) => {\n    switch (match) {\n      case `<`:\n        return '&lt;'\n      case `>`:\n        return '&gt;'\n      case `\"`:\n        return '&quot;'\n      case `&`:\n        return '&amp;'\n    }\n  })\n}\n```\n\n#### 6.index.js定义还原HTML的方法\n\n```js\n//定义还原HTML\nfunction htmlUnEscape(str) {\n  return str.replace(/&lt;|&gt;|&quot;|&amp;/g, (match) => {\n    switch (match) {\n      case `&lt;`:\n        return '<'\n      case `&gt;`:\n        return '>'\n      case `&quot;`:\n        return '\"'\n      case `&amp;`:\n        return '&'\n    }\n  })\n}\n```\n\n#### 7.将不同的功能纪念性模块化拆分\n\n>1. 将格式化时间的功能，拆分到src->dateFormat.js中\n>2. 将处理HTML字符换的功能，拆分到src->htmlescape.js中\n>3. 在index.js中，导入两个模块，得到需要向外共享的方法\n>\n>4.在index.js中，使用module.exports把对应的方法共享出去\n\n\n\n**es6--扩展运算符** 将数组或者对象的内容转换为一段以逗号隔开的序列\n\n```js\nmodule.exports = {\n  ...date,//展开运算符\n  ...escape\n}\n```\n\n#### 8.编写包的说明文档\n\nREADME.md文档用于说明包\n\n**可以包含以下说明**\n\n>安装方式、导入方式、格式化时间\n>\n>转移HTML中的特殊字符、还原HTML中的特殊字符、开源协议\n\n### 7.7发布包\n\n#### 1.注册账号\n\n==已注册==\n\n#### 2.登录\n\n在命令行中输入 `npm login` 进行登录\n\n**注意，使用之前需要先将服务器切换到官方服务器**\n\n`npm config set registry=https://registry.npmjs.org/`\n\n#### 3.把包发布到npm上\n\n> 将终端切换到包的根目录，运行 npm publish命令，即可发布\n\n![image-20240325110008091](Node.js使用教程.assets/image-20240325110008091.png)\n\n发布成功!!!\n\n#### 4.删除已发布的包\n\n**注意**\n\n```npm\nnpm unpublish 包名 --force，即可删除\n```\n\n\n\n>npm unpublish命令只能删除72小时以内的包\n>\n>npm unpublish删除的包，在24小时内不能重新发布\n>\n>尽量不要发布没有意义的包\n\n## 8.模块的缓存机制\n\n### 8.1优先从缓存中加载\n\n模块第一次加载会被缓存，这也意味着多次调用require()不会导致模块代码被执行多次\n\n**注意**  各种模块都会从缓存中加载，从而提高模块的加载效率\n\n### 8.2内置模块加载机制\n\n> 内置模块是Node.js提供的模块，优先级最高。\n\n### 8.3自定义模块加载机制\n\n使用require()加载自定义模块是，必须指定以./ 或者 ../开头的路径标识符，否则node会把他当作第三方模块或者内置模块加载\n\n如果省略了文件扩展名，那么node或按照一下顺序分别尝试加载文件\n\n1. 按照确切的文件名进行加载\n2. 补全.js进行加载\n3. 补全.json进行\n4. 补全.node\n5. 加载失败\n\n### 8.4第三方模块加载机制\n\n如果传递给require的不符合上述两种规则，则node.js会从当前模块父目录开始，尝试从/node_modules加载第三方模块\n\n如果没有找到，则移动到再上一层父目录中，直到磁盘根目录中。\n\n### 8.5目录作为模块\n\n把目录作为标识符，传递给require()时，有三种加载方式\n\n>1. 被加载目录下查找一个叫做package.json的文件，并寻找main属性，作为require()入口\n>2. 如果没有.json文件按，或者main不存在或者无法解析，则Node.js或试图加载目录下的index.js文件\n>3. 如果都失败了，会打印模块缺失 Error:Cannot find module 'xxx'\n\n# \n\n\n\n","tags":["入门","nodejs"],"categories":["node.js"]},{"title":"协变返回类型","url":"/2024/03/协变返回类型/","content":"# 协变返回类型\n\n## 定义\n\n==定义==\t<p>导出类中被覆盖的方法可以返回积累芳芳的返回类型的某种到处类型</p>\n\n\n```java\n//polymorphism/CovariantReturn.java\npackage polymorphism;\nclass Grain {\n  public String toString() { return \"Grain\"; }\n}\nclass Wheat extends Grain {\n  public String toString() { return \"Wheat\"; }\n}\nclass Mill {\n  Grain process() { return new Grain(); }\n}\nclass WheatMill extends Mill {\n  Wheat process() { return new Wheat(); }\n}\npublic class CovariantReturn {\n  public static void main(String[] args) {\n    Mill m = new Mill();\n    Grain g = m.process();\n    System.out.println(g);\n    m = new WheatMill();\n    g = m.process();\n    System.out.println(g);\n  }\n} /* Output:\nGrain\nWheat\n*///:~\n\n```\n\n## 状态模式\n\n\n```java\nclass Stage {\n\n  private Actor actor = new HappyActor();\n\n  public void change() { actor = new SadActor(); }\n\n  public void performPlay() { actor.act(); }\n```\n\n## 纯继承模式\n\n\n<blockquote>只有在基类中出现的方法才可以在导出类中定义，是一种纯粹的“is a\"关系\n\n<blockquote>扩展接口可定义为”is-like-a\"关系\n\n```java\n//: polymorphism/RTTI.java\n// Downcasting & Runtime type information (RTTI).\n// {ThrowsException}\npackage polymorphism;\nclass Useful {\n  public void f() {System.out.println(\"Userful:f()\");}\n  public void g() {System.out.println(\"Userful:g()\");}\n}\n\nclass MoreUseful extends Useful {\n  public void f() {System.out.println(\"MoreUseful:f()\");}\n  public void g() {System.out.println(\"MoreUseful:g()\");}\n  public void u() {System.out.println(\"MoreUseful:u()\");}\n  public void v() {System.out.println(\"MoreUseful:v()\");}\n  public void w() {System.out.println(\"MoreUseful:w()\");}\n}\t\n\npublic class RTTI {\n  public static void main(String[] args) {\n    Useful[] x = {\n      new Useful(),\n      new MoreUseful()\n    };\n    x[0].f();\n    x[1].g();\n    // Compile time: method not found in Useful:\n    //x[1].u();\n    ((MoreUseful)x[1]).u(); // Downcast/RTTI\n  //  ((MoreUseful)x[0]).u(); // Exception thrown\n   \n    if (x[0] instanceof MoreUseful)\n    {\n    \tSystem.out.println(\"ttt\");\n    \tMoreUseful mf = (MoreUseful) x[0];\n    \tmf.u();\n    }\n    \n    \n  }\n} ///:~\n\n```\n\n==对象不能向上转型，类型才能向上转型。==\n\n==内存分析== \n\n\"[Java多态的向上转型——内存分析_向上转型内存结构-CSDN博客](https://blog.csdn.net/qq_43582566/article/details/121909107)\"\n\n\n\n# java的异常处理机制\n\n## throws\n\n![image-20231220165420962](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231220165420962.png)\n\n<b>例</b>  \n\n```java\nstatic void calculate() throws IllegalAccessException{\n\t\tint c[]={1,2};\n\t\tc[5]=60;\n\t\tint a=0;\n\t\tSystem.out.println(\"a=\"+a);\n\t    int b=50/a;\n\t    throw new IllegalAccessException();\n\t}\n\tpublic static void main(String args[]){\n\t\ttry\n\t\t{\n\t\t\tcalculate();\n\t\t}   \n\t\tcatch (IllegalAccessException e)\n\t\t{\n\t\t\tSystem.out.println(\"非法存取\"+e);\n\t\t}\n```\n\n\n\n# 泛型编程\n\n功能类似于cpp中的模板,作用是提高代码的复用率\n\n例\n\n```java\nstatic void calculate() throws IllegalAccessException{\n\t\tint c[]={1,2};\n\t\tc[5]=60;\n\t\tint a=0;\n\t\tSystem.out.println(\"a=\"+a);\n\t    int b=50/a;\n\t    throw new IllegalAccessException();\n\t}\n\tpublic static void main(String args[]){\n\t\ttry\n\t\t{\n\t\t\tcalculate();\n\t\t}   \n\t\tcatch (IllegalAccessException e)\n\t\t{\n\t\t\tSystem.out.println(\"非法存取\"+e);\n\t\t}\n```\n\n## 泛型类\n\n> 泛型是带一个或则和多个类型参数的类\n\neg \n\n```java\npackage generics;\n\npublic class Box<T> {\n\tprivate T  t;\n\tpublic void add(T  t) {\n\t\tthis.t = t;\n\t}\n\tpublic T  get() {\n\t    return  t;\n\t}\n\tpublic static void main(String[] args){\n\t\tBox<String> box = new Box();\n\t    Box<Integer> box1 = new Box<Integer>();\n\t\tbox.add(\"hello\");     //box.add(100);\n\t\tSystem.out.println(box.get());\n\t   }\n\t}\n\n\n```\n\n> 泛型类的使用与方法调用类似。 ¡ 方法调用需向方法传递参数，使用泛型需传递一个类型参 数，即用某个具体的类型替换T。 要在Box对象中存放String对象，就要在创建Box对象时为其 传递String类型参数。 ¡ 要实例化泛型类对象，也使用new运算符，但在类名和括 号之间需加上要传递的具体类型，\n>\n> > 例如： //在JDK 1.7之前，创建泛型对象时的写法 BoxGenerics box = new BoxGenerics(); \n>\n> > //在JDK 1.7之后，创建泛型对象时的写法 BoxGenerics box = new BoxGenerics(); \n>\n> 按照约定，类型参数名使用单个大写字母表示。常用的类 型参数名（标记符）有：E表示元素，K表示键，N表示数字，T 表示类型，V表示值，？等\n\n> 当没有指定模板类型时，会默认当成object对像\n\n```java{\npublic class REG1 {\n\tpublic static void main(String[] args)\n\t{\n\t    CE c3=new CE();\n\t    c3.x=5;\n\t    c3.y=10;\n\t    System.out.println(c3.toString());\n\t}\n}\n\n```\n\n![image-20231222144704812](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231222144704812.png)\n\n当定义数组时，不能直接定义,需要用以下方法:\n\n```java\nint i=0;\n\t//CE<Integer,Double>[] carry1=new CE<Integer,Double>[5];\n\t\tCE<Integer,Double>[] carry2=new CE[5];\n\t\tfor(i=0;i<5;i++)\n\t\t{\n\t\t    carry2[i]=new CE<Integer,Double>();\n\t\t}\n```\n\n\n\n## 泛型方法\n\n#### 类型擦除\n\n在泛型代码内部，无法获得任何有关泛型参数的信息。 ¡ 当泛型类型实例化时，编译器使用一种叫类型擦除的技术 转换这些类型。在编译时，编译器将清除类和方法中的所 有与类型参数有关的信息。 ¡ Java考虑到兼容问题，使用擦除实现泛型，意味着泛型使 用时，任何具体的类型信息都被擦除了，唯一知道的就是 你在使用一个对象。\n\n```java\n public class ErasedTypeEquivalence { public static void main(String[] args) { Class c1 = new ArrayList().getClass(); Class c2 = new ArrayList().getClass(); System.out.println(c1 == c2); //True or False？ } } //generics.ErasedTypeEquivalence.java 35 //: generics/LostInformation.java\n```\n\n#### 边界\n\n> <u>边界通配符</u> <code>? super Apple</code> 表示传入apple整个类及其以上的父类。\n>\n> <u>边界通配符</u> <code>? extend Apple</code> 表示传入apple整个类及其以下的子类。\n\n* 1.上界不能往里存，只能往外取 编译器只知道容器里的是Fruit或者Fruit的子类，但不 知道它具体是什么类型，所以存的时候，无法判断是否要存 入的数据的类型与容器种的类型一致，所以会拒绝set操作。 \n\n* 2.下界往外取只能赋值给Object变量，不影 响往里存 因为编译器只知道它是Fruit或者它的父类，这样实际上 是放松了类型限制，Fruit的父类一直到Object类型的对象 都可以往里存，但是取的时候，就只能当成Object对象使用 了。\n\n*  所以如果需要经常往外读，则使用，如果需 要经常往外取，则使用。\n\n  [＜? extend T＞和＜? super T＞的解释_-CSDN博客](https://blog.csdn.net/qq_58746475/article/details/119887000?ops_request_misc=%7B%22request%5Fid%22%3A%22170323034416800222821634%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=170323034416800222821634&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-119887000-null-\tnull.142^v96^pc_search_result_base9&utm_term= extend &spm=1018.2226.3001.4187)\"\n\n  > <u>无界通配符</u>  使用无界通配符指定一个未知类型 “？” 。 ？ 与==? extend Apple==具有相同的含义，表示任何类 型。\n\n## 泛型接口\n\n<ul>泛型也可以用于接口\n\n* 实现泛型接口时，如果不生命类型，那么泛型自动变为object\n* 如果想保留接口中的泛型，则在实现剋的声明时，必须保留泛型接口中的泛型声明\n* 也可以在是实现时，直接给定接口泛型中的具体类型\n\n#### 使用泛型需要注意的问题\n\n* 任何基本类型都不能作为类型参数\n* 实现参数化接口，由于擦除，一个类不能实现同一 泛型接口的两种变体\n* 转型与警告：使用带泛型类型参数的转型， instanceof无任何效果，因为擦除\n*  方法重载：类型参数不能识别\n","tags":["Java","协变"],"categories":["Java"]},{"title":"操作系统第四组第二次小班课","url":"/2024/03/大纲 - 副本/","content":"# 操作系统第四组第二次小班课\n\n> 代码实现利用多进程实现 C/S 模式聊天程序，启动一个服务器，单个和多个客户端，服务端接收到新的客户端请求就创建一个进程与客户端通信。\n\n## CS 架构和 BS 架构\n\n常见的软件架构有两种：CS、BS。不管是哪种，真正的核心处理逻辑都是在服务器上：\n\n1. CS：Client/Server（客户端 / 服务器），采取这种架构的软件，在用户本地需要下载并安装客户端程序，在远程有一个服务器端程序。比如：QQ、steam。\n\n   优点：事先下载好所有资源，用户体验好。缺点：需要开发客户端和服务端，开发、部署、维护麻烦，服务端更新时，客户端也需要更新。CS架构适合定制专业化的办公类软件。\n\n2. BS：Brower/Server（浏览器 / 服务器），采取这种架构时，只需要一个浏览器，用户通过不同的网址就可以访问不同的服务器。比如：京东、淘宝（网页端）。\n\n   优点：方便，不需要开发客户端，只需要页面+服务端，且只需要打开浏览器就可以使用。缺点：需要通过网络传输所有的图片、音频资源，如果资源过大，则会降低用户体验。BS架构适合移动互联网应用。\n\n## 网络编程三要素\n\n当我们要向另外一台计算机发送信息时，我们要知晓对方电脑在互联网上的地址（**IP**），还需要确定对方电脑接受数据的软件（**端口号**，一个端口号只能被一个软件绑定使用），还需要确定网络传输的规则（**协议**）。故**IP、端口号、协议**就是网络编程三要素。\n\n**网络编程三要素**：\n\n1. IP：设备在网络中的地址，是唯一的标识。\n2. 端口号：应用程序在设备中唯一的标识。\n3. 协议：数据在网络中传输的规则，常见的协议有 UDP、TCP、http、https、ftp。\n\n### IP\n\n全称：Internet Protocol，是互联网协议地址，也称IP地址。是分配给上网设备的数字标签。常见的IP分为：ipv4、ipv6。\n\nIPv4：全称为Internet Protocol version 4，即互联网通信协议第四版。采用**32位地址长度**，**分成4组（每组1字节，8位）**。一般用**点分十进制表示法**，例如：`192.168.1.66`。每一组最大值是255，最小值是0。在IPv4中，每一组有256种表示方法，一共4组，最多可以表示 $256^4 = 4294967296$ 种地址，数量有限，不够使用。实际上，在2019年11月26日，IPv4的全部可用地址就已经分配完毕了。\n\nIPv6：全称为Internet Protocol version 6，即互联网通信协议第六版。由于互联网的蓬勃发展，IP地址的需求量越来越大，而IPv4模式下的IP总数有限，为了让地址能够继续分配，故出现了IPv6。采用**128位地址长度，分成8组（每组2字节，16位）**。一共有 $2^{128} = 3.04\\times10^{38}$ 种地址，这个数量，可以给地球上的每一粒沙子都编上号。一般用**冒分十六进制表示法**，例如：`2001:0DB8:0000:0023:0008:0800:200C:417A`。对于每一组，可以省略前导0，此时，对于上述IP地址，可以记录为：`2001:DB8:0:23:8:800:200C:417A`。此外，还有一种特殊情况：**0位压缩表示法**。即如果计算出的16进制表示形式中有多个连续的0，可以利用`::`进行压缩表示，例如对于`FF01:0:0:0:0:0:0:1101`，我们可以压缩为：`FF01::1101`。\n\n上述是对于IPv4和IPv6的基本介绍，现对IPv4进行额外补充。\n\nIPv4的地址分类形式有两种：一种是公网地址（万维网使用），一种是私有地址（局域网使用）。`192.168.`开头的就是私有地址，范围即为`192.168.0.0--192.168.255.255`，专门为组织机构内部使用，通过共享公网IP以此节省IP。\n\n一个特殊的IP地址为：`127.0.0.1`，又称localhost。是回送地址，也叫本地回环地址，又称本机IP。永远只会寻找当前所在的本机。换个地方上网，局域网IP可能不一样，因为这个是通过路由器分配的。通过localhost，可以保证自己给自己发送数据时不出错。\n\n### 端口号\n\n应用程序在设备中唯一的标识。**一个端口号只能被一个应用程序使用。**\n\n端口号是由两个字节表示的整数，取值范围：0-65535。其中0-1023之间的端口号是用于一些知名的网络服务或者应用。我们自己使用1024以上的端口号就可以了。\n\n### 协议\n\n计算机网络中，连接和通信的规则被称作网络通信协议。\n\nOSI参考模型：世界互联协议标准，全球通信规范，单模型过于理想化，未能在因特网上进行广泛推广。\n\nTCP / IP 参考模型：事实上的国际标准。\n\n#### UDP协议\n\n用户数据报协议（User Datagram Protocol），是**面向无连接**（不管两台计算机是否建立连接，直接传输数据）通信协议。速度快，有大小限制，一次最多发送64K，数据不安全，易丢失数据。应用场景：网络会议、语音通话、在线视频。（丢失数据的影响不大）\n\n#### TCP协议\n\n传输控制协议（Transmission Control Protocol），是**面向连接**的通信协议。速度慢，没有大小限制，数据安全。应用场景：下载软件、文字聊天、发送邮件。（丢失数据影响较大）","tags":["操作系统"],"categories":["小班"]},{"title":"操作系统作业1","url":"/2024/03/操作系统作业1/","content":"# 4\t\n\n## 4-1\n\n![image-20240316210403950](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240316210403950.png)\n\n可以看到，在每一个时刻，都保持cpu处于忙碌状态，因此cpu利用率位100%;\n\n使用-c指令查看发现符合预期。\n\n## 4-2\n\n![image-20240316210906963](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240316210906963.png)\n\n进程二为一个I/O操作，因此程序完成的时间与等待I/O完成的时间有关；\n\n若设这个时间位x，那么所需要的总时间就为进程0的执行时间加上I/O发起请求的时间加上I/O等待的时间再加上I/O执行完成的时间；\n\n即\n$$\n4+x+2=6+x\n$$\n如输入-c之后的表，表中I/O等待了4个时刻，因此耗费了11个时刻的时间，与预期相符。\n\n## 4-3\n\n![image-20240316211841117](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240316211841117.png)\n\n我们可以看到，当交换了程序运行时间后，实际上进行I/O操作时仍旧处于阻塞状态，但是不同的是，此时程序二由于cpu空闲而可以运行，这样子就大大提高了cpu利用率，有效缩短了时间，因此交换顺序是很重要的，这样可以大大提高cpu利用率和运行效率。\n\n使用-c指令可以发现答案正确。\n\n# 5\n\n## 5-1\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n\nint main(int argc,char *argv[])\n{\n\n        int x=100;\n        int rc=fork();\n\n        if(rc<0){\n                fprintf(stderr,\"fork failed\");\n                exit(1);\n        }else if(rc==0){\n                printf(\"child(pid:%d) (x:%d)\\n\",(int)getpid(),x);\n        \n        }else {\n                printf(\"parent of %d (pid:%d) (x:%d)\\n\",\n                                rc,(int)getpid(),x);\n          \t\t\tx=50;\n        }\n        return 0;\n\n}\n```\n\n在主进程访问x并将100设置为50时，子进程中的值仍为100，这说明子进程与父进程中的x值互不影响。\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n\nint main(int argc,char *argv[])\n{\n\n        int x=100;\n        int rc=fork();\n\n        if(rc<0){\n                fprintf(stderr,\"fork failed\");\n                exit(1);\n        }else if(rc==0){\n        \tx=50;\n                printf(\"child(pid:%d) (x:%d)\\n\",(int)getpid(),x);\n        \n        }else { \n        \tx=150;\n                printf(\"parent of %d (pid:%d) (x:%d)\\n\",\n                                rc,(int)getpid(),x);\n               \n        }\n        return 0;\n\n}\n```\n\n将父进程中的x设置为50再输出而子进程中的x设置为150输出，可以观察到：\n\n![image-20240316214932000](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240316214932000.png)\n\n因此这更加证明了父进程和子进程中的变量x并不互相影响。\n\n## 5-2\n\n```c\n#include<stdio.h>\n#include<unistd.h>\n#include<string.h>\n#include<fcntl.h>\n#include<stdlib.h>\n\nint main(int argc,char *argv[])\n{\n        int rc=fork();\n        int fd=open(\"./op-5-2-open.txt\",O_RDWR);\n\n        if(rc<0){\n                fprintf(stderr,\"fork failed\");\n                exit(1);\n        }else if(rc==0){\n                printf(\"child(fd:%d)\\n\",fd);\n                char str[]=\"child process\";\n                write(fd,str,sizeof(str));\n        \n        }else { \n                printf(\"parent (fd:%d)\\n\",fd);\n               \n                char str2[]=\"parent process\";\n                write(fd,str2,sizeof(str2));\n\n        }\n        close(fd);\n        return 0;\n\n}\n\n\n```\n\n当他们并发的写入同一个文件中时，可以看到子进程和父进程都可以正常的访问open()返回的文件描述符；打开txt文件后可以发现后运行的子进程覆盖了先运行的父进程，如下面第二张图所示：\n\n\n\n![image-20240316221640885](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240316221640885.png)\n\n![image-20240316221829401](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240316221829401.png)\n\n\n\n## 5-4\n\n```C\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n\nint main(){\n\tint rc=fork();\n\tif(rc<0){\n\t\tfprintf(stderr,\"fork failed!\\n\");\n\t}else if(rc==0){\n\t\tprintf(\"execl\\n\");\n\t\texecl(\"/bin/ls\",\"ls\",NULL);\n\t}else {\n\t\tint wc=wait(NULL);\n\t}\n\treturn 0;\n}\n```\n\n运行后输出结果如图所示：\n\n![image-20240317171813950](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240317171813950.png)\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n\nint main(){\n\tint rc=fork();\n\tif(rc<0){\n\t\tfprintf(stderr,\"fork failed!\\n\");\n\t}else if(rc==0){\n\t\tprintf(\"execl\\n\");\n\t\tconst char*arg;\n\t\tchar *const argv[]={\"ls\",\"-l\",NULL};\n\t\tcahr *const envp[]={\"\",\"\",NULL};\n\t\t\n\t\texecl(\"/bin/ls\",arg,NULL);\n    //\n    printf(\"execlp\\n\");\n\t\texeclp(\"ls\",arg,NULL);\n    //\n    printf(\"execle\\n\");\n\t\texecle(\"/bin/ls\",arg,NULL,envp);\n    //\n    printf(\"execv\\n\");\n\t\texecv(\"/bin/ls\",argv);\n    //\n    printf(\"ececvp\\n\");\n\t\texecvp(\"ls\",argv);\n    //\n    printf(\"ececvp\\n\");\n\t\texecvp(\"ls\",argv,envp);\n\t}else {\n\t\tint wc=wait(NULL);\n\t}\n\treturn 0;\n}\n```\n\n\n\n分别运行后可以看到如图所示的结果：\n\n![image-20240317173008027](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240317173008027.png)\n\n![image-20240317173034407](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240317173034407.png)\n\n![image-20240317173059810](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240317173059810.png)\n\n![image-20240317173127891](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240317173127891.png)\n\n![image-20240317173153763](C:\\Users\\南渡的南\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240317173153763.png)\n\n__为什么会有这么多的变种__，是因为多种exec()调用的参数传递方式和传递参数不同，这样子就可以更加灵活多样的使用exec()的功能，从而完成更加细致多样的操作来满足不同的需求。\n\n#\t7\n\n## 7-1\n\n由于三个任务时间相同且在同一时刻到达，因此他们两种方式的响应时间和周转时间分别相同。\n\n**其调度方式为:**\n\n| SJF/FIFO调度顺序 | A    | B    | B    |\n| ---------------- | ---- | ---- | ---- |\n| 运行长度         | 200  | 200  | 200  |\n\n其中每个单元格表示：**响应时间/周转时间**\n\n| 调度方式 | A     | B       | C       |\n| -------- | ----- | ------- | ------- |\n| FIFO     | 0/200 | 200/400 | 400/600 |\n| SJF      | 0/200 | 200/400 | 400/600 |\n\n**这两种调度方式的平均响应时间为:**\n$$\n（0+200+400）/3=200\n$$\n**这两种调度方式的平均周转时间为：**\n$$\n(200+400+600)/3=400\n$$\n\n\n## 7-2\n\n**其调度方式为:**\n\n| SJF/FIFO调度顺序 | A    | B    | B    |\n| ---------------- | ---- | ---- | ---- |\n| 运行长度         | 100  | 200  | 300  |\n\n其中每个单元格表示：**响应时间/周转时间**\n\n| 调度方式 | A     | B       | C       |\n| -------- | ----- | ------- | ------- |\n| FIFO     | 0/100 | 100/300 | 300/600 |\n| SJF      | 0/100 | 100/300 | 300/600 |\n\n**这两种调度方式的平均响应时间为:**\n$$\n（0+100+300）/3=133.33\n$$\n**这两种调度方式的平均周转时间为：**\n$$\n(100+300+600)/3=333.33\n$$\n\n\n## 7-3\n\n其中每个单元格表示：**响应时间/周转时间**\n\n| 调度方式 | A     | B     | C     |\n| -------- | ----- | ----- | ----- |\n| RR       | 0/598 | 1/599 | 2/600 |\n\n**这两种调度方式的平均响应时间为:**\n$$\n（0+1+2）/3=1\n$$\n**这两种调度方式的平均周转时间为：**\n$$\n(598+599+600)/3=599\n$$\n","tags":["操作系统"],"categories":["作业"]},{"title":"数据库系统第四章课后作业","url":"/2024/03/数据库作业2软件2204戴腾宇202226010418/","content":"## 第四章课后作业\n\n### 1.\n\n**某酒店集团公司在全国各城市开有酒店。每个酒店都有客房，客户可在网上先登录，然后预订，也可入店时现场预订。其住宿业务数据库中有如下4个表：**\n\n**Hotel(hotelNo, name, city, address, phone)**\n**Room(roomNo, hotelNo, type, price)**\n**Booking (hotelNo, roomNo, guestNo, dateFrom, dateTo)**\n**Guest(guestNo, password, name, city, email, phone, discount, creditNo)**\n**其中房间类型type字段的取值有单人间、双人间、商务间、豪华间。price是指住宿一天的房价。**\n**1)写出创建Room表和Booking表的SQL语句。**\n**2)创建一个视图，列出在2019-09-30这天，入住在编号为H0001的酒店的客人情况表，输出字段包括客人名字、房间号、房间类型、价格。**\n**3)创建一个存储过程，以起始日期、结束日期、酒店号为输入参数，求出所指的住宿期间，这个酒店可供预定的房间列表，包括房间号、类型、价格。按价格升序排列。**\n**4)有业务规则：不允许发生一个客户在两个不同的酒店有起始日期相同的预订。请创建一个触发器，表示该业务规则。**\n\n1)\n\n```mysql\nCREATE TABLE Room (\n\troomNo VARCHAR(10),//假设房间号为10个字符\n\thotelNo VARCHAR(10),//假设宾馆好为10个字符\n\ttype ENUM(‘单人间’，‘双人间’，‘三人间’)，//假设有这三种房间\n\tprice INT,\n\tPRIMARY KEY (roomNo,hotelNo),\n  FOREIGN KEY (hotelNo) REFERENCES Hotel(hotelNo)\n);\n\nCREATE TABLE Booking (\n  hotelNo VARCHAR(10),\n  roomNo VARCHAR(10),\n  guestNo int,\n  dateFrom DATE,\n  dateto DATE,\n  PRIMARY KEY (hotelNo,roomNo,guestNo,dateFrom,dateTo),\n  FOREIGN KEY (hotelNo) REFERENCES Hotel(hotelNo),\n  FOREIGN KEY (roomNo) REFERENCES Room(roomNo),\n  FOREIGN KEY (guestNo) REFERENCES Guest(guestNo)\n);\n```\n\n\n\n2)\n\n```sql\nCREATE VIEW view_h0001 AS\nSELECT g.name,b.roomNo,r.type,r.prcie \nFROM Booking b\nJOIN Guest g IN b.guestNo=g.guestNo\nJOIN Room r IN b.roomNo=r.roomNo AND b.hotelNo=r.hotelNo\nWHERE b.hotelNo='H0001'\nAND '2019-09-30' BETWEEN b.dateFrom AND b.dateTo;\n```\n\n\n\n3)\n\n```mysql\nCREATE PROCEDURE getGuestInfo(@gDateFrom in DATE,@gDateTo in DATE,@gHotelNo in VARCHAR)\nBEGIN \n\tSELECT r.roomNo,r.type,r.price\n\tFROM Room r\n\tWHERE @gHotelNo=r.hotelNo AND r.roomNo NOT IN(\n  \tSELECT b.roomNo\n    FROM Booking b\n    WHERE b.hotelNo=@gHotelNo AND NOT(\n    \tb.dateTo>@gDateFrom AND \n      b.dateStart<@gDateTo\n    )\n  )\n  ORDER BY r.price ASC\nEND;\n```\n\n\n\n4)\n\n```sql\nDELIMITER \nCREATE TRIGGER unableInsertBooking\nBEFORE INSERT ON Booking\nFOR EACH ROW\nBEGIN\n\tDECLARE sum INT;\n\tSELECT COUNT(*)\n\tINTO sum\n\tFROM Booking\n\tWHERE new.guestNo=b.guestNo\n\t\tAND new.dateFrom=b.dateFrom\n\t\tAND new.hotelNo<>b.hotelNo\n\tIF sum>0 THEN\n\t\tSIGNAL SQLSTATE '45000'\n\t\tSET MESSAGE_TEXT='Wrong operation!'\n\tEND IF\n END\n DELIMITER;\n```\n\n\n\n## 2.\n\n**数据库中的对象，例如表，其模式是存储在DBMS内部的表中。假设表对象的模式存储在DBMS内部的tableSchema表中，请写出tableSchema表的模式。并用SQL写出tableSchema表的模式的定义语句。注意：要存储表对象的模式，在DBMS内部光有tableSchema表还不够，还要有辅助表才行。基于严格按类分表存储原则，以及类与类之间有联系，还要求写出辅助表的定义。**\n\n**tableSchema表的模式定义**\n\nTableSchema 表可能包括表名、字段名、数据类型、是否可为空、主键、外键等信息。\n\n```sql\nCREATE TABLE tableSchema (\n  tableName VARCHAR(100),\n  columnName VARCHAR(100),\n  dataType VARCHAR(100),\n  isNullable BOOLEAN,\n  isPrimaryKey BOOLEAN,\n  isForeignKey BOOLEAN,\n  referenceTable VARCHAR(100),\n  referenceColumn VARCHAR(100),\n  /* 其它可能的字段 */\n  PRIMARY KEY (tableName, columnName)\n  /* 外键约束等 */\n);\n```\n\n**辅助表**\n\n辅助表可用来存储索引或者关系信息的表。\n\n```sql\nCREATE TABLE auxiliaryTable (\n  tableName VARCHAR(100),\n  constraintName VARCHAR(100),\n  constraintType VARCHAR(50),\n  /* 其它可能的辅助信息 */\n  PRIMARY KEY (tableName, constraintName)\n  /* 外键约束等 */\n);\n```\n\n","tags":["数据库系统"],"categories":["作业"]},{"title":"数据库系统第一、二章课后作业","url":"/2024/03/数据库作业一/","content":"##习题一\n\n1. 标识每个表的主键和外键：\n\n   - 学院表（Department）：主键是 `deptNo`。\n   - 学生表（Student）：主键是 `studentNo`。`deptNo` 是外键，引用了学院表（Department）的`deptNo`。\n   - 课程表（Course）：主键是 `courseNo`。`deptNo` 是外键，引用学院表（Department）的`deptNo`。\n   - 教师表（Teacher）：主键是 `teacherNo`。`deptNo` 是外键，引用学院表（Department）的`deptNo`。\n   - 教师开课表（Teach）：主键可能是 `courseNo`、`semester` 和 `classNo` 的组合。`courseNo` 是外键，引用课程表（Course）的`courseNo`；`teacherNo` 是外键，引用教师表（Teacher）的`teacherNo`。\n   - 学生选课表（Enroll）：主键是 `studentNo`、`courseNo`、`semester` 的组合。`studentNo` 是外键，引用学生表（Student）的`studentNo`；`courseNo` 是外键，引用教师开课表（Teach）的`courseNo`；`teacherNo`是外键，引用教师表`(Teacher)`中的主键。\n   - 教室表（Classroom）：主键是 `classroomNo`。\n   - 排课表（Dispatch）：主键是 `courseNo`、`semester`、`classNo`、`period`、`weekday` 的组合。`classroomNo` 是外键，引用教室表（Classroom）的`classroomNo`。\n\n2. 域约束：\n\n   - 课程表（Course）中的 `credit` 字段：域约束为数值类型，取值范围取决于学校的学分制度。\n   - 教师表（Teacher）中的 `rank` 字段：域约束为字符串类型,取值范围是预定义的职称集合，例如 {'助教', '讲师', '副教授', '教授'} 等。\n\n3. 使用关系代数生成以下用户所需业务数据：\n\n   (a)\n\n   ​\t\n   $$\n   \\Pi_{studentNo, name, birthday}(\\sigma_{sex = '女' \\land YEAR(birthday) = 2000}(Student))\n   $$\n   ​\t\n\n   (b)\n   $$\n   \\Pi_{Course.courseNo, Course.name, Enroll.semester, Course.credit, Enroll.score}(Enroll ⨝_{Enroll.courseNo=Course.courseNo \\land Enroll.studentNo='200843407'} Course)\n   $$\n   \n\n   (c)\n   $$\n   \\Pi_{Student.studentNo,Student.name,Student.sex}(\\sigma_{semester='2011-1' \\ landcourseNo='G61030009'}(Enroll) \\Join _{Enroll.student=Student.studentNo}Student)\n   $$\n   \n\n   ## 习题二\n\n   （1）\n\n   - Hotel表\n     - 主键: hotelNo\n     - 没有外键\n   - Room表\n     - 主键: (roomNo, hotelNo) 的联合主键\n     - 外键: hotelNo (关联到Hotel表的hotelNo)\n   - Booking表\n     - 主键: (hotelNo, roomNo, guestNo, dateFrom, dateTo) 的联合主键\n     - 外键: hotelNo (关联到Hotel表的hotelNo)，roomNo (关联到Room表的roomNo)，guestNo (关联到Guest表的guestNo)\n   - Guest表\n     - 主键: guestNo\n     - 没有外键\n\n   (2)\n\n   - 每个房间在任何时间段内只能被一位客户预订，不允许在相同日期范围内有重叠的预订。\n   - 客户在进行网络预订时必须使用有效的身份验证登陆信息，即客户的guestNo和password字段需要有效对应才能完成预订流程。\n\n   \n\n   (3)\n\n   ​\t(a)\n   $$\n   \\Pi_{Room.type, Hotel.name, Hotel.city}(\\sigma_{Room.price > 1500}(Room ⨝ Hotel))\n   $$\n   ​\t(b)\n   $$\n   \\Pi_{Hotel.name, Room.roomNo, Room.price}(\n       (σ_{Hotel.city = '长沙' AND Room.type = '单人间'}(Hotel ⨝ Room))\n       -\\\\\n       (σ_{Booking.dateFrom \\leq '2019-09-11' AND Booking.dateTo \\geq '2019-09-11'}(Booking))\n   )\n   $$\n   \n\n## \t习题三 \n\n1. ```SQL\n   SELECT h.name,r.type,COUTT(r.roomNo) AS room_num \n   From Hotel As h\n   JOIN Room r ON h.hotelNo=r.hotelNo\n   WHERE h.city='长沙'\n   GROUP BY h.name,r.type\n   ORDER BY h.name;\n   ```\n\n2. ```sql\n   SELECT g.name,b.roomNo\n   From Booking b\n   JOIN Hotel h ON b.hotelNo=h.hotelNo\n   JOIN GUEST g ON b.guestNo=g.guestNo\n   WHERE h.city='长沙' AND b.dateFrom<='2019-09-29' AND b.dateTo>='2019-09-29'\n   ORDER By g.name;\n   ```\n\n3. ```sql\n   SELECT h.name,r.roomNo,r.price\n   FROM Hotel h\n   JOIN Room r ON h.hotelNo=r.hotelNo\n   WHERE h.city='长沙' AND r.type='双人间' AND r.price<140\n   ORDER BY h.name,r.price;\n   ```\n\n4. ```sql\n   SELECT COUNT(DISTINCT b.name)\n   FROM Booking b\n   WHERE b.dateFrom>='2019-08-00' AND b.dateTo<='2019-08-31';\n   ```\n   \n5. ```sql\n   SELECT *\n   FROM Booking b\n   WHERE b.dateTo=NULL;\n   ```\n\n6. ```sql\n   SELECT COUNT(h.hotelNo)\n   FROM Hotel h;\n   ```\n\n7. ```sql\n   SELECT h.city AVG(r.price) AS avg_price\n   FROM Hotel h\n   JOIN Room r ON h.hotelNo=r.hotelNo\n   GROUP BY h.city;\n   ```\n\n8. ```sql\n   SELECT h.city,r.type,AVG(r.price) AS avg_price\n   FROM Hotel h\n   JOIN Room r ON h.hotelNo=r.hotelNo\n   GROUP BY h.city,r.type;\n   ```\n\n9. ```sql\n   SELECT h.city,h.name,b.roomNo,g.name,g.guestNo\n   FROM Booking b\n   JOIN Hotel h ON r.hotelNo=b.hotelNo\n   JOIN Guest g ON b.guestNo=b.guestNo\n   WHERE g.city='北京' AND b.dateFrom<='2019-09-29' AND b.dateTo>='2019-09-29';\n   ```\n\n10. ```sql\n   SELECT SUM(r.price) AS sum_income\n   FROM Room r\n   JOIN Hotel h ON h.hotelNo=r.hotelNo\n   WHERE h.city='长沙';\n   ```\n\n11. ```sql\n    SELECT SUM(r.price) AS sum_income\n    FROM Booking b\n    JOIN Hotel h ON b.hotelNo=h.hotelNO\n    JOIN Room r ON b.hotelNo=r.hotelNo\n    WHERE h.city='长沙' AND b.dateFrom<='2019-09-29' AND b.dateTo>='2019-09-29';\n    ```\n\n12. ``` sql\n    SELECT r.roomNo\n    FROM Room r\n    JOIN Hotel h ON h.hotelNo=r.hotelNo\n    WHERE h.city='长沙' AND r.roomNo NOT IN{\n    \t\tSELECT b.roomNo\n    \t\tFROM Booking b\n    \t\tWHERE b.dateFrom<='2019-09-29' AND b.dateTo>='2019-09-29'\n    };\n    ```\n\n13. ```sql\n    SELECT h.city,h.name,\n    \t\t\t(COUNT(DISTINCT b.roomNo)/COUNT(DISTINCT r.roomNO))*100\n    \t\t\tAS occupancyRate\n    FROM Hotel h\n    JOIN Room r ON r.hotelNo=h.hotelNo\n    JOIN Booking b ON r.hotel=b.hotelNo AND r.roomNo=b.roomNo\n    WHERE b.dateFrom<='2019-09-29' AND b.dateTo>='2019-09-29'\n    GROUP BY h.city,h.name;\n    ```\n\n14. ```sql\n    SELECT r.roomNo,r.price\n    FROM Room r\n    JOIN Hotel h ON h.hotelNo=r.hotelNo\n    WHERE r.type='双人间' AND h.city='长沙' AND r.roomNo NOT IN {\n    \t\t\tSELECT b.roomNo\n    \t\t\tFROM Booking b\n    \t\t\tWHERE b.dateFrom='2019-10-01' AND b.dateTo='2019-10-03'\n    };\n    ```\n\n15. ```sql\n    SELECT r.type\n    FROM Room r\n    JOIN Hotel h ON h.hotelNo=r.hotelNo\n    JOIN Booking b ON b.hotelNo=r.hotelNo AND b.roomNo=r.roomNo\n    WHERE h.city='长沙' AND '2019-09-29' BETWEEN b.dateFrom AND b.dateTo\n    GROUP BY r.type\n    ORDER BY COUNT(*) DESC\n    LIMIT 1;\n    ```\n\n16. ```sql\n    SELECT g.name,g.creditNo,g.city\n    FROM Guest g\n    JOIN Booking b ON b.guestNo=g.guestNo\n    WHERE b.dateFrom>='2019-08-01' AND b.dateTo<='2019-08-31'\n    GROUP g.name,g.creditNo,g.city\n    HAVING COUNT(b.guest)>5;\n    ```\n\n17. ```sql\n    INSERT INTO Hotel(hotelNo,name,city,address,phone) \n    \t\t\tVALUES ('001','天马大酒店'，'长沙'，'岳麓区'，'10086');\n    INSERT INTO Room(roomNo,hotelNo,type,price) \n    \t\t\tVALUES ('001','001'，'十人间'，'10086');\n    INSERT INTO Booking(hotelNo,roomNo,guestNo,dateFrom,dateTo) \n    \t\t\tVALUES ('001','001'，'001'，'2024-03-15'，'2024-03-16');\n    INSERT INTO Guest(guestNo,password,name,city,email,phone,discount,creditNo) \n    \t\t\tVALUES ('001','114514'，'张三'，'长沙'，'999@gmail.com','10086','0.01','3131313313131');\n    ```\n\n18. ```sql\n    UPDATE Room SET price=price*1.05;\n    ```\n\n19. ```sql\n    CREATE TABLE archival_booking like Booking;\n    INSERT INTO archival_booking \n    \t\t\tSELECT *\n    \t\t\tFROM Booking \n    \t\t\tWHERE b.dateFrom<='2019-01-01';\n    DELETE FROM Booking\n    \t\t\tWHERE dateFrom<='2019-01-01';\n    ```\n\n20. ```sql\n    UPDATE Guest SET Discount=Discount*0.9\n    WHERE guestNo{\n    \tSELECT guestNo\n    \tFrom Guest\n    \tWHERE dateFrom>='2019-01-01' AND dateTo<='2019-12-31'\n    \t\t\t\tGROUP BY guestNO\n    \t\t\t\tHAVING COUNT(*)>=12\n    };\n    ```\n\n21. ```sql\n    DELETE FROM Guest \n    \t\t\tWHERE g.guest NOT IN{\n    \t\t\tSELECT b.guestNo\n    \t\t\tFROM Booking b\n    \t\t\tWHERE b.dateFrom>='2017-01-01'\n    \t\t\t};\n    ```\n\n22. ```sql\n    SELECT g.name,g.creditNo,g.city\n    FROM guest g\n    \t\tWHERE NOT EXISTS(\n    \t\t\tSELECT h.hotelNO\n    \t\t\tFROM Hotel h\n    \t\t\tWHERE h.city='长沙'\n    \t\t\t\t\tAND NOT EXISTS(\n                    SELECT b.hotelNo\n                    FROM Booking b\n                    WHERE b.hotelNo=g.hotelNo \n                          AND b.guestNo=g.guestNo\n                          AND b.dateFrom BETWEEN '2019-01-01' AND '2019-12-31'\n    \t\t)\n    );\n    ```\n\n","tags":["数据库系统"],"categories":["作业"]},{"title":"数据库与身份验证","url":"/2024/03/数据库与身份验证/","content":"\n# 数据库与身份验证\n\n<p align=\"center\">\n  <br>\n  <h2 style=\"text-align:center;color:#F4E0EA\">\n    樱春雪\n\t</h2>\n  <br>\n  <br>\n\t<div style=\"text-align:center\">\n    <a href=\"https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master\">湖南大学</a>\n  | <a href=\"https://theme.typora.io/theme/Drake/\">软件工程</a>\n  | <a href=\"https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md\">2204</a>\n</div>\n<br>\n<br>\n<img style=\"clear:both;display:block;margin:auto;width:400px;height:100px\" src=\"计算机系统作业1.assets\\7HN)MKDR%[2BI2$@Q69A8$H.png\">\n  <br>\n</p>\n\n## 1.数据库的基本概念\n\n### 1.1什么是数据库\n\n> 数据库是用来组织、存储和管理数据的仓库\n\n### 1.2常见的数据库及其分类\n\n1. MySQL数据库(最广泛、流行度最高的开源免费数据库\n2. Oracle数据库\n3. SQL Server数据库\n4. Mongodb数据库\n\n## 2.安装并配置MySql相关的服务\n\n#### 2.1了解\n\n- MySql server :专门用来提供数据存储和服务的软件\n- MySQL Workbench :可视化的MySQL管理工具，通过它，可以方便的操作存储在MySQL Server中的数据\n\n#### 2.2&3.安装\n\n略\n\n## 3.MySQL的基本使用\n\n### 3.1使用mysql workbench管理数据库\n\n略\n\n#### 3.创建数据库\n\n#### 4.常见数据表\n\n> 1. PK主键，唯一标识\n> 2. NN，值不允许为空\n> 3. UQ，值唯一\n> 4. AI，值自动增长\n\n### 3.2使用SQL管理数据\n\n#### 1.什么是SQL\n\n> sql是一门结构化查询语言，专门用于访问和处理数据库的编程语言，能让我们以编程的形式，操作数据库里面的数据。\n\n**三个关键点：**\n\n- SQL是一门数据库编程语言\n- 使用SQL编写出来的代码，叫做SQL语句\n- SQL语言只能在==关系型数据库中使用==（例如Mysql，Oracle，SQL server)，非关系型数据库(如mongdb)不支持SQL语言。\n\n#### 2.SQL能够做什么\n\n从数据库中增删改查数据，创建新的数据库，创建表等等\n\n#### 3.SQL的学习目标\n\n如何对数据库进行增删改查\n\n---\n\nwhere、and和or、order by、count(*)函数\n\n### 3.3SQL语言\n\n## 4.在项目中操作MySql\n\n### 4.1在项目中操作数据库的步骤\n\n1. 安装专门的MySql数据库的第三方模块\n2. 通过mysql模块连接到MySql数据库\n3. 通过mysql模块执行SQL语句\n\n#### 1.安装mysql模块\n\n> mysql是一个托关于npm上的第三方某块\n\n语法:\n\n```js\nnpm i mysql//mysql2\n```\n\n#### 2.配置mysql模块\n\n在使用sql模块操作mysql数据库之前，必须先对MySQL进行必要的配置，主要配置步骤如下\n\n==这里推荐安装mysql2==,否则会因为加密不一样而出现错误\n\n```js\n//1.导入mysql模块\nconst mysql = require('mysql')\n\n//2.建立与mysql数据库的链接\nconst db = mysql.createPool({\n  host: 'localhost',//登录ip地址\n  user: 'root',//数据库账号\n  password: '615715',//数据库密码\n  database: 'test'//指定数据库\n})\n```\n\n#### 3.测试mysql模块能否正确工作\n\n通过db.query()函数，指定要执行的sql语句，通过回调函数拿到结果:\n\n**这里的SELECT 1没有任何实质性作用，仅用于测试**\n\n```js\n//判断mysql能否正确工作\ndb.query('SELECT 1', (err, res) => {\n  //如果出错了\n  if (err) return console.log(err.message)\n  console.log(res)\n})\n```\n\n### 4.2使用mysql操作mysql数据库\n\n#### 1.查询数据\n\n查询user中所有的数据\n\n如果执行的是SELECT，则执行的结果是以一个**数组**\n\n```JS\n//查询user中所有的数据\nconst sqlstr = `SELECT * FROM user`\ndb.query(sqlstr, (err, res) => {\n  if (err) return console.log(err.message)\n  console.log(res)\n})\n```\n\n![image-20240328215553883](数据库与身份验证.assets/image-20240328215553883.png)\n\n#### 2.插入数据\n\n向user中插入数据\n\nid为001，name为zz\n\n```js\n//向user中新增一条数据，user=‘001’ name='dn'\nconst user = { id: '001', username: 'dn' }\n\n//定义sql语句\nconst sqlStr = `insert into user (id,name) values(?,?)`\n\n//执行\ndb.query(sqlStr, [user.id, user.password], (err, res) => {\n  if (err) return console.log(err.message)\n  console.log()\n  //判断成功\n  //注意，如果执行的是insert，则res是一个对象，在这个对象中有affectRows这个属性来判断是否陈功\n  if (res.affectedRows === 1)\n    console.log('插入成功')\n})//填写两个占位符的值\n\n```\n\n**在这里面，有几个需要注意的：**\n\n>- 占位符?可以用于表示待插入的位置，在执行db.query时指定属性值进行填充\n>- 在返回的对象res中有一个属性affectRows，如果他的值为1，代表插入成功\n\n#### 3.插入数据的便捷操作\n\n当我们向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，可以通过如下方式：\n\n```js\nconst user = { id:10,name:'zz'}\nconst sqlStr = `insert into user set ?`\n//执行\ndb.query(sqlStr, user, (err, res) => {\n  if (err) return console.log(err.message)\n  console.log()\n  //判断成功\n  //注意，如果执行的是insert，则res是一个对象，在这个对象中有affectRows这个属性来判断是否陈功\n  if (res.affectedRows === 1)\n    console.log('插入成功')\n})//填写两个占位符的值\n```\n\n#### 4.更新数据\n\n通过如下方式\n\n```js\nconst user = { id:10,name:'zz'}\nconst sqlStr = `insert into user set ?`\n//执行\ndb.query(sqlStr, user, (err, res) => {\n  if (err) return console.log(err.message)\n  console.log()\n  //判断成功\n  //注意，如果执行的是insert，则res是一个对象，在这个对象中有affectRows这个属性来判断是否陈功\n  if (res.affectedRows === 1)\n    console.log('插入成功')\n})//填写两个占位符的值\n```\n\n#### 5.更新数据的便捷方式\n\n如果数据对象的每一个属性都和数据表的字段一一对应，则可以通过如下方式来快速更新表数据:\n\n```js\n//更新数据的便捷方式\nconst user = { id:10,user:'无敌逆神',password:'1234567'}\nconst sqlStr = `update user set ? where id=?`\n\n//执行\ndb.query(sqlStr, [user,user.id], (err, res) => {\n  if (err) return console.log(err.message)\n    if (res.affectedRows === 1)\n      console.log('更新成功')\n})\n```\n\n==注意，在提供数据的时候还要加一个额外的参数**user.id**==\n\n#### 6.删除数据\n\n**删除数据时，推荐使用id来，因为它具有唯一标识**\n\n```js\n//删除id为5的数据\nconst sqlStr = 'delete from user where id=?'\n\ndb.query(sqlStr, 5, (err, res) => {\n  if (err) return console.log(err.message)\n  //删除结果执行后，也会生成一个结果对象，其中也包含affectedRows这个属性\n    if (res.affectedRows === 1)\n      console.log('删除成功')\n})\n```\n\n#### 7.标记删除\n\n使用delete时，会真正的将数据从表中删除掉，推荐使用标记**删除**的方式，来**模拟删除**的动作\n\n>所谓的标记删除时，就是在表中设置类似于status这样的状态字段，来标记这条数据是否被删除\n>\n>当用户执行了删除的动作后，并不与执行delete语句将其删除掉，而是执行了**UPDATE**语句，将status更新为删除\n\n```js\nconst sqlStr = 'update user set status=? where id=?'\n\ndb.query(sqlStr, [1, 6], (err, res) => {\n    if (err) return console.log(err.message)\n  //删除结果执行后，也会生成一个结果对象，其中也包含affectedRows这个属性\n    if (res.affectedRows === 1)\n      console.log('删除成功')\n})\n```\n\n## 5.前后端身份认证\n\n### 5.1Web开发模式\n\n#### 1.服务器渲染的Web开发模式\n\n> 服务器渲染的概念：服务器发送给客户端的HTML页面，是在服务器通过字符串的拼接动态生成的，因此，客户端不需要Ajax这样的技术请求额外的数据\n\n#### 2.服务器渲染Web开发模式的优缺点\n\n==优点==\n\n> 前端耗时少，因此服务器负责动态生成HTML内容，浏览器只需要渲染页面即可\n>\n> 有利于SEO，因为服务器端响应的时完整的HTML内容，所以爬虫更容易获取信息，有利于SEO\n\n-----\n\n==缺点==\n\n>占用服务器端资源，即服务器端完成HTML内容页面的拼接，如果请求比较多，会对服务器造成一定的压力\n>\n>不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行合作分工，尤其对于前端复杂度给高的项目，不利于项目高效开发\n\n#### 3.前后端分离的Web开发模式\n\n> 前后端分离的概念：前后端分离的开发模式，依赖于Ajax技术的广泛使用，简而言之，前后端分离的Web开发模式就是后端只负责提供API接口，前端使用Ajax调用接口的开发模式\n\n#### 4.前后端分离的优缺点\n\n==优点==\n\n> 开发体验好：前端专注于UI页面开发，后端专注于api的开发，且前端有更多的选择性\n>\n> 用户体验好：Ajax的广泛应用，极大的提高了用户的体验，可以轻松实现页面的同步刷新\n>\n> 减轻了服务器端的渲染压力\n\n==缺点==\n\n> 不利于SEO，不利于爬虫的爬取\n\n#### 5.如何选择开发模式\n\n==不谈业务场景选使用都是耍流氓==\n\n![image-20240329211010552](数据库与身份验证.assets/image-20240329211010552.png)\n\n### 5.2什么是身份认证\n\n#### 1.什么是身份认证\n\n> 身份认证又称“身份验证”，“鉴权”，是指通过一定的手段，完成对用户的身份确认\n\n#### 2.为什么需要身份验证\n\n> 身份验证的目的，是为了确认**当前用户所声称某种身份的用户确实是某种用户\n\n#### 3.不同开发模式下的身份验证\n\n**服务器渲染推荐使用Session认证机制**\n\n**前后端分离推荐使用JWT认证机制**\n\n### 5.3Session认证机制\n\n#### 1.HTTP协议的无状态性\n\n> HTTP协议的无状态性，指的是客户端每次HTTP请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态\n\n![image-20240329212001957](数据库与身份验证.assets/image-20240329212001957.png)\n\n#### 2.如何突破HTTP无状态的限制\n\n![image-20240329212149180](数据库与身份验证.assets/image-20240329212149180.png)\n\n\n\n==现实生活中的会员卡身份认证方式，就叫做Cookie==\n\n#### 3.什么是Cookie\n\n> Cookie就是存储在浏览器中的一段键值对，他的大小不超过4kb，它由一个值(value)和一个键值(key)和其他几个用于控制Cookie有效期，安全性，适用范围的可选属性组成\n>\n> 不同域名下的Cookie各自独立，每当客户端发起请求时，会自动把当前域名下的所有未过期的Cookie一起发送给服务器\n\n==四大特性==\n\n1. 自动发送\n2. 域名独立\n3. 过期时限\n4. 4kb限制\n\n#### 4.Cookie在身份验证的作用\n\n> 客户端第一次请求服务器的时候，服务器会通过响应头的方式，向客户端发送一个身份验证的Cookie，客户端会自动将COOKIE保存在浏览器中\n>\n> 随后当客户端浏览器每次请求服务器的时候，浏览器都会自动将身份认证相关的Cookie，通过请求头的方式发送给服务器，服务器即可验明客户端的身份\n\n\n\n![image-20240329213207760](数据库与身份验证.assets/image-20240329213207760.png)\n\n#### 5.Cookie的安全性\n\n==COOKIE不具有安全性==\n\n> 由于Cookie是存储在浏览器中的，而且浏览器也提供了读写Cookie的API，也难辞Cookie也很容易被伪造，不具有安全性\n\n\n\n![image-20240329213612017](数据库与身份验证.assets/image-20240329213612017.png)\n\n\n\n**所以千万不要使用Cookie来存储用户隐私且敏感的数据**\n\n#### 6.提高身份认证的安全性\n\n![image-20240329213730371](数据库与身份验证.assets/image-20240329213730371.png)\n\n\n\n**这种会员卡+刷卡认证的设计理念，就是Session认证机制的精髓**\n\n在服务器会验证这个Cookie是否真正存在\n\n#### 7.Session的工作原理\n\n![image-20240329213923164](数据库与身份验证.assets/image-20240329213923164.png)\n\n### 5.4在Express中使用Session认证\n\n#### 1.安装express-session认证\n\n<npm i express-session>\n\n#### 2.配置\n\n安装成功后，需要通过app.use()来注册session中间件，\n\n```js\n//TODO：配置Session中间件\nconst session = require('express-session')\napp.use(\n  session({\n    secret: 'ycx',\n    resave: false,\n    saveUninitialized:true\n  })\n)\n```\n\n#### 3.如何向session中存入数据\n\n配置成功后，就可以通过req.session来访问和配置session对象，从而存储用户关键信息\n\n==只有配置成功后，才能通过req.出来session这个属性==\n\n```js\n  if (req.body.username != 'admin' || req.body.password != '000000') {\n    return res.send({ stats: 1, msg: '登陆失败' })\n  }\n  //TODO2:将登陆成功后的用户信息，保存在Session中\n  //只有配置成功后，才能通过req.出来session这个属性\n  req.session.user = req.body//用户信息\n  req.session.islogin = true//登陆状态\n  \n  res.send({ status: 0, ms: '登录成功' })\n```\n\n#### 4.从session中取数据\n\n可以直接从req.session中取数据\n\n```js\n //TODO3从session中获取用户名称，响应给客户端\n  if (!req.session.islogin) {\n    return res.send({status:1,msg:'fail'})\n  }\n  res.send({\n    status: 0,\n    msg: 'success',\n    username: 'req.session.user.username'\n  })\n```\n\n#### 5.清空session\n\n使用req.session.destroy()函数，==只会清空当前用户服务器保存的session==\n\n```js\n//退出登录的接口\napp.post('/api/logout', (req, res) => {\n  req.session.destroy()\n  res.send({\n    status: 0,\n    msg:'退出登录成功'\n  })\n})\n```\n\n### 5.5JWT认证机制\n\n#### 1.了解session的缺点\n\n> session认证机制需要配合Cookie才能实现，由于Cookie默认不支持跨域访问，所以当涉及到前端跨域请求后端接口时，需要很多额外的配置，\n>\n> 前后端需要跨域问题时，推荐session\n>\n> 不需要时，推荐jwt\n\n#### 2.什么是JWT\n\nJWT是目前最流行的跨域认证解决方案\n\n#### 3.JWT工作原理\n\n#### ![image-20240402201227994](数据库与身份验证.assets/image-20240402201227994.png)\n\n> 用户的信息通过Token字符串的方式，保存在客户端浏览器中，服务器通过还原Token字符串的形式来验证用户的身份。\n\n#### 4.JWT字符串组成\n\nJWT通常由三部分组成\n\n> Header、Payload(有效荷载)、Signature(签名)\n\n三者之间使用\".\"分隔\n\n#### 5.JWT三个部分的代表含义\n\n==Header====Signature==\n\n> 是安全性相关的部分，只是为了保证Token的安全性\n\n==Payload==\n\n> 是真正的用户信息，他是用户信息经过加密之后生成的字符串\n\n![image-20240402220156590](数据库与身份验证.assets/image-20240402220156590.png)\n\n#### 6.JWT的使用方式\n\n客户端收到服务器返回的JWT之后，将他存储在\n\n**localStorage或者sessionStorage**之中\n\n此后，客户端每次与服务器端通信，都要带上这个JWT字符串，从而进行身份验证。\n\n**推荐的做法：**\n\n> 将JWT放在HTTP请求头的Authorization字段中\n\n**其格式为：**\n\n```js\nAuthorization: Bearer <token>\n```\n\n### 5.6在Express中使用JWT\n\n#### 1.安装JWT相关包\n\n```js\nnpm install jsonwebtoken express-jwt\n```\n\n**其中**\n\n-  jsonwebtoken用于生成JWT字符串\n- express-jwt用于将JWT字符串解析还原成JSON对象\n\n#### 2.导入相关包\n\n使用require()函数\n\n```js\n// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt\nconst jsonwebtoken = require('jsonwebtoken')\nconst expressJwt = require('express-jwt')\n```\n\n#### 3.定义Secret密钥\n\n> 为了保证JWT字符串安全性，防止\n","tags":["nodejs","npm","身份验证","数据库"],"categories":["数据库"]},{"title":"数据库系统第三章课后作业","url":"/2024/03/数据库作业三/","content":"#  数据库作业三\n\n## 习题一\n\n大学教务管理数据库中，操作系统(courseNo为H61030008)是一门专业核心课，请为2019级软件工程专业（专业编号为‘24）的每个学生，向选课表enroll（studentNo, courseNo,semester,score)中添加一行选修该课的记录。将这个操作定义为一个事务。学号的样式为yyyyddssccnm.其中yyyy表示是哪一年级，dd表示所属学院的编号，ss表示专业编号。\n\n\n\n```sql\nTRANSACTION BEGIN\n\nINSERT INTO Enroll (studentNo,courseNo,semester,score) \nVALUES(\n\t(SELECT studentNo,FROM student WHERE studentNo LIKE '2019__24%'),\n  'H61030008',\n\t(SELECT semester FROM course WHERE courseNo='H6103008'),\n   60//这个数据貌似只有选课表中有，插入数值应该更具实际情况而定\n)\n  \nEND\nCOMMIT;\n```\n\n\n\n## 习题二\n\n在图6-7所示的事务执行框架中，从其开始执行，直至执行logCommit()之前，其前面的数更新日志已写入了日志磁盘，有可能吗?在这期间，那些已写人日志磁盘的日志记录，能从日志缓存区删除吗?请说明理由。logCommit()不只是给日志缓存区添加一条<t_id，COMMIT日志记录，还要等待，直至其所有日志记录被写入日志磁盘为止。为什么?对于logAbort()它只是给日志缓存区添加一条<tid，ABORT>日志记录，但并不需要等待。为什么?当一个事务被放弃，其所有日志记录还需要写入日志磁盘吗?请说明理由。\n\n1. 在提交之前，不一定会将所有的日志全部都写入磁盘，但这些日志一定会在适当的时候异步写入磁盘；在执行logCommit()时，必须将之前的所有日志全部写入磁盘，这样才能在发生崩溃之后完整的执行回滚。\n2. 可能，但这通常由数据库系统管理，可能涉及缓存替换策略和数据库的持久化策略。\n3. 这是为了崩溃后能够完整的执行回滚操作，因为只有等待所有的日志记录全都被写入后，才能保证回滚时能够执行每一步操作。\n4. 一个事务被中止时，他的变更不需要保存到数据库，因此也不需要等待前面的日志全部写入。\n5. 也需要，因为如果系统在回滚时发生崩溃，这些日志将用于再次恢复和回滚，以保证数据库的一致性。","tags":["数据库系统"],"categories":["作业"]},{"title":"计算机系统第四章课后作业","url":"/2024/03/计算机系统作业1/","content":"### 2.61 \n\n![image-20240324110351074](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A1.assets/image-20240324110351074.png)\n\n```C\n#include\"stdio.h\"\n#include\"stdlib.h\"\n\nint judge(int x){\n    return ((x+1)||x||(!(x>>24)+1)||(!(x&0xff)));\n}\nint main(){\n  int x;\n  scanf(\"%d\", &x);\n  printf(\"%d\", judge(x));\n  return 0;\n}\n```\n\n### 2.71\n\n![image-20240324112741611](计算机系统作业1.assets/image-20240324112741611.png)\n\n![image-20240324112902304](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A1.assets/image-20240324112902304.png)\n\n```c\n#include\"stdio.h\"\n#include\"stdlib.h\"\n\ntypedef unsigned packed_t; \n\nint xbyte(packed_t word, int bytenum) \n{ \n   return ((int)(word<<((3-bytenum)<<3)))>>24;\n}\nint main(){\n  int x,num;-\n  scanf(\"%d %d\", &x,&num);\n  printf(\"0x%hx\", xbyte(x,num));\n  return 0;\n}\n```\n\n### 2.87\n\n![image-20240324142831618](计算机系统作业1.assets/image-20240324142831618.png)\n\n![image-20240324142847715](计算机系统作业1.assets/image-20240324142847715.png)\n\n| 格式A       | 格式A   | 格式B       | 格式B   |\n| ----------- | ------- | ----------- | ------- |\n| 位          | 值      | 位          | 值      |\n| 1 01110 001 | -9/16   | 1 0110 0010 | -9/16   |\n| 0 10110 101 | 208     | 0 1110 1010 | 208     |\n| 1 00111 110 | -7/1024 | 1 0000 0111 | -7/1024 |\n| 0 00000 101 | 5/2^17  | 0 0000 0001 | 1/1024  |\n| 1 11011 000 | -2^12   | 1 1110 1111 | -248    |\n| 0 11000 100 | 768     | 0 1111 0000 | +∞      |\n\n### 2.88\n\n![image-20240324152512538](计算机系统作业1.assets/image-20240324152512538.png)\n\n\n\n**A:**正确，int转float，double转float有可能小数部分损失，但两者仍然相等\n\n**B:**错误，当x、y其中一者为INT_MAX，其他一个为整数时，会导致int溢出，导致两者不相等\n\n**C:**正确，改变运算顺序并不影响浮点数相加运算\n\n**D:**正确，改变运算顺序并不影响浮点数相乘运算\n\n**E:**错误，当dx=0，dy=1或者dx=1，dy=0时，会导致除法表达式不成立从而不总是为0。","tags":["计算机系统"],"categories":["作业"]},{"title":"Express","url":"/2019/11/Express使用/","content":"# Express\n\n<p align=\"center\">\n  <br>\n  <h2 style=\"text-align:center;color:#F4E0EA\">\n    樱春雪\n  </h2>\n  <br>\n  <br>\n  <div style=\"text-align:center\">\n    <a href=\"https://codeload.github.com/liangjingkanji/DrakeTyporaTheme/zip/refs/heads/master\">湖南大学</a>\n  | <a href=\"https://theme.typora.io/theme/Drake/\">软件工程</a>\n  | <a href=\"https://github.com/liangjingkanji/DrakeTyporaTheme/blob/master/issues.md\">2204</a>\n</div>\n<br>\n<br>\n<img style=\"clear:both;display:block;margin:auto;width:400px;height:100px\" src=\"计算机系统作业1.assets\\7HN)MKDR%[2BI2$@Q69A8$H.png\">\n  <br>\n</p>\n\n\n\n## 1.初识Express\n\n### 1.1Express简介\n\n#### 1.什么是Express\n\n>Express是基于Node.js平台，快速、开放、极简的Web开发框架\n\n#### 2.进一步理解\t\t\t\t\t\t\n\nhttp内部模块使用很复杂，开发效率低；EXpress是基于http封装出来的。\n\n#### 3.Express能做什么\n\n两种服务器\n\n>Web网站服务器：专门提供Web网页的服务器\n>\n>API接口服务器：专门提供API接口的服务器\n\n**使用Express，可以方便快捷的创建两种服务器**\n\n### 1.2Express的基本使用\n\n#### 1.安装\n\n```npm\nnpm i express@4.17.1\n```\n\n#### 2.创建最基本Web服务器\n\n```js\n//1.导入\nconst express=require('express')\n//2.创建\nconst app=express()\n//3.启动Web服务器\napp.listen(80, () => {\n  console.log('express server running at localhost')\n})\n```\n\n#### 3.监听GET请求\n\n通过app.get()方法，可以监听\n\n具体语法格式如下\n\n```js\napp.get('请求url',function(req,res){//req 请求对象 res 响应对象\n  /**待处理函数**/\n})\n```\n\n#### 4.监听POST请求\n\n通过app.post()方法\n\n具体格式如下\n\n```js\napp.post('请求url',function(req,res){//req 请求对象 res 响应对象\n  /**待处理函数**/\n})\n```\n\n#### 5.把内容响应给客户端\n\n通过res.send()方法，可以把处理好的内容，发送给客户端\n\n这个方法既可以发送JSON字符串，也可以发送文本\n\n```js\napp.get('/user', (req, res) => {\n  //调用express提供的send方法相应一个对象\n  res.send({name:'zs',age:20,gender:'男'})\n})\n```\n\n```js\napp.post('/user', (req, res) => {\n  res.send('请求成功!')\n})\n```\n\n#### 6.获取URL中携带的查询参数\n\n通过req.query对象，可以访问客户端通过查询字符穿的方式\n\n```js\napp.get('/', (req, res) => {\n  //默认是空对象\n  console.log(req.query)\n  res.send(req.query)\n})\n```\n\n#### 7.获取url中的动态参数\n\n通过==req.params==对象，可以访问到URL中，通过==：==匹配到的动态参数\n\n```js\napp.get('/user/:id', (req, res) => {\n  console.log(req.params)\n  res.send(req.params)\n})\n```\n\n![image-20240325211442354](Express使用.assets/image-20240325211442354.png)\n\n也可以匹配两个至多个动态参数例如 `/:id/:name`，返回一个对象\n\n### 1.3托管动态资源\n\n#### 1.express.static()\n\nexpress提供了该函数，叫做express.static(),可以方便快捷的创建一个静态资源服务器\n\n例如，通过以下代码就可以将public目录下的图片、CSS文件、Js文件对外开放访问了\n\n```js\napp.use(express.static('public'))\n```\n\n现在就可以访问public下所有问价了\n\n==注意==\n\n> Express在指定的静态目录中查找文件，存放文件的路径名不会出现在路径名中\n\n![image-20240325212444542](Express使用.assets/image-20240325212444542.png)\n\n打开成功\n\n#### 2.托管多个静态资源目录\n\n可以多次调用express.statci()函数\n\n> 访问静态资源时候，会按照顺序依次访问资源。\n\n#### 3.挂载路径前缀\n\n需要在托管的资源访问路径之前，挂载路径前缀\n\n```js\napp.use('/public',express.static('public'))\n```\n\n### 1.4nodemon\n\n#### 1.为什么要使用\n\n> 在编写Node.js项目的时候，如果修改了项目代码，需要频繁close掉，然后重新启动 \n>\n> 使用nodemon之后，它可以监听项目文件的变动，当代码被修改之后，nodemon会帮助重启项目\n\n#### 2.安装\n\n```npm\nnpm install -g nodemon\n```\n\n## 2.Express路由\n\n### 2.1介绍\n\n### 2.2路由的使用\n\n#### 1.最简单的路由\n\n在Express中，最简单的路由的使用方式，就是把路由挂载到app上\n\n```js\n//来get\napp.get('/', (req, res) => {\n  res.send('hello world')\n})\n\n//来post\napp.post('/', (req, res) => {\n  res.send('Post ing')\n})\n```\n\n#### 2.模块化路由\n\n方便对路由进行模块化管理，不建议将路由直接挂载到app上，而是推荐==将路由抽离为单独的模块==\n\n将路由抽离为单独模块步骤\n\n>1. 创建路由.js文件\n>2. 调用express.static()方法创建路由对象\n>3. 向路由对象上挂载具体的路由\n>4. 室友moudule.exports向外共享路由对象\n>5. 使用app.use函数注册路由模块\n\n#### 3.创建路由.js文件\n\n```js\nconst express = require('express')\n//创建路由对象\nconst router = express.Router()\n//挂载具体的路由\nrouter.get('/user/list', (req, res) => {\n  res.send('Get user list.')\n})\n\nrouter.post('user/add', (req, res) => {\n  res.send('Add new user successfully')\n})\n//向外导出\nmodule.exports=router\n```\n\n#### 4.如何注册路由模块\n\n```JS\n//1.导入路由模块\nconst router=require('./router')\n//2.注册\napp.use(router)\n\n```\n\n**app.use()的作用就是用于注册全局的中间件**\n\n#### 5.为路由模块添加前缀\n\n类似于为静态资源统一挂载前缀\n\n```JS\napp.use('api',router)\n```\n\n## 3.Express中间件\n\n### 3.1中间件概念\n\n#### 1.2.概念等等\n\n略\n\n#### 3.Express中间件的调用流程\n\n当一个请求到达Express的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理\n\n![image-20240326163045849](Express使用.assets/image-20240326163045849.png)\n\n#### 4.Express中间件的格式\n\n中间件的本质就是一个function函数，其格式如下\n\n![image-20240326163143550](Express使用.assets/image-20240326163143550.png)\n\n**中间间函数形参列表中，必须包含一个next形参，而路由处理函数中只有req、res**\n\n==next形参必须放到最后一个==\n\n#### 5.next函数的作用\n\n==next 函数是实现多个中间件连续调用的关键==，他表示把流转关系转交给下一个中间件或路由\n\n![image-20240326163407998](Express使用.assets/image-20240326163407998.png)\n\n### 3.2定义中间件函数\n\n#### 1.定义\n\n可以通过如下方式\n\n```js\nconst express = require('express')\nconst app = express()\n\n//定义一个最简单的中间件函数\nconst mw = (req,res,next) => {\n  console.log('最简单的中间件函数')\n  //把流转关系交给下一个中间件或者函数\n  next()\n}\napp.listen(80, () => {\n  console.log('Running')\n})\n```\n\n#### 2.全局生效的中间件\n\n客户端发起的**任何请求**，到达服务器之后，都会触发的中间件，成为==全局生效的中间件==\n\n通过调用**app.use(中间件函数)**，即可定义一个全局生效的中间件，\n\n```js\napp.use(mw)\n```\n\n![image-20240326164327361](Express使用.assets/image-20240326164327361.png)\n\n#### 3.定义全局中间件的简化形式\n\n```js\napp.use((req, res, next) => {\n  console.log('This is the app')\n})\n```\n\n#### 4.中间件的作用\n\n> 多个中间件之间，可以共享**req和res**，基于这样的特性，我么可以在上游的中间件中，**统一为**req或者res添加自定义属性或者方法，**供下游**中间件或者路由使用\n\n![image-20240326164904111](Express使用.assets/image-20240326164904111.png)`\n\n现在需要在每一个需求都获取时间\n\n```JS\napp.get('/', (req, res) => {\n  const time=Date.now()\n  res.send('Home page')\n  console.log('This is get')\n})\napp.post('/user', (req, res) => {\n  const time=Date.now()\n  res.send('User')\n})\n```\n\n在中间件函数中添加自定义属性\n\n```js\napp.use((req, res, next) => {\n  //为req对象，添加自定义属性\n  const time = Date.now()\n  //添加自定义属性\n  req.startTime=time\n  console.log('This is the app')\n})\n```\n\n#### 5.定义多个全局中间件\n\n可以使用app.use连续定义多个全局中间件，客户端请求到达服务器之后，会按照前后顺序执行\n\n```js\n//第一个\napp.use((req, res, next) => {\n  console.log('第一个')\n  next()\n})\n//第二个\napp.use((req, res, next) => {\n  console.log('第二个')\n  next()\n})\n//路由\napp.get('/user', (req, res) => {\n  res.send('User page')\n})\n```\n\n![image-20240326165934807](Express使用.assets/image-20240326165934807.png)\n\n#### 6.局部生效的中间件\n\n> 不使用app.use()定义的中间件，叫做局部生效的中间件\n\n```js\nconst mwl = (req, res, next) => {\n  console.log('局部生效')\n  next()\n}\napp.get('/', (req, res) => {\n  res.send('Home page')\n})\napp.post('/user', (req, res) => {\n  res.send('User page')\n})\n```\n\n这里面只有第一个路由才能被正确设置\t\n\n#### 7.连续定义多个局部中间件\n\n可以如下定义，顺序从前到后:\n\n```js\n//1.定义中间件函数\nconst mwl1 = (req, res, next) => {\n  console.log('局部生效1')\n  next()\n}\nconst mwl2 = (req, res, next) => {\n  console.log('局部生效2')\n  next()\n}\napp.get('/',mwl1,mwl2,(req, res) => {//('/',[mwl1,mwl2],(req,res))\n  res.send('Home page')\n})\n```\n\n#### 8.中间件五个使用注意事项\n\n>1. 一定要在路由之前注册中间件\n>2. 客户但发送的请求可以连续调用多个中间件函数\n>3. 执行完中间件业务代码后，一定要使用next()\n>4. 在调用next()后，不用再写其他业务代码了，防止代码逻辑混乱\n>5. 连续调用多个中间件，多个中间件之间是共享(req,res)对象的\n\n### 3.3中间件分类\n\n==常用的中间件分类==\n\n> 1. 应用级别\n> 2. 路由级别\n> 3. 错误级别\n> 4. Express内置\n> 5. 第三方\n\n#### 1.应用级别\n\n> 通过app.use()/app.get()/app.post(),绑定到app实例上的中间件\n\n#### 2.路由级别\n\n> 绑定到express.Router()实例上的，叫做路由级别中间件\n>\n> > **差别**\n> >\n> > 应用级别中间件是绑定到app上，路由级别绑定到Router上\n\n#### 3.错误级别\n\n**作用：**专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题\n\n**格式：**错误级别中渐渐暗function()处理函数中，必须有四个形参，形参顺序从前到后\n\n```js\n（err,req,res,next)\n```\n\n```js\napp.get('/', (req, res) => {\n  throw new Error('Error occured')\n  //1.1人为制造错误\n  res.send('Home page')\n})\n\n```\n\n![image-20240326172657669](Express使用.assets/image-20240326172657669.png)\n\n**使用错误级别中间件**\n\n```js\napp.get('/', (req, res) => {\n  throw new Error('Error occured')\n  //1.1人为制造错误\n  res.send('Home page')\n})\n//定义错误级别中间件，防止崩溃\napp.use((err,req,res,next) => {\n  console.log('发生了错误' + err.message)\n  res.send('Error' + err.message)\n  next()\n})\n\n```\n\n\n\n![image-20240326172936210](Express使用.assets/image-20240326172936210.png)\n\n**程序没有崩溃**\n\n> 注意如果将中间件和路由调换顺序，还是会报错\n\n#### 4.Express内置中间件\n\nExpress再4.16.0之后有三个常用中间件，\n\n> express.static()快速托管静态资源的内置中间件，\n>\n> express.json()解析JSON格式的请求体数据(有兼容性，再4.16.0及之后)\n>\n> express.urlencoded()解析URL-encoded格式的请求日数据(有兼容性)\n\n```js\napp.use(express.json)//配置解析application/json格式化数据\napp.use(express.urlencoded({extended:false}))//配置解析application/x-www-form-urlencoded格式数据的中间件\n```\n\n==express.json()使用==\n\n```js\napp.post('/user', (req, res) => {\n  //再服务器，可以使用req.body属性来接受来自客户端的请求体数据\n  console.log(req.body)\n  //默认情况下，如果不配置解析表单数据的中间件，则req.body默认等于Undefined\n  res.send('ok')\n})\n```\n\n输出Undefined\n\n**注意，除了错误级别中间件，其他中间件必须在路由之前进行配置**\n\n```js\n//通过express.json这个中间件解析\napp.use(express.json())\napp.post('/user', (req, res) => {\n  //再服务器，可以使用req.body属性来接受来自客户端的请求体数据\n  console.log(req.body)\n  //默认情况下，如果不配置解析表单数据的中间件，则req.body默认等于Undefined\n  res.send('ok')\n})\n```\n\n成功输出json字符串\n\n![image-20240326174434765](Express使用.assets/image-20240326174434765.png)\n\n==express.urlencoded()==\n\n```js\napp.post('/book', (req, res) => {\n  console.log(req.body)\n  res.send('ok')\n})\n```\n\n![image-20240326174712500](Express使用.assets/image-20240326174712500.png)\n\n解析不了，得到空对象\n\n```js\n//通过express.urlencoded()中间件来解析表单中的urlencoded\napp.use(express.urlencoded({ extended: false }))\n```\n\n![image-20240326174852564](Express使用.assets/image-20240326174852564.png)\n\n**解析成功！**\n\n#### 5.第三方中间件\n\n> 非express官方的，由第三方出来的中间件，叫做第三方中间件\n\n**步骤**\n\n例如安装 body-parser\n\n1. npm i body-parser\n2. const parser=require('body-parser')\n3. app.use(parser.urlencoded({ extended: false }))\n\n**express中内置的express.urlencoded就是基于body-parser这个进一步封装的**\n\n### 3.4自定义中间件\n\n#### 1.步骤\n\n实现步骤：\n\n1. 定义中间件\n2. 监听req的data事件\n3. 监听req的end事件\n4. 使用queryString模块解析请求体数据\n5. 将解析出来的数据对象挂载为req.body\n6. 将子定义中间件封装为模块\n\n#### 2.定义\n\n通过app.use()定义\n\n#### 3.监听req的data事件\n\n通过监听req的data事件，就可以获取客户端发送到服务器的数据\n\n**如果数据量比较大，客户端会把数据切割分批发送到服务器**\n\n```js\n  //1.定义变量存储客户端发送的请求体数据\n  let str = ''\n  //2.监听req的data事件\n  req.on('data', (chunk) => {\n    str+=chunk\n```\n\n#### 4.监听req的end事件\n\n当end事件触发，代表数据接收完毕\n\n```js\nreq.on('end', () => {\n    //在str村发的是完整的请求体数据\n    //TODO:把字符串请求体数据，转换成对象格式\n  })\n```\n\n#### 5.使用querystring解析请求体数据\n\n```js\n   const body = qs.parse(str)\n    console.log(body)\n```\n\n![image-20240326200337095](Express使用.assets/image-20240326200337095.png)\n\n#### 6.将解析出来的数据对象挂载为req.body\n\n```js\n    req.body = body\n    next()\n```\n\n![image-20240326200614669](Express使用.assets/image-20240326200614669.png)\n\n#### 7.将子定义中间件封装为模块\n\n为了优化代码，需要把子定义中间件封装为独立模块\n\n## 4.使用Express写接口\n\n### 4.1创建最基本的Express服务器\n\n```js\nconst express = require('express')\nconst app = express()\n\napp.listen(80, () => {\n  console.log('Running...')\n})\n```\n\n### 4.2创建API路由模块\n\n```js\nconst express = require('express')\nconst router = express.Router\n\napp.listen(80, () => {\n  console.log('Running')\n})\n\nmodule.exports(router)\n```\n\n### 4.3编写GET接口\n\n```js\nrouter.get('/get', (req, res) => {\n  //通过req.query获取查询字符串，发送到服务器的数据\n  const query = req.query\n  //调用res.send()方法，向客户端相应处理的结果\n  res.send({\n    status: 0,//0成功\n    msg: 'GET 请求成功',\n    data:query\n  })\n})\n```\n\n通过上述操作成功获得了数据\n\n![image-20240326202743866](Express使用.assets/image-20240326202743866.png)\n\n### 4.4编写POST接口\n\n```JS\nrouter.post('/post', (req, res) => {\n  //获取请求体包含的url-encoded格式数据\n  const body = req.body\n  //通过send方法，响应结果\n  res.send({\n    status: 0,\n    msg: 'POST请求成功',\n    data:body\n  })\n})\n```\n\n成功获取了表单数据\n\n![image-20240326203222926](Express使用.assets/image-20240326203222926.png)\n\n### 4.5CORS跨域资源共享\n\n#### 1.接口的跨域问题\n\n==严重的问题==\n\n编写的接口不支持跨域问题。\n\n**解决接口的跨域问题主要有两种方法**\n\n> 1.CORS(主流的解决方案，推荐)\n>\n> 2.JSONP(有缺陷，只支持GET)\n>\n> 也可以使用响应头\n\n#### 2.使用CORS中间件\n\n使用步骤\n\n1. 运行 npm install cors\n2. 使用 const cors=require('cors')\n\n3. app.use(cors())\n\n#### 3.什么是CORS\n\n> cors跨区域资源共享由一系列HTTP响应头组成，这些HTTP响应头决定浏览器是否组织前端js代码是否共享\n\n#### 4.cors注意\n\n>1. cors主要在服务器端进行部署，客户端浏览器无需做任何配置\n>2. cors在浏览器中由兼容性，支支持XMLHttpRequest Level2的浏览器，才能正常访问开启了cors的服务器端接口\n\n#### 5.cors响应头部- Access-Control-Allow-Origin\n\n响应头部中携带一个 Access-Control-Allow-Origin 字段其语法如下\n\n```js\nAccess-Control-Allow-Origin:<origin>|*\n```\n\n其中 origin参数的值制定了允许访问人该资源的外域URL。\n\n例如，下面字段将只允许来自http://itcast.cn的请求\n\n```js\nres.setHeader('Access-Control-Allow-Origin','http//itcast.cn')\n```\n\n*****号代表通配符，表示允许任何域名请求\n\n#### 6.cors响应头 Access-Control-Allow-Headers\n\n![image-20240326213549750](Express使用.assets/image-20240326213549750.png)\n\n```js\n//允许客户端向服务器发送 Content-Type请求头和 X-Custom-Header请求头\n//多个请求头之间用 “，”分隔\nres.setHeader('Access-Control-Allow-Headers','Content-Type,X-Custom-Header')\n```\n\n#### 7.cors响应头部 - Access-Control-Allow-Methods\n\n默认情况下，cors仅支持客户端发起==GET、POST、HEAD==请求\n\n如果客户端希望通过 ==PUT、DELETE==等方式请求服务器，需要在该响应头指明允许所使用的HTTP方法\n\n#### 8.cors请求的分类\n\n简单请求、预检请求\n\n#### 9.简单请求\n\n![image-20240327224520915](Express使用.assets/image-20240327224520915.png)\n\n#### 10.预检请求\n\n符合以下任何一个条件按\n\n>1. 请求方式为GET\\POST\\HEAD之外的Method类型\n>2. 请求头中包含自定义头部字段\n>3. 向服务器发送了application\\json格式的数据\n\n在浏览器和服务器正式通信之前，浏览器会先发送OPTION请求进行预检，以获知服务器是否允许该实际请求，**服务器成功响应预检请求之后，才会发送真正的请求，并且携带真实数据。\n\n#### 11.简单请求和预检请求的区别\n\n> 网络请求的特点：客户端和服务器之间之会发生一次请求\n>\n> 预检请求的特点：客户端与服务器直接会发生两次请求，OPTION预检请求成功之后，才会发其真正的请求\n\n### 4.6JSONP接口\n\n#### 1.jsonp的概念和特点\n\n**概念**\n\n浏览器通过<scirpt>标签的src属性，请求服务器上的数据，同时，服务器返回一个函数的调用，这种请求的方式叫做jsonp。\n\n---\n\n**特点**\n\n1. jsonp不属于真正的ajax请求，因为他没有使用XMLHTTPRequest这个对象\n2. jsonp仅支持GET请求，不支持其他请求\n\n#### 2.创建jsonp接口的注意事项\n\n如果已经配置了CORS跨域资源共享，必须在配置CORS之前配置jsonp接口\n\n```JS\napp.get('/api/jsonp', (req, res) => {\n  //TODO 创建\n})\n//必须在配置cors之前配置jsonp\napp.use(cors())\n```\n\n#### 3.实现jsonp接口\n\n**步骤：**\n\n>1. 获取客户端发送过来的回调函数的名字\n>2. 得到通过jsonp形式发送给客户端的数据\n>3. 根据前两步得到的数据，拼接处一个函数调用的字符串\n>4. 把上一步拼接得到的字符串，响应给客户端<script>标签进行解析执行。\n\n#### 4.具体步骤\n\n```JS\n  //TODO 创建\n  //得到函数名称\n  const funcName = req.query.callback\n  //2.得到数据对象\n  const data = { name: 'zs', age: '20' }\n  //拼接\n  const str = `${funcName}(${JSON.stringify(data)})`\n  //响应\n  res.send(str)\n})\n```\n\n#### 5.使用JQUERY发起jsonp请求\n\n略\n","tags":["express","入门"],"categories":["node.js"]}]